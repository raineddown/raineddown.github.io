<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Netty学习3.7-关闭服务</title>
      <link href="/2021/04/16/Netty%E5%AD%A6%E4%B9%A03-7-%E5%85%B3%E9%97%AD%E6%9C%8D%E5%8A%A1/"/>
      <url>/2021/04/16/Netty%E5%AD%A6%E4%B9%A03-7-%E5%85%B3%E9%97%AD%E6%9C%8D%E5%8A%A1/</url>
      
        <content type="html"><![CDATA[<h2 id="主线："><a href="#主线：" class="headerlink" title="主线："></a>主线：</h2><p><img src="/img/netty/关闭服务.png" alt="关闭服务"></p><h2 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析:"></a>源码解析:</h2><p>先在服务端加个断点和修改下代码：如图：<br><img src="/img/netty/关闭服务1.png" alt="关闭服务"><br> 然后启动server和client;然后跳过bossGroup到workerGroup;进入workerGroup的关闭：在此之前呢，先在NioEventLoop里面的关闭处打个断点：<br><img src="/img/netty/关闭服务2.png" alt="关闭服务"><br> 然后跟进来看看closeAll();<br><img src="/img/netty/关闭服务3.png" alt="关闭服务"><br> 这里selectAgain();目的是为了去除canceled的key，接下来的key都是有效的key了。完成之后接着回去<br><img src="/img/netty/关闭服务4.png" alt="关闭服务"><br> 进入到confirmShutdown();<br><img src="/img/netty/关闭服务5.png" alt="关闭服务"><br> 这里会run Task和hook;挨个执行则返回：<br><img src="/img/netty/关闭服务6.png" alt="关闭服务"></p><h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><pre><code>①关闭服务本质：    关闭所有连接及Selector:    java.nio.channels.Selector#keys    java.nio.channels.spi.AbstractInterruptibleChannel#close    java.nio.channels.SelectionKey#cancel    selector.close();    关闭所有线程：退出循环体for(;;).②关闭服务要点:    优雅(DEFAULT_ SHUTDOWN_ _QUIET_ PERIOD )    可控(DEFAULT_ SHUTDOWN_ _TIMEOUT)    先不接活,后尽量干完手头的活(先关boss后关worker: 不是100%保证)</code></pre>]]></content>
      
      
      <categories>
          
          <category> netty </category>
          
      </categories>
      
      
        <tags>
            
            <tag> netty </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Netty学习3.6-断开连接</title>
      <link href="/2021/04/15/Netty%E5%AD%A6%E4%B9%A03-6-%E6%96%AD%E5%BC%80%E8%BF%9E%E6%8E%A5/"/>
      <url>/2021/04/15/Netty%E5%AD%A6%E4%B9%A03-6-%E6%96%AD%E5%BC%80%E8%BF%9E%E6%8E%A5/</url>
      
        <content type="html"><![CDATA[<h2 id="主线"><a href="#主线" class="headerlink" title="主线:"></a>主线:</h2><p><img src="/img/netty/断开连接.png" alt="断开连接"></p><h2 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析:"></a>源码解析:</h2><p>在NioEventLoop的unsafe.read()打断点<br><img src="/img/netty/断开连接1.png" alt="断开连接"><br>在客户端关闭的地方也加个断点,并且修改点代码:<br><img src="/img/netty/断开连接2.png" alt="断开连接"><br>然后启动server和client;就会发现代码停在关闭的地方：<br><img src="/img/netty/断开连接3.png" alt="断开连接"><br>当下一步的时候，则会来到最开始的断点：<br><img src="/img/netty/断开连接4.png" alt="断开连接"><br>这个时候的unsafe就是NioSocketChannel,继续跟进并在下图的“doReadBytes()”打个断点：<br><img src="/img/netty/断开连接5.png" alt="断开连接"><br>继续跟进：<br><img src="/img/netty/断开连接6.png" alt="断开连接"><br>再进入writeBytes():<br><img src="/img/netty/断开连接7.png" alt="断开连接"><br>这个时候writtenBytes=-1， -1表示正常关闭，然后返回-1；接着回去<br><img src="/img/netty/断开连接8.png" alt="断开连接"><br>进入closeOnRead();<br><img src="/img/netty/断开连接9.png" alt="断开连接"><br>再进入close();一直跟进后：<br><img src="/img/netty/断开连接10.png" alt="断开连接"><br>这里this.outboundBuffer=nul;表示不接受消息，接着往下走有个doClose0();<br><img src="/img/netty/断开连接11.png" alt="断开连接"><br>一直跟进去，直到看到javaChannel.close();<br><img src="/img/netty/断开连接12.png" alt="断开连接"><br>这个其实就是调用jdk:<br><img src="/img/netty/断开连接13.png" alt="断开连接"><br>再继续跟进：<br><img src="/img/netty/断开连接14.png" alt="断开连接"><br>就是将SelectionKey从Selector上cancel掉，这样的话这个Selector上就不会发生这个Channel的event了！接着返回<br><img src="/img/netty/断开连接15.png" alt="断开连接"><br>一直跟进：<br><img src="/img/netty/断开连接16.png" alt="断开连接"><br>点进去不妨可以看出：<br><img src="/img/netty/断开连接17.png" alt="断开连接"><br>它也做了一次cancel;<br><img src="/img/netty/断开连接18.png" alt="断开连接"><br>跳转回来一次正常的关闭就结束了<br><img src="/img/netty/断开连接19.png" alt="断开连接"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结:"></a>总结:</h2><p>连接关闭本质：</p><pre><code>java.nio.channels.spi.AbstractInterruptibleChannel#close;java.nio.channels.SelectionKey#cancel关闭连接，会触发OP_READ方法。读取字节数是-1代表关闭数据读取进行时，强行关闭，触发IO Exception，进而执行关闭Channel的关闭包含了SelectKey的cancel.</code></pre>]]></content>
      
      
      <categories>
          
          <category> netty </category>
          
      </categories>
      
      
        <tags>
            
            <tag> netty </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Netty学习3.5-发送数据</title>
      <link href="/2021/04/14/Netty%E5%AD%A6%E4%B9%A03-5-%E5%8F%91%E9%80%81%E6%95%B0%E6%8D%AE/"/>
      <url>/2021/04/14/Netty%E5%AD%A6%E4%B9%A03-5-%E5%8F%91%E9%80%81%E6%95%B0%E6%8D%AE/</url>
      
        <content type="html"><![CDATA[<h2 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h2><p>  开始之前先介绍下Netty写数据的三种方式：</p><pre><code>①：write:写到一个buffer,flush：把buffer里的数据发送出去②：writeAndFlush:写到buffer,立马发送③：write和flush之间有个ChannelOutboundBuffer</code></pre><p>　可以用生活中快递场景来类比下：</p><p>　　write相当于揽收到仓库，flush相当于从仓库发货，writeAndFlush相当于揽收到仓库立马就发货（类似加急件），ChannelOutboundBuffer相当于揽收和发货之间有个缓冲的仓库</p><h2 id="主线"><a href="#主线" class="headerlink" title="主线:"></a>主线:</h2><p><img src="/img/netty/发送数据.png" alt="发送数据"></p><h2 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析:"></a>源码解析:</h2><p>在channelRead()加入断点，启动服务端和客户端<br><img src="/img/netty/发送数据1.png" alt="发送数据"><br>开始跟进ctx.write();一直跟下回来到：<br><img src="/img/netty/发送数据2.png" alt="发送数据"><br>然后继续跟进invokeWrte();<br><img src="/img/netty/发送数据3.png" alt="发送数据"><br>然后跟进invokeWrite0();<br><img src="/img/netty/发送数据4.png" alt="发送数据"><br>再继续跟进write(),一步一步则会进入到这：<br><img src="/img/netty/发送数据5.png" alt="发送数据"><br>上图代码执行的地方就相当于发快递的仓库这一步骤；继续往下走则能看到：<br><img src="/img/netty/发送数据6.png" alt="发送数据"><br>可以简单进去看一看：<br><img src="/img/netty/发送数据7.png" alt="发送数据"><br>它是添加到队尾；接着继续下边的“incrementPendingOutboundBytes（）”；<br><img src="/img/netty/发送数据8.png" alt="发送数据"><br>判断待发送的数据的size是否高于高水位线，如果高于则修改为不可写状态。然后跳出来，write()完成之后开始发送了：在发送的地方加一个断点：<br><img src="/img/netty/发送数据9.png" alt="发送数据"><br>套路一样：<br><img src="/img/netty/发送数据10.png" alt="发送数据"><br>然后找到flush()<br><img src="/img/netty/发送数据11.png" alt="发送数据"><br>再继续跟进：<br><img src="/img/netty/发送数据12.png" alt="发送数据"><br>addFlush()就表示要装车发货了，跟进看看：<br><img src="/img/netty/发送数据13.png" alt="发送数据"><br>它的意思就是把unflushedEntry里面的数据转Flush里面去。然后跳回去：<br><img src="/img/netty/发送数据14.png" alt="发送数据"><br>进入flush0();<br><img src="/img/netty/发送数据15.png" alt="发送数据"><br>进入doWrite()；<br><img src="/img/netty/发送数据16.png" alt="发送数据"><br>挨个走就是调用jdk的实现</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>  写的本质：</p><pre><code>-single write:sun.nio.ch.SocketChannelImpl#write(java.nio.ByteBuffer)（单个写）-gathering write:sun.nio.ch.SocketChannelImpl#write(java.nio.ByteBuffer[],int,int)（批量写）</code></pre><p>  写数据写不进去时，会停止写，注册一个OP_WRITE事件，来通知什么时候可以写进去</p><p>  OP_WRITE不是说有数据可写，而是说可以写进去，所以正常情况，不能注册，否则一直触发</p><p>  批量写数据时，如果尝试写的都写进去了，接下来会尝试写更多（maxBytesPerGatheringWrite)。</p><p>　　只要有数据要写，且能写，则一直尝试，直到16次（writeSpinCount），写16次还没有写完，就直接schedule一个task来继续写，而不是   用注册写事件来触发，更简洁有力。</p><p>  待写数据太多，超过一定的水位线（writeBufferWaterMark.high()）,会将可写的标志位改成false,让应用端自己做决定要不要继续写。</p><p>  channelHandlerContext.channel().write():从TailContext开始执行；　　</p><p>  channelHandlerContext.write():从当前的Context开始。</p>]]></content>
      
      
      <categories>
          
          <category> netty </category>
          
      </categories>
      
      
        <tags>
            
            <tag> netty </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Netty学习3.3-接受数据</title>
      <link href="/2021/04/12/Netty%E5%AD%A6%E4%B9%A03-3-%E6%8E%A5%E5%8F%97%E6%95%B0%E6%8D%AE/"/>
      <url>/2021/04/12/Netty%E5%AD%A6%E4%B9%A03-3-%E6%8E%A5%E5%8F%97%E6%95%B0%E6%8D%AE/</url>
      
        <content type="html"><![CDATA[<h2 id="主线worker-thread"><a href="#主线worker-thread" class="headerlink" title="主线worker thread"></a>主线worker thread</h2><p>①多路复用器（Selector）接受到OP_READ事件</p><p>②处理OP_READ事件：NioSocketChannel.NioSocketChannelUnsafe.read();</p><pre><code>-1分配一个初始1024字节的byte buffer来接受数据-2从Channel接受数据到byte buffer-3记录实际接受数据大小，调整下次分配byte buffer大小-4触发pipeline.fireChannelRead(byteBuf)把读取到的数据传播出去-5判断接受byte buffer是否满载而归，是:尝试继续读取直到没有数据或满16次，否:结束本轮读取，等待下次OP_READ事件</code></pre><h2 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析:"></a>源码解析:</h2><p>在NioEventLoop中的processSelectedKey()的unsafe.read()加个断点<br><img src="/img/netty/接受数据.png" alt="Netty接受数据"><br>然后启动服务端和客户端…第一次启动的时候如下图：<br><img src="/img/netty/接受数据1.png" alt="Netty接受数据"><br>这里的channel=NioServerSocketChannel.处理的是OP_ACCEPT，我们直接放行，断点还停留在原地看看效果：<br><img src="/img/netty/接受数据2.png" alt="Netty接受数据"><br>可以清楚的看到这时候的channel=NioSocketChannel;这个时候我们跟进去看看：<br><img src="/img/netty/接受数据3.png" alt="Netty接受数据"><br>进入read()方法后可以看到这行代码，byteBuf = allocHandle.allocate(allocator);表示尽可能分配合适的大小：“guess”;下面一行“allocHandle.lastBytesRead(doReadBytes(byteBuf));”则表示读并且记录读了多少，如果读满了下次继续的话直接扩容；先跟进看看allocate();<br><img src="/img/netty/接受数据4.png" alt="Netty接受数据"><br>然后在进去guess();<br><img src="/img/netty/接受数据5.png" alt="Netty接受数据"><br>进来可以发现返回的是“1024”，接着往下走：<br><img src="/img/netty/接受数据6.png" alt="Netty接受数据"><br>进入doReadBytes()；<br><img src="/img/netty/接受数据7.png" alt="Netty接受数据"><br>可以发现这里有一个“byteBuf.writeBytes()”；接着跟进去看看：<br><img src="/img/netty/接受数据8.png" alt="Netty接受数据"><br>再跟进”setBytes()”<br><img src="/img/netty/接受数据9.png" alt="Netty接受数据"><br>这里就能看出来是“SocketChannel.read()”;然后再接着往下执行返回：<br><img src="/img/netty/接受数据10.png" alt="Netty接受数据"><br>不难看出读取了一次：<br><img src="/img/netty/接受数据11.png" alt="Netty接受数据"><br>下面的pipeline.fireChannelRead(byteBuf);则是处理业务逻辑的地方，pipeline上执行，继续往下走：<br><img src="/img/netty/接受数据12.png" alt="Netty接受数据"><br>allocHandle.readComplete();记录这次读事件共读了多少数据，计算下次分配的大小<br>pipeline.fireChannelReadComplete();相当于完成本次读事件的处理</p><h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><pre><code>读取数据的本质：sun.nio.ch.SocketChannelImpl#read(java.nio.ByteBuffer)NioSocketChannel read()是读数据，NioServerSocketChannel read()是创建连接 pipeline.fireChannelReadComplete();表示一次事件处理完成pipeline.fireChannelRead(byreBuf);一次读取数据完成，一次读事件处理可能会包含多次读数据操作为什么最多只尝试读取16次？“雨露均沾”</code></pre><p>　　AdaptiveRecvByteBufAllocator对bytebuf的猜测：放大果断，缩小谨慎（需要连续两次判断）</p>]]></content>
      
      
      <categories>
          
          <category> netty </category>
          
      </categories>
      
      
        <tags>
            
            <tag> netty </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Netty学习3.2-构建连接</title>
      <link href="/2021/04/11/Netty%E5%AD%A6%E4%B9%A03-2-%E6%9E%84%E5%BB%BA%E8%BF%9E%E6%8E%A5/"/>
      <url>/2021/04/11/Netty%E5%AD%A6%E4%B9%A03-2-%E6%9E%84%E5%BB%BA%E8%BF%9E%E6%8E%A5/</url>
      
        <content type="html"><![CDATA[<h2 id="主线："><a href="#主线：" class="headerlink" title="主线："></a>主线：</h2><p>　　和启动一样也是有两个线程完成的，boss thread 和 worker thread;</p><p>boss thread:</p><p>　　　①NioEventLoop中的selector轮询创建连接事件（OP_ACCEPT）</p><p>　　　②创建socket channel</p><p>　　　③初始化socket channel 并从 worker group 中选择一个NioEventLoop</p><p>worker thread:</p><p>　　　④将socket channel 注册到选择的NioEventLoop的selector</p><p>　　　⑤注册读事件（OP_READ）到selector上</p><h2 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析:"></a>源码解析:</h2><p>在NioEventLoop中找到run();在run()里面有个processSelectedKeys();<br><img src="/img/netty/构建连接.png" alt="Netty构建连接"><br>点进去后<br><img src="/img/netty/构建连接2.png" alt="Netty构建连接"><br>其中processSelectedKeysOptimized();不用jdk的selector.selectedKeys(),性能更好，垃圾回收更少；接着跟进去；<br><img src="/img/netty/构建连接3.png" alt="Netty构建连接"><br>打上断点，这个地方开始就轮询事件了。然后debug启动服务端和客户端<br><img src="/img/netty/构建连接4.png" alt="Netty构建连接"><br>然后进入该方法，然后依次执行；<br><img src="/img/netty/构建连接5.png" alt="Netty构建连接"><br>其中16就代表着OP_ACCEPT；进入unsafe.read().中有这么个代码<br><img src="/img/netty/构建连接6.png" alt="Netty构建连接"><br>接着再进doReadMessages();SocketChannel ch = SocketUtils.accept(javaChannel());表示接受新连接创建SocketChannel;<br><img src="/img/netty/构建连接7.png" alt="Netty构建连接"><br>接着再跟进去<br><img src="/img/netty/构建连接8.png" alt="Netty构建连接"><br>上图的断点return serverSocketChannel.accept();表示非阻塞模式下，没有连接请求时返回null；接着继续往下走会来到这个地方：<br><img src="/img/netty/构建连接9.png" alt="Netty构建连接"><br>pipeline.fireChannelRead(readBuf.get(i));可以看出有多个handler,接着找到ServerBootstrapAcceptor这个handler,然后找到channelRead()方法，打个断点跳过来：<br><img src="/img/netty/构建连接10.png" alt="Netty构建连接"><br>往下走childGroup.register(child).addListener();加个断点跟进去：<br><img src="/img/netty/构建连接11.png" alt="Netty构建连接"><br>然后在一步一步的跟进register()后来到下面的代码，打个断点之后再跟进：<br><img src="/img/netty/构建连接12.png" alt="Netty构建连接"><br>进入register0()<br><img src="/img/netty/构建连接13.png" alt="Netty构建连接"><br>看到熟悉的doRegister(),跟进去看看：<br><img src="/img/netty/构建连接14.png" alt="Netty构建连接"><br>这里和上篇源码解释的一样，继续往下走：<br><img src="/img/netty/构建连接15.png" alt="Netty构建连接"><br>再跳转到head上，找到read()方法：<br><img src="/img/netty/构建连接16.png" alt="Netty构建连接"><br>然后进去看看<br><img src="/img/netty/构建连接17.png" alt="Netty构建连接"><br>又看到熟悉的doBeginRead();跟进去看看<br><img src="/img/netty/构建连接18.png" alt="Netty构建连接"><br>与之不同的是这时候readInterestOp不是16而是1了，是OP_READ而非OP_ACCEPT了。这时候已经走完了。可以看控制台：<br><img src="/img/netty/构建连接19.png" alt="Netty构建连接"></p><h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><p>接收连接的本质：</p><p>selector.select()/selectNow()/select(timeoutMillis)轮询发现OP_ACCEPT事件，处理：</p><pre><code>SocketChannel socketChannel = serverSocketChannel.accopt();selectionKey = javaChannel().register(eventLoop().unwrappedSelector(),0,this);selectKey.interestOps(OP_READ);　　　　</code></pre><p>创建连接的初始化和注册是通过pipeline.fireChannelRead在ServerBootstrapAcceptor中完成的。</p><p>第一次Register并不是监听OP_READ,而是0；</p><pre><code>selectionKey = javaChannel().register(eventLoop().unwrappedSelector(),0,this);</code></pre><p>最终监听OP_READ是通过“Register”完成后的fireChannelActive（io.netty.channel.AbstractChannel.AbstractUnsafe#register0中）来触发的；</p><p>Worker’s NioEventLoop是通过Register操作执行来启动。</p><p>接受连接的读操作，不会尝试读取更多次（16次）。</p>]]></content>
      
      
      <categories>
          
          <category> netty </category>
          
      </categories>
      
      
        <tags>
            
            <tag> netty </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Netty学习3.1-启动服务</title>
      <link href="/2021/04/10/Netty%E5%AD%A6%E4%B9%A03-1-%E5%90%AF%E5%8A%A8%E6%9C%8D%E5%8A%A1/"/>
      <url>/2021/04/10/Netty%E5%AD%A6%E4%B9%A03-1-%E5%90%AF%E5%8A%A8%E6%9C%8D%E5%8A%A1/</url>
      
        <content type="html"><![CDATA[<h2 id="主线分两步"><a href="#主线分两步" class="headerlink" title="主线分两步"></a>主线分两步</h2><p>　　一：首先在our thread里，如果写在main方法中则就是main thread;</p><p>①：创建selector;</p><p>②：创建server socket channel;</p><p>③：初始化server socket channel;</p><p>④：给server socket channel 从boss  group中选择一个NioEventLoop;</p><p>　　二：boss thread：</p><p>⑤：将server socket channel注册到选择的NioEventLoop的selector(上一步创建的selector)</p><p>⑥：绑定地址启动</p><p>⑦：注册接收连接事件（OP_ACCEPT）到selector上</p><h2 id="代码演示"><a href="#代码演示" class="headerlink" title="代码演示"></a>代码演示</h2><p>首先在代码启动的地方加断点，并且在NioEventLoop.java中的openSelector()上也加一个断点（用于验证selector什么时候被创建），如下图：<br><img src="/img/netty/启动服务.png" alt="Netty启动服务"><br><img src="/img/netty/启动服务1.png" alt="Netty启动服务"><br>Debug启动后会进入上图第一个断点，放行后进入openSelector()的这个断点上，通过观察Frames区域可以发现selector是在刚才第一个断点的时候就被创建了，即“EventLoopGroup bossGroup = new NioEventLoopGroup();”的时候：<br><img src="/img/netty/启动服务2.png" alt="Netty启动服务"><br>好的，继续放行之后则回来到开启服务的断点：<br><img src="/img/netty/启动服务3.png" alt="Netty启动服务"><br>不难看出有个sync()，它表示阻塞，也就是说启动本身是个异步的过程，.sync()代表要启动完才能进行下一步；接下来进入bind()方法看看，一直跟进，直到进入doBind();在如图的两个地方加上断点：<br><img src="/img/netty/启动服务4.png" alt="Netty启动服务"><br>上图的“final ChannelFuture regFuture = initAndRegister();”;initAndRegister()实际表示三步：①创建一个server socket channel，②初始化server socket channel，③将server socket channel注册到NioEventLoop的selector上。创建完成之后返回的是regFuture；通过名字“Future”就可以知道它是异步过程；所以上图第一个断点不一定能注册完成，因为注册是丢到NioEventLoop里面去执行去了，所以有个第二个断点：等着注册完成之后来通知再执行bind。然后我们跟进去看看initAndRegister()：<br><img src="/img/netty/启动服务5.png" alt="Netty启动服务"><br>不难看出先通过工厂创建后初始化，接着跟进init(channel)方法:挨个下一步可以看到这段代码：<br><img src="/img/netty/启动服务6.png" alt="Netty启动服务"><br>这里的ChannelInitializer一次性，初始化hander，负责添加一个ServerBootstrapAcceptor hander,添加完成后自己就移除了，其中ServerBootstrapAcceptor hander负责接收客户端连接创建连接后，对连接的初始化工作。跳回去之后可以看到：<br><img src="/img/netty/启动服务7.png" alt="Netty启动服务"><br>“ChannelFuture regFuture = config().group().register(channel);”的group()就是boss group,跟进register()之后有这个代码，在图中的register0()这边加个断点：<br><img src="/img/netty/启动服务8.png" alt="Netty启动服务"><br>然后跟进eventLoop.execute()方法：<br><img src="/img/netty/启动服务9.png" alt="Netty启动服务"><br>接着进入startThread();<br><img src="/img/netty/启动服务10.png" alt="Netty启动服务"><br>走到这才是正正的启动线程，接着放行则会执行register0();<br><img src="/img/netty/启动服务11.png" alt="Netty启动服务"><br>再跟进register0()方法<br><img src="/img/netty/启动服务12.png" alt="Netty启动服务"><br>跟进doRegister():<br><img src="/img/netty/启动服务13.png" alt="Netty启动服务"><br>这里不难发现它真正在处理了，然后先跳回去，下面这图就是通知我们成功了<br><img src="/img/netty/启动服务14.png" alt="Netty启动服务"><br>继续往下走则会到之前打的一个断点（doBind0()）;<br><img src="/img/netty/启动服务15.png" alt="Netty启动服务"><br>然后继续跟进：<br><img src="/img/netty/启动服务16.png" alt="Netty启动服务"><br>在channel.bind()加一个断点：然后紧接着跳过来在进入bind()方法：<br><img src="/img/netty/启动服务17.png" alt="Netty启动服务"><br>可以看到pipeline.bind();Netty是串行化的操作，pipeline里面有各种各样的hander,除了上图截图显示的hander,每个pipeline都有head和tail 的hander;如下显示：<br><img src="/img/netty/启动服务18.png" alt="Netty启动服务"><br>这里我们跳到head的hander;操作如下：<br><img src="/img/netty/启动服务19.png" alt="Netty启动服务"><br>跳过来之后查找bind()方法如图，<br><img src="/img/netty/启动服务20.png" alt="Netty启动服务"><br>找到之后在unsafe.bind()加一个断点：<br><img src="/img/netty/启动服务21.png" alt="Netty启动服务"><br>跳过来进入bind()方法看看：<br><img src="/img/netty/启动服务22.png" alt="Netty启动服务"><br>可以看到这一步：do开头的几乎都是表示执行！在跟进去看看：<br><img src="/img/netty/启动服务23.png" alt="Netty启动服务"><br>这时候就能看到bind了，然后继续<br><img src="/img/netty/启动服务24.png" alt="Netty启动服务"><br>这里的就是绑定后开始激活，在pipeline.fireChannelActive()加一个断点，跳过来后：<br><img src="/img/netty/启动服务25.png" alt="Netty启动服务"><br>和之前一样，跳到head上；然后查找ChannelActive();<br><img src="/img/netty/启动服务26.png" alt="Netty启动服务"><br>打上断点如图，接着跳过来，其中readIfIsAutoRead()就是注册读事件，读包括：创建连接、读数据，这里指的是创建连接。跟进方法：<br><img src="/img/netty/启动服务27.png" alt="Netty启动服务"><br>继续跟进：<br><img src="/img/netty/启动服务28.png" alt="Netty启动服务"><br>能看出pipeline.read();这时候打开之前跳转过来的pipeline的head里找到read()；<br><img src="/img/netty/启动服务29.png" alt="Netty启动服务"><br>加个断点接着跳过来，这里unsafe.beginRead();实际上就是注册OP_ACCEPT/OP_READ事件；创建连接或者读事件。接着跟进：<br><img src="/img/netty/启动服务30.png" alt="Netty启动服务"><br>实际它是调用的doBeginRead();<br><img src="/img/netty/启动服务31.png" alt="Netty启动服务"><br>继续跟进：<br><img src="/img/netty/启动服务32.png" alt="Netty启动服务"><br> 走到这里就开始注册OP_ACCEPT=16。</p><h2 id="总结：启动服务的本质："><a href="#总结：启动服务的本质：" class="headerlink" title="总结：启动服务的本质："></a>总结：启动服务的本质：</h2><pre><code>//首先创建selector</code></pre><p>　　Selector selector = sun.nio.ch.SelectorProviderImpl.openSelector();<br>    //创建ServerSocketChannel<br>　　ServerSocketChannel serverSocketChannel = provider.openServerSocketChannel();<br>    //ServerSocketChannel绑定到selector上<br>　　selectionKey = javaChannel().register(eventLoop().unwrappedSelector(),0,this);<br>    //绑定地址<br>　　javaChannel().bind(localAddress,config.getBacklog());<br>    //做好连接准备<br>　　selectionKey.interestOps(OP_ACCEPT);</p><p>Selector是在new NioEventLoopGroup()（创建一批NioEventLoop）时创建的</p><p>第一次Register并不是监听OP_ACCEPT，而是0；</p><p>　　selectionKey = javaChannel().register(eventLoop().unwrappedSelector(),0,this);</p><p>最终监听OP_ACCEPT是通过bind完成后的fireChannelActive()来触发的。</p><p>NioEventLoop是通过Register操作的执行来完成启动的</p><p>类似ChannelInitializer，一些Hander可以设计成一次性的，用完就移除，比如授权。</p>]]></content>
      
      
      <categories>
          
          <category> netty </category>
          
      </categories>
      
      
        <tags>
            
            <tag> netty </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Netty学习3.0-Netty代码编译</title>
      <link href="/2021/04/09/Netty%E5%AD%A6%E4%B9%A03-0-Netty%E4%BB%A3%E7%A0%81%E7%BC%96%E8%AF%91/"/>
      <url>/2021/04/09/Netty%E5%AD%A6%E4%B9%A03-0-Netty%E4%BB%A3%E7%A0%81%E7%BC%96%E8%AF%91/</url>
      
        <content type="html"><![CDATA[<h2 id="Netty各部分作用"><a href="#Netty各部分作用" class="headerlink" title="Netty各部分作用"></a>Netty各部分作用</h2><p>Netty结构:<br><img src="/img/netty/Netty4.1.png" alt="Netty结构"></p><ul><li><p>netty-buffer提供字节buffer功能。Netty 的 ByteBuf<br>相当于 JDK 的ByteBuffer，ByteBuf的作用是在 Netty 中通过 Channel 传输数据。它被重新设计以解决 JDK<br>的 ByteBuffer 中的一些问题， 从而使开发人员开发网络应用程序显得更有效率。</p></li><li><p>netty-codec 处理TCP粘包半包，二次编译问题</p></li><li><p>nety-codec-dns到netty-codec-xml Netty对各个协议的支持(mqtt物联网轻量级消息队列协议)</p></li><li><p>netty-common Netty常用工具类，concurrent包下各种多线程的类。</p></li><li><p>netty-example实例</p></li><li><p>netty-handle 自定义服务，各种经常用的功能</p></li><li><p>netty-handle-proxy 代理层handle</p></li><li><p>netty-microbench 测试用</p></li><li><p>netty-resolver netty-resolver-dns 地址解析</p></li><li><p>netty-transpot 传输层协议</p></li></ul><h2 id="Netty常见问题"><a href="#Netty常见问题" class="headerlink" title="Netty常见问题:"></a>Netty常见问题:</h2><p><img src="/img/netty/NettyProblem.png" alt="Netty结构"><br>原因：未自动执行脚本，，解决方式:<br><img src="/img/netty/NettyProblem1.png" alt="Netty结构"></p>]]></content>
      
      
      <categories>
          
          <category> netty </category>
          
      </categories>
      
      
        <tags>
            
            <tag> netty </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Netty学习3.4-业务处理</title>
      <link href="/2021/04/06/Netty%E5%AD%A6%E4%B9%A03-4-%E4%B8%9A%E5%8A%A1%E5%A4%84%E7%90%86/"/>
      <url>/2021/04/06/Netty%E5%AD%A6%E4%B9%A03-4-%E4%B8%9A%E5%8A%A1%E5%A4%84%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h2 id="主线worker-thread"><a href="#主线worker-thread" class="headerlink" title="主线worker thread"></a>主线worker thread</h2><p>触发pipeline.fireChannelRead(byteBuf)把读取到的数据传播出去<br><img src="/img/netty/接受数据.png" alt="业务处理"></p><h2 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析:"></a>源码解析:</h2><p>还和之前一样，在NioEventLoop里面加断点：<br><img src="/img/netty/接受数据1.png" alt="业务处理"><br>然后启动服务端和客户端：效果图：<br><img src="/img/netty/接受数据2.png" alt="业务处理"><br>然后跟进read()；由于步骤和之前的源码差不多，所以这次只挑重点：<br><img src="/img/netty/接受数据3.png" alt="业务处理"><br>这个就是业务处理的入口，所以跟进去看看即可：<br><img src="/img/netty/接受数据4.png" alt="业务处理"><br>这个head表示从头开始的，继续跟进去：<br><img src="/img/netty/接受数据5.png" alt="业务处理"><br>这里的next默认的就是NioEventLoop;所以继续跟进：<br><img src="/img/netty/接受数据6.png" alt="业务处理"><br>继续跟进channelRead();<br><img src="/img/netty/接受数据7.png" alt="业务处理"><br>ctx.fireChannelRead(msg);表示继续在pipeline上传递，继续跟进：<br><img src="/img/netty/接受数据8.png" alt="业务处理"><br>继续跟进方法：<br><img src="/img/netty/接受数据9.png" alt="业务处理"><br>接着往下走：<br><img src="/img/netty/接受数据10.png" alt="业务处理"><br>这里就相当于就算运算结果。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>处理业务的本质：数据在pipeline中所有的handler的channelRead()执行过程</p><pre><code>前提：Handler要实现io.netty.channel.ChannelInboundHandler#channelRead(ChannelHandlerContext ctx,Object msg),且不能加注解@Skip中途可以退出，不保证执行到tail handler</code></pre><p>默认处理线程就是Channel绑定的NioEventLoop线程，也可以设置其他；</p><pre><code>pipeline.addLast(new UnorderedThreadPoolEventExecutor(10),serverHandler)。</code></pre>]]></content>
      
      
      <categories>
          
          <category> netty </category>
          
      </categories>
      
      
        <tags>
            
            <tag> netty </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>netty学习-2.5netty如何玩转内存的使用</title>
      <link href="/2021/04/05/netty%E5%AD%A6%E4%B9%A0-2-5netty%E5%A6%82%E4%BD%95%E7%8E%A9%E8%BD%AC%E5%AF%B9%E5%86%85%E5%AD%98%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>/2021/04/05/netty%E5%AD%A6%E4%B9%A0-2-5netty%E5%A6%82%E4%BD%95%E7%8E%A9%E8%BD%AC%E5%AF%B9%E5%86%85%E5%AD%98%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="内存使用技巧的目标"><a href="#内存使用技巧的目标" class="headerlink" title="内存使用技巧的目标"></a>内存使用技巧的目标</h2><ol><li>内存占用少(空间)</li><li>应用速度快(时间)</li></ol><p>对java而言:减少Full GC的STW(Stop the world)时间</p><h2 id="Netty内存使用技巧"><a href="#Netty内存使用技巧" class="headerlink" title="Netty内存使用技巧"></a>Netty内存使用技巧</h2><ol><li><img src="/img/netty/Netty内存.png" alt="Netty内存"></li></ol><p>2.<br><img src="/img/netty/Netty内存2.png" alt="Netty内存"></p><ol><li><p>结合前2者，包装类换基本类型，不实例使用类变量<br><img src="/img/netty/Netty内存3.png" alt="Netty内存"></p></li><li><p>对分配内存进行预估<br><img src="/img/netty/Netty内存4.png" alt="Netty内存"><br><img src="/img/netty/Netty内存5.png" alt="Netty内存"></p></li><li><p>零复制<br><img src="/img/netty/Netty内存6.png" alt="Netty内存"><br><img src="/img/netty/Netty内存7.png" alt="Netty内存"><br><img src="/img/netty/Netty内存8.png" alt="Netty内存"></p></li><li><p>堆外内存<br><img src="/img/netty/Netty内存9.png" alt="Netty内存"></p></li></ol><ul><li>优点:<br>  更广阔的”空间”，缓解店铺内的压力 -&gt; 破除堆空间限制,减轻GC压力<br>  减少”冗余”细节(假设烧烤过程为了气氛在室外进行: 烤好直接上桌vs烤好还要进店内) -&gt; 避免复制</li><li>缺点:<br>  需要搬桌子 -&gt; 创建速度稍慢<br>  受城管、风险大 -&gt; 堆外内存受操作系统管理</li></ul><p>内存池:<br>内存池生活场景:<br>    点菜单的演进:<br>        一张纸:一桌客人一张纸<br>        点菜平板:循环使用</p><p>为什么引入对象池:<br>    创建对象开销大<br>    对象高频率创建且可复用<br>    支持并发又能保护系统<br>    维护、共享有限的资源</p><p>解决堆外内存的缺点</p><p>如何实现对象池?<br>    开源实现: Apache Commons Pool<br>    netty 轻量级对象池实现 io.netty.util.Recycler</p><h2 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析:"></a>源码解析:</h2><ul><li>内存池/非内存池的默认选择及切换方式?<br>io.netty.channel.DefaultChannelConfig#allocator</li><li>内存池实现(以PooledDirectByteBuf为例)<br>io.netty.buffer.PooledDirectByteBuf</li><li>堆外内存/堆内内存的默认选择及切换方式?</li><li>堆外内存的分配本质?        </li></ul><h3 id="内存池-非内存池的默认选择及切换方式"><a href="#内存池-非内存池的默认选择及切换方式" class="headerlink" title="内存池/非内存池的默认选择及切换方式"></a>内存池/非内存池的默认选择及切换方式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line"><span class="comment">//以io.netty.allocator.typpe为准,没有的话,安卓平台使用非池化，其他池化</span></span><br><span class="line">    String allocType = SystemPropertyUtil.get(</span><br><span class="line">            <span class="string">"io.netty.allocator.type"</span>, PlatformDependent.isAndroid() ? <span class="string">"unpooled"</span> : <span class="string">"pooled"</span>);</span><br><span class="line">    allocType = allocType.toLowerCase(Locale.US).trim();</span><br></pre></td></tr></table></figure><h3 id="内存池实现"><a href="#内存池实现" class="headerlink" title="内存池实现"></a>内存池实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (maxCapacityPerThread == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> newObject((Handle&lt;T&gt;) NOOP_HANDLE);</span><br><span class="line">    &#125;</span><br><span class="line">    Stack&lt;T&gt; stack = threadLocal.get();</span><br><span class="line">    DefaultHandle&lt;T&gt; handle = stack.pop();</span><br><span class="line">    <span class="keyword">if</span> (handle == <span class="keyword">null</span>) &#123;</span><br><span class="line">        handle = stack.newHandle();</span><br><span class="line">        handle.value = newObject(handle);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (T) handle.value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">recycle</span><span class="params">(Object object)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (object != value) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"object does not belong to handle"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Stack&lt;?&gt; stack = <span class="keyword">this</span>.stack;</span><br><span class="line">    <span class="keyword">if</span> (lastRecycledId != recycleId || stack == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"recycled already"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    stack.push(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="堆外内存-堆内内存的默认选择及切换方式"><a href="#堆外内存-堆内内存的默认选择及切换方式" class="headerlink" title="堆外内存/堆内内存的默认选择及切换方式?"></a>堆外内存/堆内内存的默认选择及切换方式?</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; We should always prefer direct buffers by default if we can use a Cleaner to release direct buffers.</span><br><span class="line">&#x2F;&#x2F; 使用堆外内存2个条件: 1 有cleaner方法去释放堆外内存; 2 io.netty.noPreferDirect 不能设置为true</span><br><span class="line">DIRECT_BUFFER_PREFERRED &#x3D; CLEANER !&#x3D; NOOP</span><br><span class="line">                          &amp;&amp; !SystemPropertyUtil.getBoolean(&quot;io.netty.noPreferDirect&quot;, false);</span><br><span class="line">if (logger.isDebugEnabled()) &#123;</span><br><span class="line">    logger.debug(&quot;-Dio.netty.noPreferDirect: &#123;&#125;&quot;, !DIRECT_BUFFER_PREFERRED);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>切换方式： 修改参数io.netty.noPreferDirect</p><h3 id="堆外内存的分配本质"><a href="#堆外内存的分配本质" class="headerlink" title="堆外内存的分配本质"></a>堆外内存的分配本质</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Allocate a new direct &#123;<span class="doctag">@link</span> ByteBuffer&#125; with the given initialCapacity.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> ByteBuffer <span class="title">allocateDirect</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//调用JDK的allocateDirect来分配堆外内存</span></span><br><span class="line">    <span class="keyword">return</span> ByteBuffer.allocateDirect(initialCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ByteBuffer <span class="title">allocateDirect</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> DirectByteBuffer(capacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> netty </category>
          
      </categories>
      
      
        <tags>
            
            <tag> netty </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>netty学习-2.4-netty中的锁</title>
      <link href="/2021/04/05/netty%E5%AD%A6%E4%B9%A0-2-4netty%E4%B8%AD%E7%9A%84%E9%94%81/"/>
      <url>/2021/04/05/netty%E5%AD%A6%E4%B9%A0-2-4netty%E4%B8%AD%E7%9A%84%E9%94%81/</url>
      
        <content type="html"><![CDATA[<h2 id="Netty玩转锁的五个关键点："><a href="#Netty玩转锁的五个关键点：" class="headerlink" title="Netty玩转锁的五个关键点："></a>Netty玩转锁的五个关键点：</h2><p>① 在意锁的对象和范围  —&gt; 减少粒度</p><p>② 注意锁的对象本身大小   —&gt; 减少空间占用</p><p>③ 注意锁的速度 —&gt; 提高速度</p><p>④ 不同场景选择不同的并发类 —&gt;因需而边</p><p>⑤ 衡量好锁的价值 —&gt; 能不用则不用</p><p>接下来按个看看：</p><p>①：在Netty的ServerBootstrap中的init()：<br><img src="/img/netty/锁1.png" alt="Netty锁"><br>上图不难看出来，多处使用了synchronized(){},而并非在inti方法上使用synchronized,如果这么做那么锁的对象就是这个实例，锁的范围则是大括号方法的范围，但是实际上我们不需要这么做，只是把Synchronized method —&gt;Synchronized block，针对上图不同的属性，我们可以分别做锁,这样就减少了锁的范围。</p><p>②：例在ChannelOutboundBuffer中有这样的代码：<br><img src="/img/netty/锁2.png" alt="Netty锁"><br>这个totalPendingSize是统计待发送的字节数<br><img src="/img/netty/锁3.png" alt="Netty锁"></p><p>③例记录内存分配字节数等功能用到的LongCounter,在PlatformDependent的newLongCounter()中<br><img src="/img/netty/锁4.png" alt="Netty锁"><br>上图的代码就是筛选jdk版本然后有不同的返回类型，如果大于等于8则是LongAdderCounter；而LongAdderCounter继承java.util.concurrent.atomic.LongAdder;<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> io.netty.util.internal;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.LongAdder;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">LongAdderCounter</span> <span class="keyword">extends</span> <span class="title">LongAdder</span> <span class="keyword">implements</span> <span class="title">LongCounter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">value</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> longValue();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>高并发时：java.util.concurrent.atomic.AtomicLong -&gt;java.util.concurrent.atomic.LongAdder,特定场景下是优于AtomicLong ；</p><p>⑤ 避免用锁<br><img src="/img/netty/锁5.png" alt="Netty锁"></p>]]></content>
      
      
      <categories>
          
          <category> netty </category>
          
      </categories>
      
      
        <tags>
            
            <tag> netty </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>netty学习-2.3-keepalive与idle监控</title>
      <link href="/2021/04/05/netty%E5%AD%A6%E4%B9%A0-2-3/"/>
      <url>/2021/04/05/netty%E5%AD%A6%E4%B9%A0-2-3/</url>
      
        <content type="html"><![CDATA[<h2 id="学习焦点"><a href="#学习焦点" class="headerlink" title="学习焦点"></a>学习焦点</h2><ul><li>为什么需要keepalive?</li><li>怎么设计keepalive?以TCP keepalive为例</li><li>为什么还需要应用层keepalive?</li><li>idle监测是什么?</li><li>如何在Netty中开启TCP keepalive和idle监测</li></ul><h2 id="为什么需要keepalive"><a href="#为什么需要keepalive" class="headerlink" title="为什么需要keepalive"></a>为什么需要keepalive</h2><h3 id="生活场景"><a href="#生活场景" class="headerlink" title="生活场景:"></a>生活场景:</h3><p>假设你开了一个饭店,,别人电话来订餐,电话通了后，订餐的说了一堆订餐要求,说着说着对方就不讲话了。</p><ul><li>这个时候你会一直握着电话等么?<br>不会</li><li>如果不会，你一般怎么去做?<br>会确认一句”你还在么？”,如果对方没有回复,挂机。这套机制即”keepalive”<br>浪费资源去维持已经坏的连接。</li></ul><h2 id="怎么设计keepalive-以TCP-keepalive为例"><a href="#怎么设计keepalive-以TCP-keepalive为例" class="headerlink" title="怎么设计keepalive?以TCP keepalive为例"></a>怎么设计keepalive?以TCP keepalive为例</h2><p>当启用keepalive时，TCP在连接没有数据按75秒的重试频率重发,一直发9个探测包都没有回复连接失败。<br>总耗时一般为</p><h2 id="为什么还需要应用层keepalive"><a href="#为什么还需要应用层keepalive" class="headerlink" title="为什么还需要应用层keepalive?"></a>为什么还需要应用层keepalive?</h2><p>　　显然是不是的，首先协议分层思想，每层的关注点不同，TCP属于传输层，关注“通”，应用层关注是否能“用”，能“通”不一定能“用”，其次TCP层的Keepalive是默认关闭的，TCP层的keepalive时间太长，如果走默认的话那么它需要的时间为：(7500+75X9);</p><p>　　另外需要注意的是：HTTP是属于应用层协议，我们时常听到一个名词“HTTP Keep-Alive”;指的是对长连接和短连接的选择：</p><p>　　*Connection:Keep-Alive 　　长连接（HTTP/1.1默认长连接，不需要带这个header）</p><p>　　*Connection:Close 　　　　 短连接</p><h2 id="idle监测是什么"><a href="#idle监测是什么" class="headerlink" title="idle监测是什么?"></a>idle监测是什么?</h2><h3 id="生活场景-1"><a href="#生活场景-1" class="headerlink" title="生活场景:"></a>生活场景:</h3><p>假设你开了一个人饭店,别人电话来订餐,电话通了后,订餐的说了一堆订餐要求,说着说着，对方就不讲话了。<br>你会立马发问:你还在么？ 显然不会<br>一般你会稍微等待一定的时间，在这个时间内看看对方还会不会说话(idle检测)如果还不说，认定对方存在问题(Idle),于是开始发问”你还在么？”(keepalive)或者问都不问干脆直接关机(关闭连接)</p><h3 id="idle监测，只是负责诊断，诊断后，，做出不同的行为，，决定idle监测的最终用途"><a href="#idle监测，只是负责诊断，诊断后，，做出不同的行为，，决定idle监测的最终用途" class="headerlink" title="idle监测，只是负责诊断，诊断后，，做出不同的行为，，决定idle监测的最终用途:"></a>idle监测，只是负责诊断，诊断后，，做出不同的行为，，决定idle监测的最终用途:</h3><ul><li><p>发送keepalive:一般用来配合keepalibe,减少keepalive消息。<br>keepalive设计演进:V1定时发送keepalive消息 -&gt;V2空闲监测 + 判定为Idle时才发送keepalibbe.<br>V1:keepalibe消息与服务器正常消息交换完全不失联，定时就发送;<br>V2:有其他数据传输的时候,不发送keepalive,无数据传输超过一定时间判定为idle再发keepalive。</p></li><li><p>直接关闭连接:<br>快速释放损坏的、恶意的、很久不用的连接，让系统时刻保持最好的状态。</p><p>简单粗暴，客户端可能需要重连。</p><p>实际应用中:结合起来使用.按需keepalive,保证不会空闲，如果空闲关闭连接。<br><img src="/img/netty/keepalive.png" alt="serve端开启TCPkeepalive"><br><img src="/img/netty/idle.png" alt="开启Idle监测"></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> netty </category>
          
      </categories>
      
      
        <tags>
            
            <tag> netty </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>netty学习-2.2-常用的&quot;二次&quot;编解码方式</title>
      <link href="/2021/04/05/netty%E5%AD%A6%E4%B9%A0-2-2/"/>
      <url>/2021/04/05/netty%E5%AD%A6%E4%B9%A0-2-2/</url>
      
        <content type="html"><![CDATA[<h2 id="学习后解决问题"><a href="#学习后解决问题" class="headerlink" title="学习后解决问题:"></a>学习后解决问题:</h2><ul><li>为什么需要”二次解码”?</li><li>常用的”二次”编解码方式</li><li>选择编解码方式的要点</li><li>Protobuf简介与使用</li><li>源码解读:Netty对二次编解码的支持</li></ul><h2 id="为什么需要”二次”编解码"><a href="#为什么需要”二次”编解码" class="headerlink" title="为什么需要”二次”编解码"></a>为什么需要”二次”编解码</h2><p><img src="/img/netty/二次解码器.png" alt="二次解码器"><br>解决TCP粘包、半包的一次解码器都是继承的ByteToMessageDecoder,而ByteToMessageDecoder主要是将原始数据流（可能存在粘包、半包问题的数据流）转换为用户数据（是一个字节数组）。所以我们需要二次解码器（都是直接继承MessageToMessageDecoder）将字节数组转换成Java对象。</p><ul><li>一次解码器: ByteToMessageDecoder<br>  io.netty.buffer.ByteBuf(原始数据流) -&gt; io.netty.buffer.Byteuf（用户数据）</li><li>二次解码器: MessageToMessageDecoder<I><br>  io.netty.buffer.ByteBuf(用户数据) -&gt; Java Object    </li></ul><p>　　有人会问能否将两次解码合二为一？这里是不建议的，首先没有分层感，不够清晰，其次就是耦合性太高，Java是最忌讳耦合性高的方案的。</p><h2 id="常用的“二次”编解码方式有哪些？"><a href="#常用的“二次”编解码方式有哪些？" class="headerlink" title="常用的“二次”编解码方式有哪些？"></a>常用的“二次”编解码方式有哪些？</h2><p>　　Java序列化（占空间，其他语言不支持），Marshaling，XML（也是占用比较大），JSON（比XML占空间小，但是没有XML那么通用性），MessagePack（比JSON占用空间还小，却没有JSON可读性好），Protobuf，其他…</p><p>如此多的编解码方式该如何选择呢？首先考虑到的是编码后占用空间，因为编解码的作用很大情况下是为了存储和传输。其次是编解码的速度，再一个就是是否追求可读性，最后一个就是多语言支持，例如MessagePack。综上所述比较合适的有JSON，MessagePack和Protobuf。但是最流行的是ProtoBuf。所以下面简单的介绍下Protobuf。</p><p>Google ProtoBuf简介<br>　　①Protobuf是一个灵活，高效的用于序列化数据的协议</p><p>　　②相比较XML 、JSON，Protobuf更小、更快、更便捷</p><p>　　③Protobuf是跨语言的，并且自带了一个编译器（protoc），只需要用它进行编译，可以自动生成Java，C++，Python等代码，不需要再写其他代码(缺点可读性不好)</p><h2 id="选择编解码方式的要点"><a href="#选择编解码方式的要点" class="headerlink" title="选择编解码方式的要点"></a>选择编解码方式的要点</h2><p>占用空间，可读性，是否跨语言</p><h2 id="源码解读-Netty对二次编解码的支持"><a href="#源码解读-Netty对二次编解码的支持" class="headerlink" title="源码解读:Netty对二次编解码的支持"></a>源码解读:Netty对二次编解码的支持</h2><p>打开Netty的源码，它对很多的编码器都提供支持，如图<br><img src="/img/netty/编解码.png" alt="Netty对二次编解码的支持"><br>随便点开一个看看，比如bytes包下的ByteArrayDecoder.java<br><img src="/img/netty/编解码1.png" alt="Netty对二次编解码的支持"><br>可以看出ByteArratDecoder.java只有一个decode()方法；其中它有个”ByteBuf msg”的参数,这个msg是io.netty.buffer.ByteBuf，那这个类的作用就见其名了，是将Netty的Bytebuf转换成jdk里的字节数组。</p><p>　　再来看一看Netty支持的序列化，找到serialization包下的ObjectEncoder.java，如图：<br><img src="/img/netty/编解码2.png" alt="Netty对二次编解码的支持"><br>图中的第48行的“CompactObjectOutputStream”，其中Compact是压缩的意思，意味着它的大小肯定比java的序列化要小，点进去验证一下<br><img src="/img/netty/编解码3.png" alt="Netty对二次编解码的支持"><br>首先看倒数的2行代码，倒数第一行只给一个类的“Name”,这点在反序列化（用发射）时就会用到，倒数第二行代码相比较JDK少了元信息，如下图是JDK的元信息：<br><img src="/img/netty/编解码4.png" alt="Netty对二次编解码的支持"><br>所以这么一对比才体会到“Compact”的意义所在！其他的也大同小异，比如“string”的解码器</p><p>下为:Netty对google protobuf解码器支持源码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Copyright 2015 The Netty Project</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The Netty Project licenses this file to you under the Apache License,</span></span><br><span class="line"><span class="comment"> * version 2.0 (the "License"); you may not use this file except in compliance</span></span><br><span class="line"><span class="comment"> * with the License. You may obtain a copy of the License at:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *   https://www.apache.org/licenses/LICENSE-2.0</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Unless required by applicable law or agreed to in writing, software</span></span><br><span class="line"><span class="comment"> * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT</span></span><br><span class="line"><span class="comment"> * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the</span></span><br><span class="line"><span class="comment"> * License for the specific language governing permissions and limitations</span></span><br><span class="line"><span class="comment"> * under the License.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">package</span> io.netty.handler.codec.protobuf;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.google.protobuf.CodedInputStream;</span><br><span class="line"><span class="keyword">import</span> com.google.protobuf.nano.CodedInputByteBufferNano;</span><br><span class="line"><span class="keyword">import</span> io.netty.buffer.ByteBuf;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelHandlerContext;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.ByteToMessageDecoder;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.CorruptedFrameException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * A decoder that splits the received &#123;<span class="doctag">@link</span> ByteBuf&#125;s dynamically by the</span></span><br><span class="line"><span class="comment"> * value of the Google Protocol Buffers</span></span><br><span class="line"><span class="comment"> * &lt;a href="https://developers.google.com/protocol-buffers/docs/encoding#varints"&gt;Base</span></span><br><span class="line"><span class="comment"> * 128 Varints&lt;/a&gt; integer length field in the message. For example:</span></span><br><span class="line"><span class="comment"> * &lt;pre&gt;</span></span><br><span class="line"><span class="comment"> * BEFORE DECODE (302 bytes)       AFTER DECODE (300 bytes)</span></span><br><span class="line"><span class="comment"> * +--------+---------------+      +---------------+</span></span><br><span class="line"><span class="comment"> * | Length | Protobuf Data |-----&gt;| Protobuf Data |</span></span><br><span class="line"><span class="comment"> * | 0xAC02 |  (300 bytes)  |      |  (300 bytes)  |</span></span><br><span class="line"><span class="comment"> * +--------+---------------+      +---------------+</span></span><br><span class="line"><span class="comment"> * &lt;/pre&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> CodedInputStream</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> CodedInputByteBufferNano</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProtobufVarint32FrameDecoder</span> <span class="keyword">extends</span> <span class="title">ByteToMessageDecoder</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//注意： 与Netty保存数据长度解码器不同,varInt 存长度的字段大小可边:值越小的数字使用越少的字节数</span></span><br><span class="line">    <span class="comment">// TODO maxFrameLength + safe skip + fail-fast option</span></span><br><span class="line">    <span class="comment">//      (just like LengthFieldBasedFrameDecoder)</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">decode</span><span class="params">(ChannelHandlerContext ctx, ByteBuf in, List&lt;Object&gt; out)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        in.markReaderIndex();</span><br><span class="line">        <span class="keyword">int</span> preIndex = in.readerIndex();</span><br><span class="line">        <span class="keyword">int</span> length = readRawVarint32(in);</span><br><span class="line">        <span class="keyword">if</span> (preIndex == in.readerIndex()) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (length &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> CorruptedFrameException(<span class="string">"negative length: "</span> + length);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (in.readableBytes() &lt; length) &#123;</span><br><span class="line">            in.resetReaderIndex();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            out.add(in.readRetainedSlice(length));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Reads variable length 32bit int from buffer</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> decoded int if buffers readerIndex has been forwarded else nonsense value</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">readRawVarint32</span><span class="params">(ByteBuf buffer)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!buffer.isReadable()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        buffer.markReaderIndex();</span><br><span class="line">        <span class="keyword">byte</span> tmp = buffer.readByte();</span><br><span class="line">        <span class="keyword">if</span> (tmp &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> tmp;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> result = tmp &amp; <span class="number">127</span>;</span><br><span class="line">            <span class="keyword">if</span> (!buffer.isReadable()) &#123;</span><br><span class="line">                buffer.resetReaderIndex();</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> ((tmp = buffer.readByte()) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                result |= tmp &lt;&lt; <span class="number">7</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                result |= (tmp &amp; <span class="number">127</span>) &lt;&lt; <span class="number">7</span>;</span><br><span class="line">                <span class="keyword">if</span> (!buffer.isReadable()) &#123;</span><br><span class="line">                    buffer.resetReaderIndex();</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> ((tmp = buffer.readByte()) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    result |= tmp &lt;&lt; <span class="number">14</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    result |= (tmp &amp; <span class="number">127</span>) &lt;&lt; <span class="number">14</span>;</span><br><span class="line">                    <span class="keyword">if</span> (!buffer.isReadable()) &#123;</span><br><span class="line">                        buffer.resetReaderIndex();</span><br><span class="line">                        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> ((tmp = buffer.readByte()) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        result |= tmp &lt;&lt; <span class="number">21</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        result |= (tmp &amp; <span class="number">127</span>) &lt;&lt; <span class="number">21</span>;</span><br><span class="line">                        <span class="keyword">if</span> (!buffer.isReadable()) &#123;</span><br><span class="line">                            buffer.resetReaderIndex();</span><br><span class="line">                            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        result |= (tmp = buffer.readByte()) &lt;&lt; <span class="number">28</span>;</span><br><span class="line">                        <span class="keyword">if</span> (tmp &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="keyword">throw</span> <span class="keyword">new</span> CorruptedFrameException(<span class="string">"malformed varint."</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> netty </category>
          
      </categories>
      
      
        <tags>
            
            <tag> netty </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>netty学习-2.1-TCP粘包、半包</title>
      <link href="/2021/04/05/netty%E5%AD%A6%E4%B9%A0-2-1/"/>
      <url>/2021/04/05/netty%E5%AD%A6%E4%B9%A0-2-1/</url>
      
        <content type="html"><![CDATA[<h2 id="学习后解决问题"><a href="#学习后解决问题" class="headerlink" title="学习后解决问题:"></a>学习后解决问题:</h2><ul><li>什么是粘包和半包?</li><li>为什么TCP应用中会出现粘包和半包现象?</li><li>解决粘包和半包问题的几种常用方法</li><li>Netty对三种常用封帧方式的支持</li><li>解读Netty处理粘包、半包的源码</li></ul><h2 id="什么是粘包和半包"><a href="#什么是粘包和半包" class="headerlink" title="什么是粘包和半包?"></a>什么是粘包和半包?</h2><p>发生远程消息 “ABC DEF”<br>有可能接收到的消息 1.”ABCDEF” 2.”A BC DEF” 3.”AB CD EF”<br>1为粘包 2和3为半包<br>粘包的主要原因:</p><ul><li>发送方每次写入数据 &lt; 套接字缓冲区大小</li><li>接收方读取套接字缓冲去数据不够及时</li></ul><p>半包的主要原因:</p><ul><li>发送方写入数据 &gt; 套接字缓冲区大小</li><li>发送的数据大于协议的MTU(Maximum Transmission Unit, 最大传输单元), 必须拆包<br><img src="/img/netty/io.png" alt="各个协议的MTU"></li></ul><p>换个角度看</p><ul><li><p>收发:<br>  一个发送可能被多次接收，多个发送可能被一次接收</p></li><li><p>传输:<br>  一个发送可能占用多个传输包,多个发送可能公用一个传输包</p></li></ul><p>根本原因:<br>    TCP是流式协议,消息无边界。<br>    补充ps:UDP像8邮寄的包裹,虽然一次运输多个,但每个包裹都有”界限”,一个一个签收所以无粘包、半包问题。</p><p>解决问题的根本手段：找出消息的边界<br><img src="/img/netty/粘包半包.png" alt="粘包半包的解决方式"></p><p>Netty对三种常用封帧方式的支持（三个类都继承ByteTomessageDecoder.java）<br><img src="/img/netty/粘包半包1.png" alt="粘包半包的解决方式"></p><h2 id="源码解读"><a href="#源码解读" class="headerlink" title="源码解读:"></a>源码解读:</h2><h3 id="解决问题"><a href="#解决问题" class="headerlink" title="解决问题"></a>解决问题</h3><ul><li>解码核心工作流程?</li><li>解码中两种数据累积器(Cumulator)的区别?</li><li>三种解码器的常用额外控制参数有哪些?</li></ul><h3 id="解读Netty处理粘包、半包的源码———-解码核心工作流程"><a href="#解读Netty处理粘包、半包的源码———-解码核心工作流程" class="headerlink" title="解读Netty处理粘包、半包的源码———-解码核心工作流程:"></a>解读Netty处理粘包、半包的源码———-解码核心工作流程:</h3><p>先找到ByteToMessageDecoder.java，可以看到它继承了ChannelInboundHandlerAdapter.java<br><img src="/img/netty/粘包半包2.png" alt="粘包半包的解决方式"><br>这个ChannelInboundHandlerAdapter有个核心的入口方法“channelRead()”;<br><img src="/img/netty/粘包半包3.png" alt="粘包半包的解决方式"><br>图中的msg就相当于我们的数据，开始就把数据转换成data,<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ByteBuf data = (ByteBuf) msg;</span><br></pre></td></tr></table></figure><br>然后判断cumulation是否为null,cumulation是数据积累器，用来积累数据。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ByteBuf cumulation;</span><br></pre></td></tr></table></figure><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">first = cumulation == <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">if</span> (first) &#123;</span><br><span class="line">    cumulation = data;</span><br><span class="line"> &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">     cumulation = cumulator.cumulate(ctx.alloc(), cumulation, data);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><br>第一次的时候肯定为null  所以first是true，直接把data数据给了cumulation。再接下来就是解码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">callDecode(ctx, cumulation, out);</span><br></pre></td></tr></table></figure><br>进入具体方法<br><img src="/img/netty/粘包半包4.png" alt="粘包半包的解决方式"></p><p>参数中的in就是数据积累器中的数据，也就是我们传入的数据。往下走又这么个方法调用：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">decodeRemovalReentryProtection(ctx, in, out);</span><br></pre></td></tr></table></figure></p><p>需要注意的是：decode中时，不能执行完handler remove清理操作，decode完之后需要清理数据，改方法的名称长久是标识功能的。点进去可以查看<br><img src="/img/netty/粘包半包5.png" alt="粘包半包的解决方式"></p><p>可以看出有个decodeState = STATE_CALLING_CHILD_DECODE;这个就是处理刚才remove handler 的；接下来就是“decode(ctx, in, out);”；这个decode是个抽象方法采用模板模式<br><img src="/img/netty/粘包半包6.png" alt="粘包半包的解决方式"></p><p>之前说过Netty对三种封帧的支持分别是：“FixedLengthFrameDecoder”，“DelimiterBasedFrameDecoder”，“LengthFieldBasedFrameDecoder”。这里以“FixedLengthFrameDecoder”为例，所以点开FixedLengthFrameDecoder的decode();<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> 　　<span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">decode</span><span class="params">(ChannelHandlerContext ctx, ByteBuf in, List&lt;Object&gt; out)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    Object decoded = decode(ctx, in);</span><br><span class="line">    <span class="keyword">if</span> (decoded != <span class="keyword">null</span>) &#123;</span><br><span class="line">        out.add(decoded);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>然后再进去查看Object decoded = decode(ctx, in);<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">decode</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">            @SuppressWarnings(<span class="string">"UnusedParameters"</span>)</span> ChannelHandlerContext ctx, ByteBuf in) <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//这个in还是数据积累器的数据，取得之后进行判断，如果小于则返回null不能解出,否则解出。这样一来就完成了一个数据解析的过程。</span></span><br><span class="line">        <span class="keyword">if</span> (in.readableBytes() &lt; frameLength) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> in.readRetainedSlice(frameLength);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><br>这个in还是数据积累器的数据，取得之后进行判断，如果小于则返回null不能解出,否则解出。这样一来就完成了一个数据解析的过程。</p><p>数据积累器源码解析:<br>1.找到channelRead方法:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ByteToMessageDecoder</span> <span class="keyword">extends</span> <span class="title">ChannelInboundHandlerAdapter</span> </span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (msg <span class="keyword">instanceof</span> ByteBuf) &#123;</span><br><span class="line">           CodecOutputList out = CodecOutputList.newInstance();</span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">               first = cumulation == <span class="keyword">null</span>;</span><br><span class="line">               cumulation = cumulator.cumulate(ctx.alloc(),</span><br><span class="line">                       first ? Unpooled.EMPTY_BUFFER : cumulation, (ByteBuf) msg);</span><br><span class="line">               callDecode(ctx, cumulation, out);</span><br><span class="line">               &#125;</span><br><span class="line">               ......</span><br></pre></td></tr></table></figure><br>方法接口:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Cumulator</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Cumulate the given &#123;<span class="doctag">@link</span> ByteBuf&#125;s and return the &#123;<span class="doctag">@link</span> ByteBuf&#125; that holds the cumulated bytes.</span></span><br><span class="line"><span class="comment">     * The implementation is responsible to correctly handle the life-cycle of the given &#123;<span class="doctag">@link</span> ByteBuf&#125;s and so</span></span><br><span class="line"><span class="comment">     * call &#123;<span class="doctag">@link</span> ByteBuf#release()&#125; if a &#123;<span class="doctag">@link</span> ByteBuf&#125; is fully consumed.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">ByteBuf <span class="title">cumulate</span><span class="params">(ByteBufAllocator alloc, ByteBuf cumulation, ByteBuf in)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>2种实现:<br>1.内存复制:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Cumulate &#123;<span class="doctag">@link</span> ByteBuf&#125;s by merge them into one &#123;<span class="doctag">@link</span> ByteBuf&#125;'s, using memory copies.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Cumulator MERGE_CUMULATOR = <span class="keyword">new</span> Cumulator() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ByteBuf <span class="title">cumulate</span><span class="params">(ByteBufAllocator alloc, ByteBuf cumulation, ByteBuf in)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!cumulation.isReadable() &amp;&amp; in.isContiguous()) &#123;</span><br><span class="line">            <span class="comment">// If cumulation is empty and input buffer is contiguous, use it directly</span></span><br><span class="line">            cumulation.release();</span><br><span class="line">            <span class="keyword">return</span> in;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> required = in.readableBytes();</span><br><span class="line">            <span class="keyword">if</span> (required &gt; cumulation.maxWritableBytes() ||</span><br><span class="line">                    (required &gt; cumulation.maxFastWritableBytes() &amp;&amp; cumulation.refCnt() &gt; <span class="number">1</span>) ||</span><br><span class="line">                    cumulation.isReadOnly()) &#123;</span><br><span class="line">                <span class="comment">// Expand cumulation (by replacing it) under the following conditions:</span></span><br><span class="line">                <span class="comment">// - cumulation cannot be resized to accommodate the additional data</span></span><br><span class="line">                <span class="comment">// - cumulation can be expanded with a reallocation operation to accommodate but the buffer is</span></span><br><span class="line">                <span class="comment">//   assumed to be shared (e.g. refCnt() &gt; 1) and the reallocation may not be safe.</span></span><br><span class="line">                <span class="keyword">return</span> expandCumulation(alloc, cumulation, in);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//数据追加内存复制</span></span><br><span class="line">            cumulation.writeBytes(in, in.readerIndex(), required);</span><br><span class="line">            in.readerIndex(in.writerIndex());</span><br><span class="line">            <span class="keyword">return</span> cumulation;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// We must release in in all cases as otherwise it may produce a leak if writeBytes(...) throw</span></span><br><span class="line">            <span class="comment">// for whatever release (for example because of OutOfMemoryError)</span></span><br><span class="line">            in.release();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>2.COMPOSITE_CUMULATOR ：不是复制而是组合，先扩容，如果数据够了的话就直接把数据给组合起来，避免了内存复制<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Cumulator COMPOSITE_CUMULATOR = <span class="keyword">new</span> Cumulator() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ByteBuf <span class="title">cumulate</span><span class="params">(ByteBufAllocator alloc, ByteBuf cumulation, ByteBuf in)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!cumulation.isReadable()) &#123;</span><br><span class="line">            cumulation.release();</span><br><span class="line">            <span class="keyword">return</span> in;</span><br><span class="line">        &#125;</span><br><span class="line">        CompositeByteBuf composite = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (cumulation <span class="keyword">instanceof</span> CompositeByteBuf &amp;&amp; cumulation.refCnt() == <span class="number">1</span>) &#123;</span><br><span class="line">                composite = (CompositeByteBuf) cumulation;</span><br><span class="line">                <span class="comment">// Writer index must equal capacity if we are going to "write"</span></span><br><span class="line">                <span class="comment">// new components to the end</span></span><br><span class="line">                <span class="keyword">if</span> (composite.writerIndex() != composite.capacity()) &#123;</span><br><span class="line">                    composite.capacity(composite.writerIndex());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                composite = alloc.compositeBuffer(Integer.MAX_VALUE).addFlattenedComponents(<span class="keyword">true</span>, cumulation);</span><br><span class="line">            &#125;</span><br><span class="line">            composite.addFlattenedComponents(<span class="keyword">true</span>, in);</span><br><span class="line">            in = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">return</span> composite;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (in != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// We must release if the ownership was not transferred as otherwise it may produce a leak</span></span><br><span class="line">                in.release();</span><br><span class="line">                <span class="comment">// Also release any new buffer allocated if we're not returning it</span></span><br><span class="line">                <span class="keyword">if</span> (composite != <span class="keyword">null</span> &amp;&amp; composite != cumulation) &#123;</span><br><span class="line">                    composite.release();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h3 id="三种解码器的常用控制参数有哪些"><a href="#三种解码器的常用控制参数有哪些" class="headerlink" title="三种解码器的常用控制参数有哪些?"></a>三种解码器的常用控制参数有哪些?</h3><p>三种解码器链接<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">* Generally frame detection should be handled earlier in the pipeline by adding a</span><br><span class="line">* &#123;<span class="meta">@link</span> DelimiterBasedFrameDecoder&#125;, &#123;<span class="meta">@link</span> FixedLengthFrameDecoder&#125;, &#123;<span class="meta">@link</span> LengthFieldBasedFrameDecoder&#125;,</span><br><span class="line">* or &#123;<span class="meta">@link</span> LineBasedFrameDecoder&#125;.</span><br></pre></td></tr></table></figure></p><ol><li>分隔符解码器DelimiterBasedFrameDecoder：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DelimiterBasedFrameDecoder</span> <span class="keyword">extends</span> <span class="title">ByteToMessageDecoder</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//数组可存多个分隔符</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ByteBuf[] delimiters;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> maxFrameLength;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> stripDelimiter;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> failFast;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> discardingTooLongFrame;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> tooLongFrameLength;</span><br><span class="line">    <span class="comment">/** Set only when decoding with "\n" and "\r\n" as the delimiter.  */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> LineBasedFrameDecoder lineBasedDecoder;</span><br><span class="line">    ......</span><br></pre></td></tr></table></figure></li><li><p>固定长度控制符解码器FixedLengthFrameDecoder</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FixedLengthFrameDecoder</span> <span class="keyword">extends</span> <span class="title">ByteToMessageDecoder</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> frameLength;</span><br></pre></td></tr></table></figure></li><li><p>存内容长度解码器LengthFieldBasedFrameDecoder<br>源码文档</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">* &lt;pre&gt;</span><br><span class="line">* &lt;b&gt;lengthFieldOffset&lt;/b&gt;   = &lt;b&gt;0&lt;/b&gt; 位移参数</span><br><span class="line">* &lt;b&gt;lengthFieldLength&lt;/b&gt;   = &lt;b&gt;2&lt;/b&gt; length所占长度(存长度的地址)</span><br><span class="line">* lengthAdjustment    = <span class="number">0</span> 调整长度计算多加的字段和实际字段长度</span><br><span class="line">* initialBytesToStrip = <span class="number">0</span> (= <span class="keyword">do</span> not strip header)   <span class="number">0</span>为原样copy,如下表，为lengthFieldLength长度则不copy长度信息只copy<span class="string">"HELLO, WORLD"</span></span><br><span class="line">*</span><br><span class="line">* <span class="function">BEFORE <span class="title">DECODE</span> <span class="params">(<span class="number">14</span> bytes)</span>         AFTER <span class="title">DECODE</span> <span class="params">(<span class="number">14</span> bytes)</span></span></span><br><span class="line"><span class="function">* +--------+----------------+      +--------+----------------+</span></span><br><span class="line"><span class="function">* | Length | Actual Content |-----&gt;| Length | Actual Content |</span></span><br><span class="line"><span class="function">* | 0x000C | "HELLO, WORLD" |      | 0x000C | "HELLO, WORLD" |</span></span><br><span class="line"><span class="function">* +--------+----------------+      +--------+----------------+</span></span><br><span class="line"><span class="function">* &lt;/pre&gt;</span></span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> netty </category>
          
          <category> TCP </category>
          
          <category> 粘包和半包 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> netty </tag>
            
            <tag> TCP </tag>
            
            <tag> 粘包和半包 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一致性哈希与哈希槽</title>
      <link href="/2021/04/01/%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C%E4%B8%8E%E5%93%88%E5%B8%8C%E6%A7%BD/"/>
      <url>/2021/04/01/%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C%E4%B8%8E%E5%93%88%E5%B8%8C%E6%A7%BD/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>随着缓存技术出现，分布式存储的缓存集群无疑极大的提升了数据访问速度。但缓存该按照什么规定去存储到指定的节点(集群中的某个缓存服务器),新增或删除某几台缓存服务器后对以前的缓存的查找怎么办，如何处理。以下以redis非关系型内存数据库为例。</p><h3 id="缓存集群分配节点问题"><a href="#缓存集群分配节点问题" class="headerlink" title="缓存集群分配节点问题"></a>缓存集群分配节点问题</h3><p>一台或多台应用服务器的数据放入多台redis缓存服务器中时如何选择存到哪台缓存服务器，如何让数据尽可能均衡的存储数据做到负载均衡？</p><h3 id="新增删除缓存服务器影响缓存查找问题"><a href="#新增删除缓存服务器影响缓存查找问题" class="headerlink" title="新增删除缓存服务器影响缓存查找问题"></a>新增删除缓存服务器影响缓存查找问题</h3><p>如果现有的缓存服务器容量不够，新增缓存服务器如何较低风险的处理应用服务器对以前缓存数据的查找，避免新增缓存服务器时查找以前缓存服务器地址出错。</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><h3 id="余数算法"><a href="#余数算法" class="headerlink" title="余数算法"></a>余数算法</h3><p>提到分配自然而然地想到可以通过对要存储的key(redis K-V)值 hash后对服务器数量求余数，然后根据余数分配到指定缓存服务器。如下图：<br><img src="/img/Redis/hash.png" alt="余数算法"><br>问题：如何保证缓存的负载均衡？新增后余数算法得到的缓存服务器地址结果和以前不一致导致的大量缓存失效问题进而带来的缓存雪崩问题。如下图：<br><img src="/img/Redis/hash2.png" alt="余数算法问题"></p><h3 id="一致性哈希"><a href="#一致性哈希" class="headerlink" title="一致性哈希"></a>一致性哈希</h3><p>采用一致性哈希可以避免大量的缓存失效，将hash空间想象成一个圆，用各服务器的IP或者hostname进行hash算法求hashcode(在2^32之内，java hashcode为int类型32位，4个字节)，对于要缓存的数据或要查找的数据再根据对key的hash值顺时针找到的第一台服务器位缓存服务器。如下图:<br><img src="/img/Redis/一致性hash.png" alt="一致性hash"><br>新增服务器时，可以发现影响的缓存只有新增的服务器到新增服务器逆时针最近一台服务器之间的缓存受到影响，，不会导致大面积缓存失效。<br><img src="/img/Redis/一致性hash2.png" alt="一致性hash"><br>一致性hash实习负载均衡，通过将一台缓存服务器看作多台缓存服务器进行hash后映射到hash空间圆圈上<br><img src="/img/Redis/一致性hash3.png" alt="一致性hash"></p><h3 id="哈希槽"><a href="#哈希槽" class="headerlink" title="哈希槽"></a>哈希槽</h3><p> Redis Cluster(集群)在设计中没有使用一致性哈希（Consistency Hashing），而是使用数据分片引入哈希槽（hash slot）来实现一个 Redis Cluster包含16384（0~16383）个哈希槽，存储在Redis Cluster中的所有键都会被映射到这些slot中，集群中的每个键都属于这16384个哈希槽中的一个，集群使用公式slot=CRC16（key）/16384来计算key属于哪个槽，其中CRC16(key)算法语句用于计算key的CRC16 校验和。<br> 按照槽来进行分片，通过为每个节点指派不同数量的槽，可以控制不同节点负责的数据量和请求数<br><img src="/img/Redis/hashsolt.png" alt="hashsolt"><br> 新增服务器hash槽重新分配<br><img src="/img/Redis/hashsolt2.png" alt="hashsolt"></p><h4 id="哈希槽补充："><a href="#哈希槽补充：" class="headerlink" title="哈希槽补充："></a>哈希槽补充：</h4><p>哈希槽为什么是16384（2^14）个？<br>在redis节点发送心跳包时需要把所有的槽放到这个心跳包里，以便让节点知道当前集群信息，16384=16k，在发送心跳包时使用char进行bitmap压缩后是2k（2 <em> 8 (8 bit) </em> 1024(1k) = 16K），也就是说使用2k的空间创建了16k的槽数。</p><p>虽然使用CRC16算法最多可以分配65535（2^16-1）个槽位，65535=65k，压缩后就是8k（8 <em> 8 (8 bit) </em> 1024(1k) =65K），也就是说需要需要8k的心跳包，作者认为这样做不太值得；并且一般情况下一个redis集群不会有超过1000个master节点，所以16k的槽位是个比较合适的选择。</p>]]></content>
      
      
      <categories>
          
          <category> redis </category>
          
          <category> cache </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
            <tag> cache </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>netty学习-2.0-nettyI/O模式</title>
      <link href="/2021/04/01/netty%E5%AD%A6%E4%B9%A0-2-0/"/>
      <url>/2021/04/01/netty%E5%AD%A6%E4%B9%A0-2-0/</url>
      
        <content type="html"><![CDATA[<p>该文为极客时间netty源码解析记录笔记</p><h2 id="Netty怎么切换三种I-O模式"><a href="#Netty怎么切换三种I-O模式" class="headerlink" title="Netty怎么切换三种I/O模式"></a>Netty怎么切换三种I/O模式</h2><h3 id="学习目标问题"><a href="#学习目标问题" class="headerlink" title="学习目标问题"></a>学习目标问题</h3><ul><li><p>什么是经典的三种I/O模式</p></li><li><p>Netty对三种I/O模式的支持</p></li><li><p>为什么Netty仅仅支持NIO了？</p></li><li><p>为什么Netty有多种NIO实现？</p></li><li><p>NIO一定优于BIO么？</p></li><li><p>源码解读Netty怎么切换I/O模式?</p></li></ul><h3 id="三种I-O模式"><a href="#三种I-O模式" class="headerlink" title="三种I/O模式:"></a>三种I/O模式:</h3><p>当我们去饭店吃饭时:</p><ul><li><p>食堂排队打饭模式: 排队在窗口,打好才走;</p></li><li><p>点单、等待被叫模式: 等待被叫，好了自己去端;</p></li><li><p>包厢模式: 点单后菜直接被端上桌。</p></li></ul><p>类比:</p><ul><li><p>饭店-&gt; 服务器</p></li><li><p>饭菜-&gt; 数据                               排队打饭模式|BIO(阻塞I/O)|JDK1.4之前</p><pre><code>                                  点单、等待被叫模式|NIO(非阻塞I/O)|JDK1.4(2002年，java.nio包)</code></pre></li><li><p>饭菜好了 -&gt; 数据就绪                       包厢模式|AIO(异步阻塞)|JDK1.7(2011年)</p></li><li><p>端菜/送菜 -&gt; 数据读取</p></li></ul><p>阻塞与非阻塞</p><ul><li><p>菜没好, 要不要死等 -&gt;数据就绪前要不要等待</p></li><li><p>阻塞: 没有数据传过来时, 读会阻塞直到有数据; 缓冲区满时，写操作也会阻塞。非阻塞遇到这些情况,都是直接返回</p></li></ul><p>同步与异步</p><ul><li><p>菜好了, 谁端 -&gt;数据就绪后,数据操作谁完成?</p></li><li><p>数据就绪后需要自己去读是同步, 数据就绪直接读好再回调给程序是异步。</p></li></ul><h3 id="Netty对三种I-O模式的支持"><a href="#Netty对三种I-O模式的支持" class="headerlink" title="Netty对三种I/O模式的支持:"></a>Netty对三种I/O模式的支持:</h3><p><img src="/img/netty/io.png" alt="Netty对三种I/O模式的支持"></p><h3 id="为什么Netty仅仅支持NIO了？"><a href="#为什么Netty仅仅支持NIO了？" class="headerlink" title="为什么Netty仅仅支持NIO了？"></a>为什么Netty仅仅支持NIO了？</h3><ul><li>为什么不建议(deprecate)阻塞I/O(BIO/OIO)?<br>连接数高的情况下：阻塞-&gt;耗资源、效率低</li><li>为什么删掉已经做好的AIO支持?<ul><li>Windows实现成熟，但是很少用来做服务器。</li><li>Linux常用来做服务器,但是AIO实现不够成熟。</li><li>Linux下AIO相比较NIO的提升不明显。</li></ul></li></ul><h3 id="为什么Netty有多种NIO实现？"><a href="#为什么Netty有多种NIO实现？" class="headerlink" title="为什么Netty有多种NIO实现？"></a>为什么Netty有多种NIO实现？</h3><p>通用的NIO实现(Common)在Linux下也是使用epoll, 为什么自己单独实现?</p><p>实现得更好！</p><ul><li>Netty暴露了更多的可控参数, 例如:<ul><li>JDK的NIO默认实现是水平触发</li><li>Netty是边缘触发(默认)和水平触发可切换</li></ul></li><li>Netty实现的垃圾回收更少、性能更好    </li></ul><h3 id="NIO一定优于BIO么？"><a href="#NIO一定优于BIO么？" class="headerlink" title="NIO一定优于BIO么？"></a>NIO一定优于BIO么？</h3><ul><li>BIO代码简单</li><li>特定场景: 连接数少,并发度低, BIO性能不输NIO。<br>连接数少，不存在代码扩展的情况下可选用BIO。</li></ul><h3 id="Netty怎么切换I-O模式的"><a href="#Netty怎么切换I-O模式的" class="headerlink" title="Netty怎么切换I/O模式的?"></a>Netty怎么切换I/O模式的?</h3><ul><li>怎么切换?</li><li>原理是什么?</li><li>为什么服务器开发并不需要切换客户端对应Socket？<br><img src="/img/netty/io切换1.png" alt="Netty切换I/O模式"><br><img src="/img/netty/io切换2.png" alt="Netty切换I/O模式"></li></ul><h2 id="Netty如何支持三种Reactor"><a href="#Netty如何支持三种Reactor" class="headerlink" title="Netty如何支持三种Reactor"></a>Netty如何支持三种Reactor</h2><ul><li>什么是Reactor及三种版本</li><li>如何在Netty中使用Reactor模式</li><li>解析Netty对Reactor模式支持的常见疑问</li></ul><h3 id="什么是Reactor及三种版本"><a href="#什么是Reactor及三种版本" class="headerlink" title="什么是Reactor及三种版本"></a>什么是Reactor及三种版本</h3><p>生活场景: 饭店规模变化</p><ul><li>一个人包揽所有: 迎宾、电池、做饭、上菜、送客等;</li><li>多招几个伙计: 大家一起做上面的事情;</li><li>进一步分工: 搞一个或多个人专门做迎宾。</li></ul><p>场景类比</p><ul><li>饭店伙计: 线程</li><li>迎宾工作: 接入连接</li><li>点菜： 请求</li><li>做菜: 业务处理</li><li>上菜: 响应</li><li>送客: 断连</li></ul><p>三种版本:<br>BIO|NIO|AIO<br>Thread-Per-Connection|Reactor|Proactor</p><p>三种模式:</p><ol><li>一个人包揽所有: 迎宾、点菜、做饭、上菜、送客等-&gt;Reactor单线程</li><li>多招几个伙计: 大家一起做上面的事情 -&gt; Reactor多线程模式</li><li>进一步分工: 搞一个或者多个人专门做迎宾 -&gt; 主从Reactor多线程模式</li></ol><p>Reactor是一种开发模式，模式的核心流程:<br>注册感兴趣的事件-&gt;扫描是否有感兴趣的事件发生-&gt;事件发生后做出相应的处理</p><p>BIO版本的开发模式:<br><img src="/img/netty/reactor-BIO.png" alt="BIO"></p><p>Reactor单线程模式:<br><img src="/img/netty/ReactorV1.png" alt="reactorV1"><br><img src="/img/netty/ReactorV2.png" alt="reactorV2"><br><img src="/img/netty/ReactorV2.png" alt="reactorV3"></p><h3 id="Netty中使用Reactor模式"><a href="#Netty中使用Reactor模式" class="headerlink" title="Netty中使用Reactor模式"></a>Netty中使用Reactor模式</h3><p><img src="/img/netty/Reactor.png" alt="reactor使用3种模式"></p><h2 id="解析Netty对Reactor模式支持的常见疑问"><a href="#解析Netty对Reactor模式支持的常见疑问" class="headerlink" title="解析Netty对Reactor模式支持的常见疑问"></a>解析Netty对Reactor模式支持的常见疑问</h2><ul><li>Netty如何支持主从Reactor模式的?</li><li>为什么说Netty的main reactor大多并不能用到一个线程组,只能是线程组里面的一个?</li><li>Netty给Channel分配NIO event loop的规则是什么</li><li>为什么通用模式的NIO实现多路复用器是专门跨平台的</li></ul><h3 id="Netty如何支持主从Reactor模式的"><a href="#Netty如何支持主从Reactor模式的" class="headerlink" title="Netty如何支持主从Reactor模式的?"></a>Netty如何支持主从Reactor模式的?</h3><p>设置<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">EchoServer</span> </span>&#123;</span><br><span class="line">......</span><br><span class="line">    <span class="comment">// Configure the server. EchoServer56行</span></span><br><span class="line">        EventLoopGroup bossGroup = <span class="keyword">new</span> NioEventLoopGroup(<span class="number">1</span>);</span><br><span class="line">        EventLoopGroup workerGroup = <span class="keyword">new</span> NioEventLoopGroup(); <span class="comment">//在此设置主从</span></span><br><span class="line">        <span class="keyword">final</span> EchoServerHandler serverHandler = <span class="keyword">new</span> EchoServerHandler();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ServerBootstrap b = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line">            b.group(bossGroup, workerGroup)  <span class="comment">//在此设置主从组进入源码</span></span><br><span class="line">             .channel(NioServerSocketChannel<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">        ......</span></span><br><span class="line"><span class="class">&#125;</span></span><br></pre></td></tr></table></figure><br>主:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServerBootstrap</span> <span class="keyword">extends</span> <span class="title">AbstractBootstrap</span>&lt;<span class="title">ServerBootstrap</span>, <span class="title">ServerChannel</span>&gt; </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;ChannelOption&lt;?&gt;, Object&gt; childOptions = <span class="keyword">new</span> LinkedHashMap&lt;ChannelOption&lt;?&gt;, Object&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;AttributeKey&lt;?&gt;, Object&gt; childAttrs = <span class="keyword">new</span> ConcurrentHashMap&lt;AttributeKey&lt;?&gt;, Object&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ServerBootstrapConfig config = <span class="keyword">new</span> ServerBootstrapConfig(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> EventLoopGroup childGroup; <span class="comment">//workGroup</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> ChannelHandler childHandler;</span><br><span class="line">.......</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ServerBootstrap <span class="title">group</span><span class="params">(EventLoopGroup parentGroup, EventLoopGroup childGroup)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.group(parentGroup);  <span class="comment">//进入源码</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.childGroup != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"childGroup set already"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.childGroup = ObjectUtil.checkNotNull(childGroup, <span class="string">"childGroup"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br></pre></td></tr></table></figure></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractBootstrap</span>&lt;<span class="title">B</span> <span class="keyword">extends</span> <span class="title">AbstractBootstrap</span>&lt;<span class="title">B</span>, <span class="title">C</span>&gt;, <span class="title">C</span> <span class="keyword">extends</span> <span class="title">Channel</span>&gt; <span class="keyword">implements</span> <span class="title">Cloneable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map.Entry&lt;ChannelOption&lt;?&gt;, Object&gt;[] EMPTY_OPTION_ARRAY = <span class="keyword">new</span> Map.Entry[<span class="number">0</span>];</span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map.Entry&lt;AttributeKey&lt;?&gt;, Object&gt;[] EMPTY_ATTRIBUTE_ARRAY = <span class="keyword">new</span> Map.Entry[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">volatile</span> EventLoopGroup group;</span><br><span class="line">......</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The &#123;<span class="doctag">@link</span> EventLoopGroup&#125; which is used to handle all the events for the to-be-created</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@link</span> Channel&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> B <span class="title">group</span><span class="params">(EventLoopGroup group)</span> </span>&#123;</span><br><span class="line">        ObjectUtil.checkNotNull(group, <span class="string">"group"</span>);</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.group != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"group set already"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.group = group;</span><br><span class="line">        <span class="keyword">return</span> self();</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">//开始register</span></span><br><span class="line">        ChannelFuture regFuture = config().group().register(channel); <span class="comment">//将socketChannel绑定到bossGroup</span></span><br><span class="line">        <span class="keyword">if</span> (regFuture.cause() != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (channel.isRegistered()) &#123;</span><br><span class="line">                channel.close();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                channel.unsafe().closeForcibly();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>从:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Channel child = (Channel) msg;</span><br><span class="line"></span><br><span class="line">    child.pipeline().addLast(childHandler);</span><br><span class="line"></span><br><span class="line">    setChannelOptions(child, childOptions, logger);</span><br><span class="line">    setAttributes(child, childAttrs);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//绑定socketChannel到子组workGroup</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        childGroup.register(child).addListener(<span class="keyword">new</span> ChannelFutureListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operationComplete</span><span class="params">(ChannelFuture future)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (!future.isSuccess()) &#123;</span><br><span class="line">                    forceClose(child, future.cause());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        forceClose(child, t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="为什么说Netty的main-reactor大多并不能用到一个线程组-只能是线程组里面的一个"><a href="#为什么说Netty的main-reactor大多并不能用到一个线程组-只能是线程组里面的一个" class="headerlink" title="为什么说Netty的main reactor大多并不能用到一个线程组,只能是线程组里面的一个"></a>为什么说Netty的main reactor大多并不能用到一个线程组,只能是线程组里面的一个</h3><p>查看group方法的调用栈:<br><img src="/img/netty/groupstack.png" alt="reactorV3"><br>绑定服务器地址和端口，一般只会绑定一个服务器地址和一个端口所以Netty的main reactor只能是线程组里面的一个。</p><h3 id="Netty给Channel分配NIO-event-loop的规则是什么"><a href="#Netty给Channel分配NIO-event-loop的规则是什么" class="headerlink" title="Netty给Channel分配NIO event loop的规则是什么"></a>Netty给Channel分配NIO event loop的规则是什么</h3><p>源码分析:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">ServerBootstrap.java: </span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//进入register方法</span></span><br><span class="line">                childGroup.register(child).addListener(<span class="keyword">new</span> ChannelFutureListener() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operationComplete</span><span class="params">(ChannelFuture future)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                        <span class="keyword">if</span> (!future.isSuccess()) &#123;</span><br><span class="line">                            forceClose(child, future.cause());</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br></pre></td></tr></table></figure><br><img src="/img/netty/nio.png" alt="nio实现"><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ChannelFuture <span class="title">register</span><span class="params">(Channel channel)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//next选择</span></span><br><span class="line">    <span class="keyword">return</span> next().register(channel);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> EventLoop <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (EventLoop) <span class="keyword">super</span>.next();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> EventExecutor <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> chooser.next();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><img src="/img/netty/choose.png" alt="选择工厂实现"><br>2种实现对应的源码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> io.netty.util.concurrent;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.util.internal.UnstableApi;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicLong;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Default implementation which uses simple round-robin to choose next &#123;<span class="doctag">@link</span> EventExecutor&#125;.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@UnstableApi</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultEventExecutorChooserFactory</span> <span class="keyword">implements</span> <span class="title">EventExecutorChooserFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> DefaultEventExecutorChooserFactory INSTANCE = <span class="keyword">new</span> DefaultEventExecutorChooserFactory();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">DefaultEventExecutorChooserFactory</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> EventExecutorChooser <span class="title">newChooser</span><span class="params">(EventExecutor[] executors)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//根据待绑定的executor是否是2的幂次方,做出不同的选择</span></span><br><span class="line">        <span class="keyword">if</span> (isPowerOfTwo(executors.length)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> PowerOfTwoEventExecutorChooser(executors);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> GenericEventExecutorChooser(executors);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isPowerOfTwo</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (val &amp; -val) == val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">PowerOfTwoEventExecutorChooser</span> <span class="keyword">implements</span> <span class="title">EventExecutorChooser</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger idx = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> EventExecutor[] executors;</span><br><span class="line"></span><br><span class="line">        PowerOfTwoEventExecutorChooser(EventExecutor[] executors) &#123;</span><br><span class="line">            <span class="keyword">this</span>.executors = executors;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="comment">//executor总数必须是2的幂次方(2,4,8...等)才会用&amp;运算效率更高</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> EventExecutor <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> executors[idx.getAndIncrement() &amp; executors.length - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericEventExecutorChooser</span> <span class="keyword">implements</span> <span class="title">EventExecutorChooser</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Use a 'long' counter to avoid non-round-robin behaviour at the 32-bit overflow boundary.</span></span><br><span class="line">        <span class="comment">// The 64-bit long solves this by placing the overflow so far into the future, that no system</span></span><br><span class="line">        <span class="comment">// will encounter this in practice.</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> AtomicLong idx = <span class="keyword">new</span> AtomicLong();</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> EventExecutor[] executors;</span><br><span class="line"></span><br><span class="line">        GenericEventExecutorChooser(EventExecutor[] executors) &#123;</span><br><span class="line">            <span class="keyword">this</span>.executors = executors;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> EventExecutor <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">//递增、取模、取正值，不然可能是负数</span></span><br><span class="line">            <span class="keyword">return</span> executors[(<span class="keyword">int</span>) Math.abs(idx.getAndIncrement() % executors.length)];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="为什么通用模式的NIO实现多路复用器是专门跨平台的"><a href="#为什么通用模式的NIO实现多路复用器是专门跨平台的" class="headerlink" title="为什么通用模式的NIO实现多路复用器是专门跨平台的"></a>为什么通用模式的NIO实现多路复用器是专门跨平台的</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NioEventLoopGroup</span> <span class="keyword">extends</span> <span class="title">MultithreadEventLoopGroup</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NioEventLoopGroup</span><span class="params">(<span class="keyword">int</span> nThreads, Executor executor)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//进入provider方法</span></span><br><span class="line">        <span class="keyword">this</span>(nThreads, executor, SelectorProvider.provider());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SelectorProvider <span class="title">provider</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">        <span class="keyword">if</span> (provider != <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> provider;</span><br><span class="line">        <span class="keyword">return</span> AccessController.doPrivileged(</span><br><span class="line">            <span class="keyword">new</span> PrivilegedAction&lt;&gt;() &#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> SelectorProvider <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                        <span class="comment">// 1.查看是否有参数，默认false</span></span><br><span class="line">                        <span class="keyword">if</span> (loadProviderFromProperty())</span><br><span class="line">                            <span class="keyword">return</span> provider;</span><br><span class="line">                        <span class="comment">// 2.查看是否有实现, 默认false    </span></span><br><span class="line">                        <span class="keyword">if</span> (loadProviderAsService())</span><br><span class="line">                            <span class="keyword">return</span> provider;</span><br><span class="line">                        <span class="comment">// 3.跨平台实现的根本进入create方法    </span></span><br><span class="line">                        provider = sun.nio.ch.DefaultSelectorProvider.create();</span><br><span class="line">                        <span class="keyword">return</span> provider;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>1.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//通过反射看是否有参数java.nio.channels.spi.SelectorProvider无返回true</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">loadProviderFromProperty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    String cn = System.getProperty(<span class="string">"java.nio.channels.spi.SelectorProvider"</span>);</span><br><span class="line">    <span class="keyword">if</span> (cn == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="meta">@SuppressWarnings</span>(<span class="string">"deprecation"</span>)</span><br><span class="line">        Object tmp = Class.forName(cn, <span class="keyword">true</span>,</span><br><span class="line">                                   ClassLoader.getSystemClassLoader()).newInstance();</span><br><span class="line">        provider = (SelectorProvider)tmp;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ClassNotFoundException x) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ServiceConfigurationError(<span class="keyword">null</span>, x);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IllegalAccessException x) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ServiceConfigurationError(<span class="keyword">null</span>, x);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InstantiationException x) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ServiceConfigurationError(<span class="keyword">null</span>, x);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (SecurityException x) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ServiceConfigurationError(<span class="keyword">null</span>, x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>2.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//通过serviceLoader找到实现，没找到返回false</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">loadProviderAsService</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    ServiceLoader&lt;SelectorProvider&gt; sl =</span><br><span class="line">        ServiceLoader.load(SelectorProvider<span class="class">.<span class="keyword">class</span>,</span></span><br><span class="line"><span class="class">                           <span class="title">ClassLoader</span>.<span class="title">getSystemClassLoader</span>())</span>;</span><br><span class="line">    Iterator&lt;SelectorProvider&gt; i = sl.iterator();</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!i.hasNext())</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            provider = i.next();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ServiceConfigurationError sce) &#123;</span><br><span class="line">            <span class="keyword">if</span> (sce.getCause() <span class="keyword">instanceof</span> SecurityException) &#123;</span><br><span class="line">                <span class="comment">// Ignore the security exception, try the next provider</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">throw</span> sce;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>3.跨平台<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultSelectorProvider</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Prevent instantiation.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">DefaultSelectorProvider</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns the default SelectorProvider.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SelectorProvider <span class="title">create</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//可以发现未windows下jdk实现</span></span><br><span class="line">        <span class="comment">//macosx实现: return new sun.nio.ch.KQueueSelectorProvider();</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> sun.nio.ch.WindowsSelectorProvider();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> netty </category>
          
          <category> Reactor </category>
          
      </categories>
      
      
        <tags>
            
            <tag> netty </tag>
            
            <tag> Reactor </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>netty学习-1.0-初识netty</title>
      <link href="/2021/04/01/netty%E5%AD%A6%E4%B9%A0-1-0/"/>
      <url>/2021/04/01/netty%E5%AD%A6%E4%B9%A0-1-0/</url>
      
        <content type="html"><![CDATA[<p>该文为极客时间netty源码解析记录笔记</p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>官方定义为：Netty 是一款异步的事件驱动的网络应用程序框架，支持快速地开发可维护的高性能的面向协议的服务器和客户端<br>Netty 由 Trustin Lee(韩国， Line公司)2004年开发</p><ul><li><p>本质：网络应用程序框架</p></li><li><p>实现：异步、事件驱动</p></li><li><p>特性: 高性能、可维护、快速开发</p></li><li><p>用途: 开发服务器和客户端<br>Netty结构图：<br><img src="/img/netty/components.png" alt="Netty结构图"></p></li></ul><h2 id="为什么不直接使用jdk-NIO"><a href="#为什么不直接使用jdk-NIO" class="headerlink" title="为什么不直接使用jdk NIO"></a>为什么不直接使用jdk NIO</h2><p>Netty做得更多:</p><ul><li>支持常用应用层协议;</li><li>解决传输问题: 黏包、半包现象;</li><li>支持流量整形;</li><li>完善的断连、idle等异常处理等。</li></ul><p>Netty做得更好:</p><ul><li><p>未关闭问题较少<br><img src="/img/netty/jdkNio.png" alt="Netty结构图"><br>Netty解决方案:</p></li><li><p>API更友好更强大<br>  JDK的NIO一些API不够友好，功能薄弱， 例如ByteBuffer -&gt; Netty’s ByteBuf</p><p>  除NIO外， 也提供了其他一些增强: Threadlocal -&gt; Netty’s FastThreadLocal</p></li><li><p>隔离变化、屏蔽细节<br>  隔离JDK NIO的实现变化: nio-&gt; nio2(aio)<br>  屏蔽JDK NIO的实现细节</p></li></ul><h2 id="从版本演变上看发展"><a href="#从版本演变上看发展" class="headerlink" title="从版本演变上看发展"></a>从版本演变上看发展</h2><ul><li><p>2004年6月Netty2发布<br>声称Java社区中第一个基于事件驱动的应用网络框架</p></li><li><p>2008年10月 Netty3发布</p></li><li><p>2013年7月 Netty4发布</p></li><li><p>2013年12月发布5.0.0.Alpha1</p></li><li><p>2015年11月废弃5.0.0</p></li></ul><h2 id="使用Netty的经典项目"><a href="#使用Netty的经典项目" class="headerlink" title="使用Netty的经典项目"></a>使用Netty的经典项目</h2><ul><li><p>检索: Elasticsearch</p></li><li><p>框架: gRPC、 Apache Dubbo、 Spring5</p></li><li><p>分布式协调器: ZooKeeper</p></li><li><p>工具类: async-http-client</p></li><li><p>更多应用:<a href="https://netty.io/wiki/adopters.html" target="_blank" rel="noopener">https://netty.io/wiki/adopters.html</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> netty </category>
          
      </categories>
      
      
        <tags>
            
            <tag> netty </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RabbitMQ的4种广播类型与DEMO</title>
      <link href="/2021/03/01/RabbitMQ%E7%9A%844%E7%A7%8D%E5%B9%BF%E6%92%AD%E7%B1%BB%E5%9E%8B/"/>
      <url>/2021/03/01/RabbitMQ%E7%9A%844%E7%A7%8D%E5%B9%BF%E6%92%AD%E7%B1%BB%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="rabbitmq管理界面"><a href="#rabbitmq管理界面" class="headerlink" title="rabbitmq管理界面"></a>rabbitmq管理界面</h2><p>可见我的上篇文章介绍的rabbitMQ基础与docker安装rabbitMQ management<br>网址输入：<a href="http://127.0.0.1:15672/" target="_blank" rel="noopener">http://127.0.0.1:15672/</a><br>登录名&amp;密码：guest<br><img src="/img/MQ/rabbitmq_2.png" alt="rabbitmq管理界面"></p><h2 id="1-直接模式Direct"><a href="#1-直接模式Direct" class="headerlink" title="1.直接模式Direct"></a>1.直接模式Direct</h2><h3 id="直接模式介绍"><a href="#直接模式介绍" class="headerlink" title="直接模式介绍"></a>直接模式介绍</h3><p>rabbitMQ直接模式:<br>最基础最简单的模式，发送方把消息发送给订阅方，如果有多个订阅者，默认采取轮询的方式进行消息发送。<br>当我们需要将消息发给唯一一个节点时使用这种模式，这是简单的一种形式。<br><img src="/img/MQ/rabbitmq_5.png" alt="直接模式"><br>任何发送到Direct Exchange的消息都会被转发到RouteKey中指定的Queue。 1.一般情况可以使用rabbitMQ自带的Exchange：””(该Exchange的名字为空字符串，下 文称其为default Exchange)。 2.这种模式下不需要将Exchange进行任何绑定(binding)操作 3.消息传递时需要一个“RouteKey”，可以简单的理解为要发送到的队列名字。 4.如果vhost中不存在RouteKey中指定的队列名，则该消息会被抛弃。</p><h3 id="直接模式demo代码"><a href="#直接模式demo代码" class="headerlink" title="直接模式demo代码"></a>直接模式demo代码</h3><p>添加队列<br><img src="/img/MQ/rabbitmq_3.png" alt="添加队列"></p><p>pom.xml:<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-amqp<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-autoconfigure<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>DirectCustomer.Class<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@RabbitListener</span>(queues = <span class="string">"rabbitMQ-direct"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DirectCustomer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RabbitHandler</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getMsg</span><span class="params">(String msg)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"直接模式消费消息"</span>+ msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>application.yml:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">spring: </span><br><span class="line">rabbitmq: </span><br><span class="line">host: 127.0.0.1</span><br></pre></td></tr></table></figure></p><p>appliction.properties:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spring.rabbitmq.host&#x3D;127.0.0.1</span><br></pre></td></tr></table></figure></p><p>Test:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.rabbitmq;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.Test;</span><br><span class="line"><span class="keyword">import</span> org.junit.runner.RunWith;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.rabbit.core.RabbitTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.test.context.SpringBootTest;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.context.junit4.SpringRunner;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RunWith</span>(SpringRunner<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">@<span class="title">SpringBootTest</span>(<span class="title">classes</span> </span>= RabbitmqApplication<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">RabbitmqApplicationTests</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">contextLoads</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RabbitTemplate rabbitTemplate;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSend</span><span class="params">()</span></span>&#123;</span><br><span class="line">        rabbitTemplate.convertAndSend(<span class="string">"rabbitMQ-direct"</span>,<span class="string">"我要红包"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>运行项目观察控制台<br><img src="/img/MQ/rabbitmq_4.png" alt="运行项目观察控制台"></p><h2 id="2-headers模式"><a href="#2-headers模式" class="headerlink" title="2.headers模式"></a>2.headers模式</h2><p>headers：与 direct 类似，只是性能很差，此类型几乎用不到。</p><h2 id="3-fanout分发模式"><a href="#3-fanout分发模式" class="headerlink" title="3.fanout分发模式"></a>3.fanout分发模式</h2><h3 id="fanout分发模式介绍"><a href="#fanout分发模式介绍" class="headerlink" title="fanout分发模式介绍"></a>fanout分发模式介绍</h3><p>分发模式，把消息分发给所有订阅者。<br>当我们需要将消息一次发给多个队列时，需要使用这种模式，如下图<br><img src="/img/MQ/rabbitmq_5.png" alt="分发模式"><br>任何发送到Direct Exchange的消息都会被转发到RouteKey中指定的Queue。 1.一般情况可以使用rabbitMQ自带的Exchange：””(该Exchange的名字为空字符串，下 文称其为default Exchange)。 2.这种模式下不需要将Exchange进行任何绑定(binding)操作 3.消息传递时需要一个“RouteKey”，可以简单的理解为要发送到的队列名字。 4.如果vhost中不存在RouteKey中指定的队列名，则该消息会被抛弃。</p><h3 id="分发模式demo代码"><a href="#分发模式demo代码" class="headerlink" title="分发模式demo代码"></a>分发模式demo代码</h3><p>管理界面操作:<br><img src="/img/MQ/rabbitmq_6.png" alt="运行项目观察控制台"><br><img src="/img/MQ/rabbitmq_7.png" alt="运行项目观察控制台"><br><img src="/img/MQ/rabbitmq_8.png" alt="运行项目观察控制台"><br><img src="/img/MQ/rabbitmq_9.png" alt="运行项目观察控制台"><br><img src="/img/MQ/rabbitmq_10.png" alt="运行项目观察控制台"><br>Test:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSend2</span><span class="params">()</span></span>&#123;</span><br><span class="line">       rabbitTemplate.convertAndSend(<span class="string">"rabbitmq-gzx"</span>,<span class="string">""</span>,<span class="string">"分裂模式"</span>);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p><p>消费者代码:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.rabbitmq;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.rabbit.annotation.RabbitHandler;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.rabbit.annotation.RabbitListener;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@RabbitListener</span>(queues = <span class="string">"rabbitMQ-fanout1"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FanoutCustomer1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RabbitHandler</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getMsg</span><span class="params">(String msg)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"分发模式1消费消息"</span>+ msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.rabbitmq;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.rabbit.annotation.RabbitHandler;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.rabbit.annotation.RabbitListener;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@RabbitListener</span>(queues = <span class="string">"rabbitMQ-fanout2"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FanoutCustomer2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RabbitHandler</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getMsg</span><span class="params">(String msg)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"分发模式2消费消息"</span>+ msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>启动测试类发送消息，观察控制台结果<br><img src="/img/MQ/rabbitmq_11.png" alt="分发模式"></p><h2 id="4-topic主题模式"><a href="#4-topic主题模式" class="headerlink" title="4.topic主题模式"></a>4.topic主题模式</h2><h3 id="主题模式介绍"><a href="#主题模式介绍" class="headerlink" title="主题模式介绍"></a>主题模式介绍</h3><p>任何发送到Topic Exchange的消息都会被转发到所有关心RouteKey中指定话题的Queue上<br><img src="/img/MQ/rabbitmq_12.png" alt="主题模式"><br>如上图所示  此类交换器使得来自不同的源头的消息可以到达一个对列，其实说的更明白一点就是模 糊匹配的意思，例如：上图中红色对列的routekey为usa.#，#代表匹配任意字符，但是 要想消息能到达此对列，usa.必须匹配后面的#好可以随意。图中usa.news usa.weather,都能找到红色队列，符号 # 匹配一个或多个词，符号 <em> 匹配不多不少一个 词。因此 usa.# 能够匹配到 usa.news.XXX ，但是 usa.</em> 只会匹配到 usa.XXX 。  注：  交换器说到底是一个名称与队列绑定的列表。当消息发布到交换器时，实际上是由你所 连接的信道，将消息路由键同交换器上绑定的列表进行比较，后路由消息。<br>任何发送到Topic Exchange的消息都会被转发到所有关心RouteKey中指定话题的 Queue上</p><p>1.这种模式较为复杂，简单来说，就是每个队列都有其关心的主题，所有的消息都带有一 个“标题”(RouteKey)，Exchange会将消息转发到所有关注主题能与RouteKey模糊匹配的 队列。</p><p>2.这种模式需要RouteKey，也许要提前绑定Exchange与Queue。</p><p>3.在进行绑定时，要提供一个该队列关心的主题，如“#.log.#”表示该队列关心所有涉及 log的消息(一个RouteKey为”MQ.log.error”的消息会被转发到该队列)。</p><p>4.“#”表示0个或若干个关键字，“”表示一个关键字。如“log.”能与“log.warn”匹配，无法 与“log.warn.timeout”匹配；但是“log.#”能与上述两者匹配。</p><p>5.同样，如果Exchange没有发现能够与RouteKey匹配的Queue，则会抛弃此消息 </p><h3 id="主题模式demo代码"><a href="#主题模式demo代码" class="headerlink" title="主题模式demo代码"></a>主题模式demo代码</h3><p>管理界面操作:<br><img src="/img/MQ/rabbitmq_13.png" alt="主题模式"><br><img src="/img/MQ/rabbitmq_14.png" alt="主题模式"></p><p>Test:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testTopicSend1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    rabbitTemplate.convertAndSend(<span class="string">"rabbitmq-topic"</span>,<span class="string">"china.news"</span>,<span class="string">"主题模式消息1"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testTopicSend2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    rabbitTemplate.convertAndSend(<span class="string">"rabbitmq-topic"</span>,<span class="string">"chengdu.weather"</span>,<span class="string">"主题模式消息2"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testTopicSend3</span><span class="params">()</span></span>&#123;</span><br><span class="line">    rabbitTemplate.convertAndSend(<span class="string">"rabbitmq-topic"</span>,<span class="string">"usa.news"</span>,<span class="string">"主题模式消息3"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>查看运行结果:<br><img src="/img/MQ/rabbitmq_15.png" alt="主题模式"></p>]]></content>
      
      
      <categories>
          
          <category> rabbitmq </category>
          
      </categories>
      
      
        <tags>
            
            <tag> rabbitmq </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue+springboot整合easyexcel</title>
      <link href="/2021/02/23/vue-springboot%E6%95%B4%E5%90%88easyexcel/"/>
      <url>/2021/02/23/vue-springboot%E6%95%B4%E5%90%88easyexcel/</url>
      
        <content type="html"><![CDATA[<h3 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h3><p>最近Vue+ssm开发项目的excel导入导出下载整合</p><h3 id="代码编写"><a href="#代码编写" class="headerlink" title="代码编写"></a>代码编写</h3><p>项目依赖</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.alibaba&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;easyexcel&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;!--目前最新的版本--&gt;</span><br><span class="line">    &lt;version&gt;LATEST&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure><h3 id="Excel录入功能"><a href="#Excel录入功能" class="headerlink" title="Excel录入功能"></a>Excel录入功能</h3><p>将excel转换为表数据</p><h4 id="后端代码"><a href="#后端代码" class="headerlink" title="后端代码:"></a>后端代码:</h4><p>mybatis-plus添加查询数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">import java.text.ParseException;</span><br><span class="line">import java.text.SimpleDateFormat;</span><br><span class="line">import java.util.Date;</span><br><span class="line">import java.util.UUID;</span><br><span class="line"></span><br><span class="line">import org.springframework.beans.BeanUtils;</span><br><span class="line"></span><br><span class="line">import com.alibaba.excel.context.AnalysisContext;</span><br><span class="line">import com.alibaba.excel.event.AnalysisEventListener;</span><br><span class="line">import com.baomidou.mybatisplus.core.conditions.query.QueryWrapper;</span><br><span class="line">import com.thunisoft.bid.entity.BidInfor;</span><br><span class="line">import com.thunisoft.bid.exception.BusinessException;</span><br><span class="line">import com.thunisoft.bid.service.BidExcelService;</span><br><span class="line">import com.thunisoft.bid.vo.req.ExcelVo;</span><br><span class="line"></span><br><span class="line">public class SubjectExcelListener extends AnalysisEventListener&lt;ExcelVo&gt; &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;因为SubjectExcelListener不能交给spring进行管理，需要自己new，不能注入其他对象</span><br><span class="line">    &#x2F;&#x2F;不能实现数据库操作</span><br><span class="line">    private BidExcelService bidExcelService;</span><br><span class="line"></span><br><span class="line">    public SubjectExcelListener() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public SubjectExcelListener(BidExcelService bidExcelService) &#123;</span><br><span class="line">        this.bidExcelService &#x3D; bidExcelService;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;读取excel内容，一行一行进行读取，不会读取excel中的表头数据</span><br><span class="line">    @Override</span><br><span class="line">    public void invoke(ExcelVo excelVo, AnalysisContext analysisContext) &#123;</span><br><span class="line">        if(excelVo &#x3D;&#x3D; null)&#123;</span><br><span class="line">            throw new BusinessException(20001,&quot;文件中的数据为空！&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;一行一行读取，每次读取</span><br><span class="line">        &#x2F;&#x2F;  判断数据库中是否存在相同项目名称、中标公司、采购单位数据，如果不存在则添加到数据库</span><br><span class="line">        BidInfor bidInfor &#x3D; existOneSubject(bidExcelService, excelVo.getProjectName(), excelVo.getPurchaseCompany(), excelVo.getBidCompany());</span><br><span class="line">        if( bidInfor &#x3D;&#x3D; null)&#123;</span><br><span class="line">            bidInfor &#x3D; new BidInfor();</span><br><span class="line">            BeanUtils.copyProperties(excelVo, bidInfor);</span><br><span class="line">            if (bidInfor.getBusinessLabel() &#x3D;&#x3D; null) &#123;</span><br><span class="line">                bidInfor.setBusinessLabel(&quot;未定义&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            try &#123;</span><br><span class="line">                bidInfor.setBidDate(simpleDateFormat.parse(excelVo.getBidDate().replaceAll(&quot;&#x2F;&quot;, &quot;-&quot;)));</span><br><span class="line">            &#125; catch (ParseException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            bidInfor.setId(UUID.randomUUID().toString().replaceAll(&quot;-&quot;, &quot;&quot;));</span><br><span class="line">            bidInfor.setCreateDate(new Date());</span><br><span class="line">            bidExcelService.save(bidInfor);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;判断避免重复添加</span><br><span class="line">    public BidInfor existOneSubject(BidExcelService bidExcelService, String subjectName, String purchaseCompany, String bidCompany)&#123;</span><br><span class="line">        QueryWrapper&lt;BidInfor&gt; BidInforQueryWrapper &#x3D; new QueryWrapper&lt;&gt;();</span><br><span class="line">        BidInforQueryWrapper.eq(&quot;project_name&quot;, subjectName);</span><br><span class="line">        BidInforQueryWrapper.eq(&quot;purchase_company&quot;, purchaseCompany);</span><br><span class="line">        BidInforQueryWrapper.eq(&quot;bid_company&quot;, bidCompany);</span><br><span class="line">        BidInfor bidInfor &#x3D; bidExcelService.getOne(BidInforQueryWrapper);</span><br><span class="line">        return bidInfor;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void doAfterAllAnalysed(AnalysisContext analysisContext) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@Service</span><br><span class="line">public class BidExcelServiceImpl extends ServiceImpl&lt;BidInforMapper, BidInfor&gt; implements BidExcelService &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void addSubject(MultipartFile file, BidExcelService bidExcelService) &#123;</span><br><span class="line">        &#x2F;&#x2F;文件输入流</span><br><span class="line">        InputStream in &#x3D; null;</span><br><span class="line">        try &#123;</span><br><span class="line">            in &#x3D; file.getInputStream();</span><br><span class="line">            &#x2F;&#x2F;调用方法进行读取,通过带参数的构造器将spring容器中的EduSubjectService对象传入到监听器中</span><br><span class="line">            EasyExcel.read(in, ExcelVo.class,new SubjectExcelListener(bidExcelService)).sheet().doRead();</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="前端代码"><a href="#前端代码" class="headerlink" title="前端代码"></a>前端代码</h4><p>Excel导入功能页面代码:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;el-row class&#x3D;&quot;home&quot; :gutter&#x3D;&quot;20&quot; style&#x3D;&quot;margin-top: 10px&quot;&gt;</span><br><span class="line">    &lt;el-col :span&#x3D;&quot;24&quot;&gt;</span><br><span class="line">      &lt;el-card shadow&#x3D;&quot;hover&quot;&gt;</span><br><span class="line">        &lt;el-upload</span><br><span class="line">          class&#x3D;&quot;upload-demo&quot;</span><br><span class="line">          action&#x3D;&quot;&quot;</span><br><span class="line">          :on-preview&#x3D;&quot;handlePreview&quot;</span><br><span class="line">          :on-remove&#x3D;&quot;handleRemove&quot;</span><br><span class="line">          :before-remove&#x3D;&quot;beforeRemove&quot;</span><br><span class="line">          :http-request&#x3D;&quot;uploadExcel&quot;</span><br><span class="line">          multiple</span><br><span class="line">          :limit&#x3D;&quot;1&quot;</span><br><span class="line">          :on-exceed&#x3D;&quot;handleExceed&quot;</span><br><span class="line">          :file-list&#x3D;&quot;fileList&quot;</span><br><span class="line">        &gt;</span><br><span class="line">          &lt;el-button size&#x3D;&quot;small&quot; type&#x3D;&quot;primary&quot;&gt;点击上传Excel&lt;&#x2F;el-button&gt;</span><br><span class="line">          &lt;div slot&#x3D;&quot;tip&quot; class&#x3D;&quot;el-upload__tip&quot;&gt;只能上传xlsx&#x2F;xls文件&lt;&#x2F;div&gt;</span><br><span class="line">        &lt;&#x2F;el-upload&gt;</span><br><span class="line">      &lt;&#x2F;el-card&gt;</span><br><span class="line">    &lt;&#x2F;el-col&gt;</span><br><span class="line">  &lt;&#x2F;el-row&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      fileList: []</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    handleRemove(file, fileList) &#123;</span><br><span class="line">      console.log(file, fileList)</span><br><span class="line">    &#125;,</span><br><span class="line">    handlePreview(file) &#123;</span><br><span class="line">      console.log(file)</span><br><span class="line">    &#125;,</span><br><span class="line">    handleExceed(files, fileList) &#123;</span><br><span class="line">      this.$message.warning(&#96;当前限制选择 1 个文件，本次选择了 $&#123;files.length&#125; 个文件，共选择了 $&#123;files.length + fileList.length&#125; 个文件&#96;);</span><br><span class="line">    &#125;,</span><br><span class="line">    &#x2F;&#x2F; eslint-disable-next-line no-unused-vars</span><br><span class="line">    beforeRemove(file, fileList) &#123;</span><br><span class="line">      return this.$confirm(&#96;确定移除 $&#123;file.name&#125;？&#96;)</span><br><span class="line">    &#125;,</span><br><span class="line">    uploadExcel(fileObj) &#123;</span><br><span class="line">      let formData &#x3D; new FormData()</span><br><span class="line">      formData.set(&#39;file&#39;, fileObj.file)</span><br><span class="line">      this.$axios</span><br><span class="line">        .post(&#39;&#x2F;excelData&#39;, formData, &#123;</span><br><span class="line">          headers: &#123;</span><br><span class="line">            &#39;Content-type&#39;: &#39;multipart&#x2F;form-data&#39;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">        .then()</span><br><span class="line">        .catch()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style lang&#x3D;&quot;scss&quot; scoped&gt;&lt;&#x2F;style&gt;</span><br></pre></td></tr></table></figure><p>前端样式：<br> <img src="/img/easyexcel/excel.png" alt="错误"></p><h3 id="将数据库数据导出为excel并提供用户下载接口"><a href="#将数据库数据导出为excel并提供用户下载接口" class="headerlink" title="将数据库数据导出为excel并提供用户下载接口"></a>将数据库数据导出为excel并提供用户下载接口</h3><h4 id="后端代码-1"><a href="#后端代码-1" class="headerlink" title="后端代码"></a>后端代码</h4><p>接口代码:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;excel表录入添加数据</span><br><span class="line">   @PostMapping(&quot;&#x2F;excelData&quot;)</span><br><span class="line">   public DataResult addBidDataFromExcel (MultipartFile file) &#123;</span><br><span class="line">       bidExcelService.addSubject(file, bidExcelService);</span><br><span class="line">       return DataResult.success();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   &#x2F;**</span><br><span class="line">    * 文件下载（失败了会返回一个有部分数据的Excel）</span><br><span class="line">    * &lt;p&gt;</span><br><span class="line">    * 1. 创建excel对应的实体对象 参照&#123;&#125;</span><br><span class="line">    * &lt;p&gt;</span><br><span class="line">    * 2. 设置返回的 参数</span><br><span class="line">    * &lt;p&gt;</span><br><span class="line">    * 3. 直接写，这里注意，finish的时候会自动关闭OutputStream,当然你外面再关闭流问题不大</span><br><span class="line">    *&#x2F;</span><br><span class="line">   @GetMapping(&quot;&#x2F;download&quot;)</span><br><span class="line">   public void download(HttpServletResponse response) throws IOException &#123;</span><br><span class="line">       &#x2F;&#x2F; 这里注意 有同学反应使用swagger 会导致各种问题，请直接用浏览器或者用postman</span><br><span class="line">       response.setContentType(&quot;application&#x2F;vnd.ms-excel&quot;);</span><br><span class="line">       response.setCharacterEncoding(&quot;utf-8&quot;);</span><br><span class="line">       &#x2F;&#x2F; 这里URLEncoder.encode可以防止中文乱码 当然和easyexcel没有关系</span><br><span class="line">       String fileName &#x3D; URLEncoder.encode(&quot;中标系统导出数据&quot;, &quot;UTF-8&quot;).replaceAll(&quot;\\+&quot;, &quot;%20&quot;);</span><br><span class="line">       response.setHeader(&quot;Content-disposition&quot;, &quot;attachment;filename*&#x3D;utf-8&#39;&#39;&quot; + fileName + &quot;.xlsx&quot;);</span><br><span class="line">       List&lt;BidInfor&gt; bidInforList &#x3D; bidExcelService.list(</span><br><span class="line">           Wrappers.&lt;BidInfor&gt;lambdaQuery().orderByDesc(BidInfor::getBidDate).select(BidInfor::getIndustry, BidInfor::getBidDate, BidInfor::getProvince,</span><br><span class="line">               BidInfor::getProjectName, BidInfor::getPurchaseWay,BidInfor::getPurchaseCompany, BidInfor::getDataSource, BidInfor::getBidCompany, BidInfor::getAmount, BidInfor::getNote,</span><br><span class="line">               BidInfor::getBusinessLabel, BidInfor::getTechnologyLabel, BidInfor::getCustomerLevel));</span><br><span class="line">       List&lt;DownloadDataVo&gt; downloadDataVoList &#x3D; new LinkedList&lt;&gt;();</span><br><span class="line">       for (BidInfor bidInfor : bidInforList) &#123;</span><br><span class="line">           downloadDataVoList.add(new DownloadDataVo(bidInfor.getIndustry(), bidInfor.getBidDate(), bidInfor.getProvince(), bidInfor.getProjectName(), bidInfor.getPurchaseWay(),</span><br><span class="line">               bidInfor.getPurchaseCompany(), bidInfor.getDataSource(), bidInfor.getBidCompany(), bidInfor.getAmount(), bidInfor.getNote(), bidInfor.getBusinessLabel(),</span><br><span class="line">               bidInfor.getTechnologyLabel(), bidInfor.getCustomerLevel()));</span><br><span class="line">       &#125;</span><br><span class="line">       EasyExcel.write(response.getOutputStream(), DownloadDataVo.class).sheet(&quot;中标系统导出数据&quot;).doWrite(downloadDataVoList);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h4 id="前端代码-1"><a href="#前端代码-1" class="headerlink" title="前端代码:"></a>前端代码:</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;el-button type&#x3D;&quot;primary&quot; @click&#x3D;&quot;downloadExcel&quot;&gt;导出全部数据&lt;&#x2F;el-button&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> methods: &#123;</span><br><span class="line">downloadExcel() &#123;</span><br><span class="line">      window.open(&#39;http:&#x2F;&#x2F;localhost:8080&#x2F;api&#x2F;download&#39;)</span><br><span class="line">      &#x2F;&#x2F;location.href &#x3D; &#39;http:&#x2F;&#x2F;localhost:8080&#x2F;api&#x2F;download&#39;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="问题记录"><a href="#问题记录" class="headerlink" title="问题记录"></a>问题记录</h3><p>注意请勿使用以下代码发生请求下载</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">this.$axios</span><br><span class="line">     .get(&#39;&#x2F;download&#39;, &#123;&#125;)</span><br><span class="line">     .then()</span><br><span class="line">     .catch(error &#x3D;&gt; &#123;</span><br><span class="line">        console.log(error)</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure><p>将导致以下结果:<br> <img src="/img/easyexcel/excelDownload.png" alt="错误"></p><p>原因:发送Ajax请求后，后端响应的是二进制数据，jQuery的Ajax只能接收JSON等数据。</p><p>解决方案: </p><ul><li>1.在新的标签页请求接口，在请求接口上自己拼接参数</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function download() &#123;</span><br><span class="line">    window.open(&quot;&#x2F;download&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>2.创建一个form表单，提交表单的方式下载</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">function download() &#123;</span><br><span class="line">    var studentName &#x3D; 1;</span><br><span class="line">    var form &#x3D; document.createElement(&#39;form&#39;);</span><br><span class="line">    form.id &#x3D; &#39;form&#39;;</span><br><span class="line">    form.name &#x3D; &#39;form&#39;;</span><br><span class="line">    &#x2F;&#x2F;把这个form放在body里面</span><br><span class="line">    document.body.appendChild(form);</span><br><span class="line">    &#x2F;&#x2F;给form里面创建一个input框，隐藏掉，来存参数</span><br><span class="line">    var input &#x3D; document.createElement(&#39;input&#39;);</span><br><span class="line">    input.type &#x3D; &#39;hidden&#39;;</span><br><span class="line">    input.name &#x3D; &#39;studentName&#39;;</span><br><span class="line">    input.value &#x3D; studentName;</span><br><span class="line">    &#x2F;&#x2F;把input放在form里面</span><br><span class="line">    form.appendChild(input);</span><br><span class="line">    form.method &#x3D; &quot;GET&quot; &#x2F;&#x2F;请求方式</span><br><span class="line">    form.action &#x3D; &#39;&#x2F;download&#39;;</span><br><span class="line">    form.submit();</span><br><span class="line">    &#x2F;&#x2F;删掉form</span><br><span class="line">    document.body.removeChild(form)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> vue </category>
          
          <category> easyexcel </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
            <tag> easyexcel </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mybatis-plus分组求和以及Map与Bean的转换</title>
      <link href="/2021/02/16/mybatis-plus%E5%88%86%E7%BB%84%E6%B1%82%E5%92%8C%E4%BB%A5%E5%8F%8AMap%E4%B8%8EBean%E7%9A%84%E8%BD%AC%E6%8D%A2/"/>
      <url>/2021/02/16/mybatis-plus%E5%88%86%E7%BB%84%E6%B1%82%E5%92%8C%E4%BB%A5%E5%8F%8AMap%E4%B8%8EBean%E7%9A%84%E8%BD%AC%E6%8D%A2/</url>
      
        <content type="html"><![CDATA[<h2 id="mybatis-plus分组求和"><a href="#mybatis-plus分组求和" class="headerlink" title="mybatis-plus分组求和"></a>mybatis-plus分组求和</h2><p>平常lambdaQuery写习惯了突然发现lambdaQuery好像不能求和，捡一下QueryWrapper写法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">QueryWrapper&lt;Entity&gt; yearQueryWrapper = <span class="keyword">new</span> QueryWrapper&lt;&gt;();</span><br><span class="line">        yearQueryWrapper.select(<span class="string">"bid_year as name,sum(amount) as value"</span>);</span><br><span class="line">        yearQueryWrapper.groupBy(<span class="string">"bid_year"</span>).orderByAsc(<span class="string">"bid_year"</span>);</span><br><span class="line">        List&lt;Map&lt;String, Object&gt;&gt; yearMapList= bidInforService.listMaps(yearQueryWrapper);</span><br></pre></td></tr></table></figure></p><p>groupby多个字段<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 源码信息</span></span><br><span class="line">    <span class="function"><span class="keyword">default</span> Children <span class="title">groupBy</span><span class="params">(R... columns)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.groupBy(<span class="keyword">true</span>, columns);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">QueryWrapper.groupBy(<span class="string">"bid_year"</span>,<span class="string">"bid_month"</span>);</span><br></pre></td></tr></table></figure></p><h2 id="map与javaBean对象转换"><a href="#map与javaBean对象转换" class="headerlink" title="map与javaBean对象转换"></a>map与javaBean对象转换</h2><h3 id="方法一-用Apache-BeanUtils将Map转Bean"><a href="#方法一-用Apache-BeanUtils将Map转Bean" class="headerlink" title="方法一:用Apache BeanUtils将Map转Bean"></a>方法一:用Apache BeanUtils将Map转Bean</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用apache的BeanUtils实现Map covert to Bean</span></span><br><span class="line">Map&lt;String,String&gt; map=<span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        User user=<span class="keyword">new</span> User();</span><br><span class="line">        map.put(<span class="string">"userName"</span>,<span class="string">"wang shisheng"</span>);</span><br><span class="line">        map.put(<span class="string">"passWord"</span>,<span class="string">"xxxxx44333"</span>);</span><br><span class="line"></span><br><span class="line">        BeanUtils.populate(user,map);</span><br></pre></td></tr></table></figure><h3 id="方法二-自封装工具类"><a href="#方法二-自封装工具类" class="headerlink" title="方法二:自封装工具类"></a>方法二:自封装工具类</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">public class MapToObjectUtil &#123;</span><br><span class="line">    public static &lt;T&gt; T map2Object(Map&lt;String, Object&gt; map, Class&lt;T&gt; clazz) &#123;</span><br><span class="line">        if (map &#x3D;&#x3D; null) &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        T obj &#x3D; null;</span><br><span class="line">        try &#123;</span><br><span class="line">            obj &#x3D; clazz.newInstance();</span><br><span class="line"></span><br><span class="line">            Field[] fields &#x3D; obj.getClass().getDeclaredFields();</span><br><span class="line">            for (Field field : fields) &#123;</span><br><span class="line">                int mod &#x3D; field.getModifiers();</span><br><span class="line">                if (Modifier.isStatic(mod) || Modifier.isFinal(mod)) &#123;</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;</span><br><span class="line">                field.setAccessible(true);</span><br><span class="line">                String filedTypeName &#x3D; field.getType().getName();</span><br><span class="line">                if (filedTypeName.equalsIgnoreCase(&quot;java.util.date&quot;)) &#123;</span><br><span class="line">                    String datetimestamp &#x3D; String.valueOf(map.get(field.getName()));</span><br><span class="line">                    if (datetimestamp.equalsIgnoreCase(&quot;null&quot;)) &#123;</span><br><span class="line">                        field.set(obj, null);</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        field.set(obj, new Date(Long.parseLong(datetimestamp)));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    field.set(obj, map.get(field.getName()));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        return obj;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实战使用:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Entity&gt; yearList = yearMapList.stream().map(item -&gt; MapToObjectUtil.map2Object(item, Entity<span class="class">.<span class="keyword">class</span>)).<span class="title">collect</span>(<span class="title">Collectors</span>.<span class="title">toList</span>())</span>;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> mybatis-plus </category>
          
          <category> map </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mybatis-plus </tag>
            
            <tag> map </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue-cli3脚手架创建项目变化</title>
      <link href="/2021/01/16/vue-cli3%E8%84%9A%E6%89%8B%E6%9E%B6%E5%88%9B%E5%BB%BA%E9%A1%B9%E7%9B%AE%E5%8F%98%E5%8C%96/"/>
      <url>/2021/01/16/vue-cli3%E8%84%9A%E6%89%8B%E6%9E%B6%E5%88%9B%E5%BB%BA%E9%A1%B9%E7%9B%AE%E5%8F%98%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h2 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h2><p>一晃眼Vue都出到4了发现自己对Vue3和Vue2之间的变化还不清楚，因为实习工作的原因经常在Vue3和Vue2之间反复横跳，项目结构的变化让自己很难受，特此记录一下。</p><h2 id="项目结构对比"><a href="#项目结构对比" class="headerlink" title="项目结构对比"></a>项目结构对比</h2><p><img src="/img/vue/v-cli2和v-cl3项目结构对比.png" alt="v-cli2和v-cl3项目结构对比"></p><h3 id="vue-cli2"><a href="#vue-cli2" class="headerlink" title="vue cli2"></a>vue cli2</h3><p>build包: 配置webpack,图中base.conf.js、dev.conf.js、prod.conf.js分别为webpack基础配置、开发环境配置、生产环境配置</p><p>config包: 配置一些全局的配置</p><p>static: 存放静态文件</p><h3 id="vue-cli3"><a href="#vue-cli3" class="headerlink" title="vue cli3"></a>vue cli3</h3><p>vue cli3已集成大部分的webpack配置</p><p>若需要手动配置需手动在根目录新建一个vue.config.js<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// vue.config.js 常用配置</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;     </span><br><span class="line"><span class="comment">// 基本路径 vue.cli 3.3以前请使用baseUrl     </span></span><br><span class="line">publicPath: <span class="string">'/'</span>, </span><br><span class="line"><span class="comment">// 输出文件目录           </span></span><br><span class="line">outputDir: <span class="string">'dist'</span>,</span><br><span class="line"> <span class="comment">// 用于嵌套生产的静态资产(js, css, img, fonts)的目录</span></span><br><span class="line"> assetsDir: <span class="string">''</span>,     </span><br><span class="line"> <span class="comment">// 生产sourceMap     </span></span><br><span class="line"> productionSourceMap: <span class="literal">true</span>,    </span><br><span class="line"><span class="comment">// webpack配置     </span></span><br><span class="line">configureWebpack: <span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;,     </span><br><span class="line">chainWebpack: <span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;,     </span><br><span class="line"><span class="comment">// css相关配置     </span></span><br><span class="line">css: &#123;      </span><br><span class="line"><span class="comment">// 启用 modules      </span></span><br><span class="line">modules: <span class="literal">false</span>,      </span><br><span class="line"><span class="comment">// 是否使用css分离插件     </span></span><br><span class="line">extract: <span class="literal">true</span>,      </span><br><span class="line"><span class="comment">// 开启CSS source maps?      </span></span><br><span class="line">sourceMap: <span class="literal">false</span>,      </span><br><span class="line"><span class="comment">// css预设配置项      </span></span><br><span class="line">loaderOptions: &#123;&#125;,     </span><br><span class="line">&#125;,     </span><br><span class="line"><span class="comment">// webpack-dev-server 相关配置  </span></span><br><span class="line">devServer: &#123;      </span><br><span class="line">host: <span class="string">'0.0.0.0'</span>,      </span><br><span class="line">port: <span class="number">8080</span>,      </span><br><span class="line">proxy: &#123;&#125;, </span><br><span class="line"><span class="comment">// 设置代理    </span></span><br><span class="line">&#125;,     </span><br><span class="line"><span class="comment">// 第三方插件配置 </span></span><br><span class="line">pluginOptions: &#123;      </span><br><span class="line"><span class="comment">// ...     </span></span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
            <tag> vue-cli3 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue的几种传值方式与demo代码</title>
      <link href="/2021/01/08/vue%E7%9A%84%E5%87%A0%E7%A7%8D%E4%BC%A0%E5%80%BC%E6%96%B9%E5%BC%8F%E4%B8%8Edemo%E4%BB%A3%E7%A0%81/"/>
      <url>/2021/01/08/vue%E7%9A%84%E5%87%A0%E7%A7%8D%E4%BC%A0%E5%80%BC%E6%96%B9%E5%BC%8F%E4%B8%8Edemo%E4%BB%A3%E7%A0%81/</url>
      
        <content type="html"><![CDATA[<h2 id="⽗⼦组件传值"><a href="#⽗⼦组件传值" class="headerlink" title="⽗⼦组件传值"></a>⽗⼦组件传值</h2><h2 id="几种传值方式"><a href="#几种传值方式" class="headerlink" title="几种传值方式"></a>几种传值方式</h2><ul><li>props / $emit<br>  ⼦组件中通过定义props接收⽗组件中通过v-bind绑定的数据<br>  ⽗组件中通过监听⼦组件中$emit的⾃定义事件接收数据</li><li>$parent / children<br>  ⼦组件中通过this.$parent这个对象获取⽗组件中的数据<br>  ⽗组件中通过this.$children这个数组获取⼦组件中的数据</li><li>$ref<br>  ⽗组件中定义⼦组件中的ref属性后，通过this.$refs.定义的属性名获取⼦组件数据</li></ul><h3 id="props-emit"><a href="#props-emit" class="headerlink" title="props / $emit"></a>props / $emit</h3><p>⼦组件中通过定义props接收⽗组件中通过v-bind绑定的数据<br>Parent.vue<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;h1&gt;Parent&lt;&#x2F;h1&gt;</span><br><span class="line">    &lt;my-child v-bind:msg&#x3D;&quot;&#39;form Parent msg&#39;&quot;&gt;&lt;&#x2F;my-child&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">import MyChild from &quot;.&#x2F;Child&quot;;</span><br><span class="line">export default &#123;</span><br><span class="line">  components: &#123;</span><br><span class="line">    MyChild</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style scoped&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;style&gt;</span><br></pre></td></tr></table></figure><br>Child.vue<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;h3&gt;Child&lt;&#x2F;h3&gt;</span><br><span class="line">    &lt;h5&gt;&#123;&#123;msg&#125;&#125;&lt;&#x2F;h5&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  props: &#123;</span><br><span class="line">    msg: &#123;</span><br><span class="line">      type: String,</span><br><span class="line">      default: &quot;&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style scoped&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;style&gt;</span><br></pre></td></tr></table></figure></p><p>传值结果:<br><img src="/img/vue/vue1.PNG" alt="父组件传值prop接收"></p><p>子组件通过$emit传值给父组件<br>Parent.vue<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;h1&gt;Parent&lt;&#x2F;h1&gt;</span><br><span class="line">    &lt;h3&gt;&#123;&#123;msg&#125;&#125;&lt;&#x2F;h3&gt;</span><br><span class="line">    &lt;my-child v-bind:msg&#x3D;&quot;&#39;form Parent msg&#39;&quot; @showMsg&#x3D;&quot;showMsg&quot;&gt;&lt;&#x2F;my-child&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">import MyChild from &quot;.&#x2F;Child&quot;;</span><br><span class="line">export default &#123;</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      msg: &#39;&#39;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  components: &#123;</span><br><span class="line">    MyChild</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    showMsg(val) &#123;</span><br><span class="line">      this.msg &#x3D; val</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style scoped&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;style&gt;</span><br></pre></td></tr></table></figure></p><p>Child.vue<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;h3&gt;Child&lt;&#x2F;h3&gt;</span><br><span class="line">    &lt;h5&gt;&#123;&#123;msg&#125;&#125;&lt;&#x2F;h5&gt;</span><br><span class="line">    &lt;button @click&#x3D;&quot;passMsg&quot;&gt;向父组件传值&lt;&#x2F;button&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  props: &#123;</span><br><span class="line">    msg: &#123;</span><br><span class="line">      type: String,</span><br><span class="line">      default: &quot;&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    passMsg() &#123;</span><br><span class="line">      this.$emit(&#39;showMsg&#39;, &#39;i am from child&#39;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style scoped&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;style&gt;</span><br></pre></td></tr></table></figure></p><p>传值结果:<br><img src="/img/vue/vue2.PNG" alt="子组件$emit传值"><br><img src="/img/vue/vue3.PNG" alt="子组件$emit传值"></p><h3 id="parent-children-ref"><a href="#parent-children-ref" class="headerlink" title="$parent / children $ref"></a>$parent / children $ref</h3><p>⼦组件中通过this.$parent这个对象获取⽗组件中的数据<br>⽗组件中通过this.$children这个数组获取⼦组件中的数据<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mounted() &#123;</span><br><span class="line">  console.log(this.$children)</span><br><span class="line">  console.log(&#39;ref&#39;,this.$res.child)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="⾮⽗⼦间传值"><a href="#⾮⽗⼦间传值" class="headerlink" title="⾮⽗⼦间传值"></a>⾮⽗⼦间传值</h2><h3 id="事件总线"><a href="#事件总线" class="headerlink" title="事件总线"></a>事件总线</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 原理上就是建⽴⼀个公共的js⽂件，专⻔⽤来传递消息</span><br><span class="line">&#x2F;&#x2F; bus.js</span><br><span class="line">import Vue from &#39;vue&#39;</span><br><span class="line">export default new Vue;</span><br><span class="line">&#x2F;&#x2F; 在需要传递消息的地⽅引⼊</span><br><span class="line">import bus from &#39;.&#x2F;bus.js&#39;</span><br><span class="line">&#x2F;&#x2F; 传递消息</span><br><span class="line">bus.$emit(&#39;msg&#39;, val)</span><br><span class="line">&#x2F;&#x2F; 接受消息</span><br><span class="line">bus.$emit(&#39;msg&#39;, val &#x3D;&gt; &#123;</span><br><span class="line"> console.log(val)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>App.vue<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div id&#x3D;&quot;app&quot;&gt;</span><br><span class="line">    &lt;button @click&#x3D;&quot;passMsg&quot;&gt;非父子传值App-&gt;Child&lt;&#x2F;button&gt;</span><br><span class="line">    </span><br><span class="line">    &lt;router-view&#x2F;&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">import bus from &#39;.&#x2F;util&#x2F;bus&#39;</span><br><span class="line">  export default &#123;</span><br><span class="line">    methods: &#123;</span><br><span class="line">      passMsg() &#123;</span><br><span class="line">        bus.$emit(&#39;msg&#39;,&#39;this is from App&#39;)      </span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,  </span><br><span class="line">  &#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure></p><p>Child.vue<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class&#x3D;&quot;child&quot;&gt;</span><br><span class="line">    &lt;h2&gt;This is a child page&lt;&#x2F;h2&gt;</span><br><span class="line">    &lt;h3&gt;&#123;&#123;msg&#125;&#125;&lt;&#x2F;h3&gt;</span><br><span class="line">    &lt;h4&gt;&#123;&#123;childMsg&#125;&#125;&lt;&#x2F;h4&gt;</span><br><span class="line">    &lt;button @click&#x3D;&quot;passtoParent&quot;&gt;子向父传值&lt;&#x2F;button&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">import bus from &#39;..&#x2F;util&#x2F;bus&#39;</span><br><span class="line">  export default &#123;</span><br><span class="line">    &#x2F;&#x2F;父向子传值</span><br><span class="line">    props:&#123;</span><br><span class="line">      msg:&#123;</span><br><span class="line">        type:String,</span><br><span class="line">        default:&#39;&#39;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    data() &#123;</span><br><span class="line">      return &#123;</span><br><span class="line">        childMsg: &#39;childMsg&#39;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    methods:&#123;</span><br><span class="line">      passtoParent()&#123;</span><br><span class="line">        this.$emit(&#39;showMsg&#39;,&#39;this is from child&#39;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    mounted () &#123;</span><br><span class="line">      &#x2F;&#x2F; bus.$on监听</span><br><span class="line">      bus.$on(&#39;msg&#39;,(val)&#x3D;&gt;&#123;</span><br><span class="line">        this.childMsg&#x3D;val</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line">&lt;style lang&#x3D;&quot;css&quot; scoped&gt;</span><br><span class="line">  .child&#123;</span><br><span class="line">     background-color:red;</span><br><span class="line">  &#125;     </span><br><span class="line">&lt;&#x2F;style&gt;</span><br></pre></td></tr></table></figure></p><h3 id="attrs-listeners"><a href="#attrs-listeners" class="headerlink" title="$attrs / $listeners"></a>$attrs / $listeners</h3><p>App.vue<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div id&#x3D;&quot;app&quot;&gt;</span><br><span class="line">    &lt;button @click&#x3D;&quot;passMsg&quot;&gt;非父子传值App-&gt;Child&lt;&#x2F;button&gt;</span><br><span class="line">    &lt;Parent :msg&#x3D;&#39;a&#39; :msg2&#x3D;&#39;b&#39; :msg3&#x3D;&#39;c&#39;&gt;&lt;&#x2F;Parent&gt;&#x2F;&#x2F;改动</span><br><span class="line">    &lt;router-view&#x2F;&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">import bus from &#39;.&#x2F;util&#x2F;bus&#39;</span><br><span class="line">import Parent from &#39;.&#x2F;views&#x2F;Parent&#39;</span><br><span class="line">  export default &#123;</span><br><span class="line">  &#x2F;&#x2F;改动</span><br><span class="line">    data() &#123;</span><br><span class="line">      return &#123;</span><br><span class="line">        a: &#39;msga&#39;,</span><br><span class="line">        b: &#39;msgb&#39;,</span><br><span class="line">        c: &#39;msgc&#39;,</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    components:&#123;</span><br><span class="line">      Parent</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">      passMsg() &#123;</span><br><span class="line">        bus.$emit(&#39;msg&#39;,&#39;this is from App&#39;)</span><br><span class="line">        </span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    </span><br><span class="line">  &#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure></p><p>Child.vue<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class&#x3D;&quot;child&quot;&gt;</span><br><span class="line">    &lt;h2&gt;This is a child page&lt;&#x2F;h2&gt;</span><br><span class="line">    &lt;h3&gt;&#123;&#123;msg&#125;&#125;&lt;&#x2F;h3&gt;</span><br><span class="line">    &lt;h4&gt;&#123;&#123;childMsg&#125;&#125;&lt;&#x2F;h4&gt;</span><br><span class="line">    &lt;button @click&#x3D;&quot;passtoParent&quot;&gt;子向父传值&lt;&#x2F;button&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">import bus from &#39;..&#x2F;util&#x2F;bus&#39;</span><br><span class="line">  export default &#123;</span><br><span class="line">    &#x2F;&#x2F;父向子传值</span><br><span class="line">    props:&#123;</span><br><span class="line">      msg:&#123;</span><br><span class="line">        type:String,</span><br><span class="line">        default:&#39;&#39;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    data() &#123;</span><br><span class="line">      return &#123;</span><br><span class="line">        childMsg: &#39;childMsg&#39;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    methods:&#123;</span><br><span class="line">      passtoParent()&#123;</span><br><span class="line">        this.$emit(&#39;showMsg&#39;,&#39;this is from child&#39;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    mounted () &#123;</span><br><span class="line">      &#x2F;&#x2F;改动</span><br><span class="line">      console.log(&#39;attrs&#39;,this.$attrs),</span><br><span class="line">      &#x2F;&#x2F; bus.$on监听</span><br><span class="line">      bus.$on(&#39;msg&#39;,(val)&#x3D;&gt;&#123;</span><br><span class="line">        this.childMsg&#x3D;val</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style lang&#x3D;&quot;css&quot; scoped&gt;</span><br><span class="line">  .child&#123;</span><br><span class="line">     background-color:red;</span><br><span class="line">  &#125;</span><br><span class="line">      </span><br><span class="line">&lt;&#x2F;style&gt;</span><br></pre></td></tr></table></figure></p><p>Pqarent.vue<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class&#x3D;&quot;parent&quot;&gt;</span><br><span class="line">    &lt;div&gt;this is a parent page&lt;&#x2F;div&gt;</span><br><span class="line">    &lt;h1&gt;&#123;&#123;msg&#125;&#125;&lt;&#x2F;h1&gt;</span><br><span class="line">    &lt;!-- 改动--&gt;</span><br><span class="line">    &lt;Child v-bind:msg&#x3D;&quot;&#39;from parent&#39;&quot; @showMsg&#x3D;&quot;showMsg1&quot; ref&#x3D;&quot;child&quot; v-bind&#x3D;&quot;$attrs&quot;&gt;&lt;&#x2F;Child&gt;</span><br><span class="line">    &lt;!-- @showMsg&#x3D;&quot;showMsg1&quot;监听事件 --&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">import Child from &#39;.&#x2F;Child&#39;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  data()&#123;</span><br><span class="line">    return&#123;</span><br><span class="line">      msg:&#39;&#39;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">  &#125;,</span><br><span class="line">  components: &#123;</span><br><span class="line">    Child</span><br><span class="line">  &#125;,</span><br><span class="line">  methods:&#123;</span><br><span class="line">    showMsg1(val)&#123;</span><br><span class="line">      this.msg&#x3D;val</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  mounted () &#123;</span><br><span class="line">    console.log(this.$children[0].childMsg);</span><br><span class="line">    console.log(&#39;ref&#39;,this.$refs.child)</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>javastream流</title>
      <link href="/2020/12/25/stream%E6%B5%81/"/>
      <url>/2020/12/25/stream%E6%B5%81/</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>在工作过程中看到类似以下代码，一时间理解不能，static void方法中有return方法，后续意识到这应该是stream流的拦截处理，特此记录巩固java stream的写法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;** 获取结案操作逻辑处理*&#x2F;</span><br><span class="line">private static void getXXXXByEnum(List&lt;Enum&gt; enumList, Entity entity, List&lt;String&gt; list) &#123;</span><br><span class="line">    enumList.forEach(enum -&gt; &#123;</span><br><span class="line">        for (Map&lt;String, Object&gt; mapItem : enum.getRule()) &#123;</span><br><span class="line">            List&lt;String&gt; collect &#x3D; mapItem.entrySet().stream().filter(item -&gt; &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    return (item.getValue() instanceof String &amp;&amp;</span><br><span class="line">                            (item.getValue()).equals(ReflectUtil.getFieldValue(entity, item.getKey())))</span><br><span class="line">                            ||</span><br><span class="line">                            (item.getValue() instanceof List &amp;&amp;</span><br><span class="line">                                    ((List&lt;String&gt;) item.getValue()).contains(ReflectUtil.getFieldValue(entity, item.getKey())));</span><br><span class="line">                &#125; catch (NoSuchMethodException | IllegalAccessException | InvocationTargetException e) &#123;</span><br><span class="line">                    log.error(&quot;获取字段：&#123;&#125; 出错&quot;, item.getKey());</span><br><span class="line">                    return false;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).map(Map.Entry::getKey).collect(Collectors.toList());</span><br><span class="line">            if (mapItem.size() &#x3D;&#x3D; collect.size()) &#123;</span><br><span class="line">                list.add(enum.getXXXXX());</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h3><h4 id="什么是-Stream？"><a href="#什么是-Stream？" class="headerlink" title="什么是 Stream？"></a>什么是 Stream？</h4><p>Stream（流）是一个来自数据源的元素队列并支持聚合操作</p><ul><li>元素是特定类型的对象，形成一个队列。 Java中的Stream并不会存储元素，而是按需计算。</li><li>数据源 流的来源。 可以是集合，数组，I/O channel， 产生器generator 等。</li><li><p>聚合操作 类似SQL语句一样的操作， 比如filter, map, reduce, find, match, sorted等。<br>和以前的Collection操作不同， Stream操作还有两个基础的特征：</p></li><li><p>Pipelining: 中间操作都会返回流对象本身。 这样多个操作可以串联成一个管道， 如同流式风格（fluent style）。 这样做可以对操作进行优化， 比如延迟执行(laziness)和短路( short-circuiting)。</p></li><li>内部迭代： 以前对集合遍历都是通过Iterator或者For-Each的方式, 显式的在集合外部进行迭代， 这叫做外部迭代。 Stream提供了内部迭代的方式， 通过访问者模式(Visitor)实现。</li></ul><h4 id="生成流"><a href="#生成流" class="headerlink" title="生成流"></a>生成流</h4><p>在 Java 8 中, 集合接口有两个方法来生成流：</p><ul><li><p>stream() − 为集合创建串行流。</p></li><li><p>parallelStream() − 为集合创建并行流。</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; strings &#x3D; Arrays.asList(&quot;abc&quot;, &quot;&quot;, &quot;bc&quot;, &quot;efg&quot;, &quot;abcd&quot;,&quot;&quot;, &quot;jkl&quot;);</span><br><span class="line">List&lt;String&gt; filtered &#x3D; strings.stream().filter(string -&gt; !string.isEmpty()).collect(Collectors.toList());</span><br></pre></td></tr></table></figure><h4 id="forEach"><a href="#forEach" class="headerlink" title="forEach"></a>forEach</h4><p>Stream 提供了新的方法 ‘forEach’ 来迭代流中的每个数据。以下代码片段使用 forEach 输出了10个随机数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Random random &#x3D; new Random();</span><br><span class="line">random.ints().limit(10).forEach(System.out::println);</span><br></pre></td></tr></table></figure><h4 id="map"><a href="#map" class="headerlink" title="map"></a>map</h4><p>map 方法用于映射每个元素到对应的结果，以下代码片段使用 map 输出了元素对应的平方数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; numbers &#x3D; Arrays.asList(3, 2, 2, 3, 7, 3, 5);</span><br><span class="line">&#x2F;&#x2F; 获取对应的平方数</span><br><span class="line">List&lt;Integer&gt; squaresList &#x3D; numbers.stream().map( i -&gt; i*i).distinct().collect(Collectors.toList());</span><br></pre></td></tr></table></figure><h4 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h4><p>filter 方法用于通过设置的条件过滤出元素。以下代码片段使用 filter 方法过滤出空字符串：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt;strings &#x3D; Arrays.asList(&quot;abc&quot;, &quot;&quot;, &quot;bc&quot;, &quot;efg&quot;, &quot;abcd&quot;,&quot;&quot;, &quot;jkl&quot;);</span><br><span class="line">&#x2F;&#x2F; 获取空字符串的数量</span><br><span class="line">long count &#x3D; strings.stream().filter(string -&gt; string.isEmpty()).count();</span><br></pre></td></tr></table></figure><h4 id="limit"><a href="#limit" class="headerlink" title="limit"></a>limit</h4><p>limit 方法用于获取指定数量的流。 以下代码片段使用 limit 方法打印出 10 条数据：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Random random &#x3D; new Random();</span><br><span class="line">random.ints().limit(10).forEach(System.out::println);</span><br></pre></td></tr></table></figure><h4 id="sorted"><a href="#sorted" class="headerlink" title="sorted"></a>sorted</h4><p>sorted 方法用于对流进行排序。以下代码片段使用 sorted 方法对输出的 10 个随机数进行排序：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Random random &#x3D; new Random();</span><br><span class="line">random.ints().limit(10).sorted().forEach(System.out::println);</span><br></pre></td></tr></table></figure><h4 id="并行（parallel）程序"><a href="#并行（parallel）程序" class="headerlink" title="并行（parallel）程序"></a>并行（parallel）程序</h4><p>parallelStream 是流并行处理程序的代替方法。以下实例我们使用 parallelStream 来输出空字符串的数量：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; strings &#x3D; Arrays.asList(&quot;abc&quot;, &quot;&quot;, &quot;bc&quot;, &quot;efg&quot;, &quot;abcd&quot;,&quot;&quot;, &quot;jkl&quot;);</span><br><span class="line">&#x2F;&#x2F; 获取空字符串的数量</span><br><span class="line">long count &#x3D; strings.parallelStream().filter(string -&gt; string.isEmpty()).count();</span><br></pre></td></tr></table></figure><h4 id="Collectors"><a href="#Collectors" class="headerlink" title="Collectors"></a>Collectors</h4><p>Collectors 类实现了很多归约操作，例如将流转换成集合和聚合元素。Collectors 可用于返回列表或字符串：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt;strings &#x3D; Arrays.asList(&quot;abc&quot;, &quot;&quot;, &quot;bc&quot;, &quot;efg&quot;, &quot;abcd&quot;,&quot;&quot;, &quot;jkl&quot;);</span><br><span class="line">List&lt;String&gt; filtered &#x3D; strings.stream().filter(string -&gt; !string.isEmpty()).collect(Collectors.toList());</span><br><span class="line"> </span><br><span class="line">System.out.println(&quot;筛选列表: &quot; + filtered);</span><br><span class="line">String mergedString &#x3D; strings.stream().filter(string -&gt; !string.isEmpty()).collect(Collectors.joining(&quot;, &quot;));</span><br><span class="line">System.out.println(&quot;合并字符串: &quot; + mergedString);</span><br></pre></td></tr></table></figure><h4 id="统计"><a href="#统计" class="headerlink" title="统计"></a>统计</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; numbers &#x3D; Arrays.asList(3, 2, 2, 3, 7, 3, 5);</span><br><span class="line"> </span><br><span class="line">IntSummaryStatistics stats &#x3D; numbers.stream().mapToInt((x) -&gt; x).summaryStatistics();</span><br><span class="line"> </span><br><span class="line">System.out.println(&quot;列表中最大的数 : &quot; + stats.getMax());</span><br><span class="line">System.out.println(&quot;列表中最小的数 : &quot; + stats.getMin());</span><br><span class="line">System.out.println(&quot;所有数之和 : &quot; + stats.getSum());</span><br><span class="line">System.out.println(&quot;平均数 : &quot; + stats.getAverage());</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> javastream </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javastream </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>消息队列、RabbitMQ简介</title>
      <link href="/2020/12/20/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E3%80%81RabbitMQ%E7%AE%80%E4%BB%8B/"/>
      <url>/2020/12/20/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E3%80%81RabbitMQ%E7%AE%80%E4%BB%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="消息队列简介"><a href="#消息队列简介" class="headerlink" title="消息队列简介"></a>消息队列简介</h2><p>消息队列MQ(Message Queue)中间件是分布式系统中重要的组件，主要解决应用耦合，异步消息，流量削锋等问题实现高性能，高可用，可伸缩和终一致性,使用较多的消息队列有ActiveMQ，RabbitMQ，ZeroMQ，Kafka，RocketMQ.其中把数据放到消息队列叫做生产者，从消息队列里边取数据叫做消费者。</p><h2 id="消息队列的作用"><a href="#消息队列的作用" class="headerlink" title="消息队列的作用"></a>消息队列的作用</h2><p><strong>解耦：</strong> 假设有A、B2个系统，B系统需要调用A系统的接口，在一次更新后B不再需要调用A系统或者需要新的系统对接A呢么A系统的代码需要修改，这使得系统形成了关联耦合性，若将A系统的要发送的数据放入消息队列中，新的系统和原来的系统只需要修改消费消息队列数据的代码即可，实现了解耦，如下图。通俗点说，可以将消息队列想象成蜂巢快递柜，快递员(系统A)和用户(系统B)不关心找不找到对的彼此和位置，快递员只需要将快递(消息数据)放到蜂巢柜(消息队列)等待用户去取(消费)即可。<br><img src="/img/MQ/mq_1.png" alt="解耦"><br><img src="/img/MQ/mq_2.png" alt="解耦"></p><p><strong>异步与流量削锋：</strong> 当我们不使⽤消息队列的时候，所有的⽤户的请求会直接落到服务器，然后通过数据库或者缓存响应。假如在⾼并发的场景下，如果没有缓存或者数据库承受不了这么⼤的压⼒的话，就会造成响应速度缓慢，甚⾄造成数据库宕机。但是，在使⽤消息队列之后，⽤户的请求数据发送给了消息队列之后就可以⽴即返回，再由消息队列的消费者进程从消息队列中获取数据，异步写⼊数据库，不过要确保消息不被重复消费还要考虑到消息丢失问题。由于消息队列服务器处理速度快于数据库，因此响应速度得到⼤幅改善。简而言之异步即服务读取消息队列数据的速度远高于数据库所以分布式形式的多个服务消费处理消息队列的数据可以提供系统响应速度，削峰即未使用消息队列和缓存之前所有用户的请求即是数据库、服务器的压力，使用消息队列后可以控制将大部分的请求暂存到消息队列中避免服务器突然处理过多的请求。如下图：<br><img src="/img/MQ/mq_3.png" alt="异步，削峰"></p><h2 id="RabbitMQ"><a href="#RabbitMQ" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>RabbitMQ 是一个由 Erlang 语言开发的 AMQP 的开源实现。<br>AMQP ：Advanced Message Queue，高级消息队列协议。它是应用层协议的一个开放 标准，为面向消息的中间件设计，基于此协议的客户端与消息中间件可传递消息，并不 受产品、开发语言等条件的限制。<br>RabbitMQ 初起源于金融系统，用于在分布式系统中存储转发消息，在易用性、扩展 性、高可用性等方面表现不俗。具体特点包括：<br>1.可靠性（Reliability）<br>RabbitMQ 使用一些机制来保证可靠性，如持久化、传输确认、发布确认。<br>2.灵活的路由（Flexible Routing）<br>在消息进入队列之前，通过 Exchange 来路由消息的。对于典型的路由功能，RabbitMQ 已经提供了一些内置的 Exchange 来实现。针对更复杂的路由功能，可以将多个 Exchange 绑定在一起，也通过插件机制实现自己的 Exchange 。<br>3.消息集群（Clustering）<br>多个 RabbitMQ 服务器可以组成一个集群，形成一个逻辑 Broker 。 4.高可用（Highly Available Queues）<br>队列可以在集群中的机器上进行镜像，使得在部分节点出问题的情况下队列仍然可用。<br>5.多种协议（Multi-protocol）<br>RabbitMQ 支持多种消息队列协议，比如 STOMP、MQTT 等等。<br>6.多语言客户端（Many Clients） RabbitMQ 几乎支持所有常用语言，比如 Java、.NET、Ruby 等等。<br>7.管理界面（Management UI）<br>RabbitMQ 提供了一个易用的用户界面，使得用户可以监控和管理消息 Broker 的许多方 面。<br>8.跟踪机制（Tracing）<br>如果消息异常，RabbitMQ 提供了消息跟踪机制，使用者可以找出发生了什么。 9.插件机制（Plugin System）<br>RabbitMQ 提供了许多插件，来从多方面进行扩展，也可以编写自己的插件。 </p><h3 id="RabbitMQ架构图"><a href="#RabbitMQ架构图" class="headerlink" title="RabbitMQ架构图"></a>RabbitMQ架构图</h3><p><img src="/img/MQ/rabbitmq_1.png" alt="RabbitMQ架构图"></p><h3 id="RabbitMQ主要概念"><a href="#RabbitMQ主要概念" class="headerlink" title="RabbitMQ主要概念"></a>RabbitMQ主要概念</h3><p>RabbitMQ Server： 也叫broker server，它是一种传输服务。 他的角色就是维护一条 从Producer到Consumer的路线，保证数据能够按照指定的方式进行传输。<br>Producer： 消息生产者，如图A、B、C，数据的发送方。消息生产者连接RabbitMQ服 务器然后将消息投递到Exchange。<br>Consumer：消息消费者，如图1、2、3，数据的接收方。消息消费者订阅队列， RabbitMQ将Queue中的消息发送到消息消费者。 Exchange：生产者将消息发送到Exchange（交换器），由Exchange将消息路由到一个 或多个Queue中（或者丢弃）。Exchange并不存储消息。RabbitMQ中的Exchange有 direct、fanout、topic、headers四种类型，每种类型对应不同的路由规则。<br>Queue：（队列）是RabbitMQ的内部对象，用于存储消息。消息消费者就是通过订阅 队列来获取消息的，RabbitMQ中的消息都只能存储在Queue中，生产者生产消息并终 投递到Queue中，消费者可以从Queue中获取消息并消费。多个消费者可以订阅同一个 Queue，这时Queue中的消息会被平均分摊给多个消费者进行处理，而不是每个消费者 都收到所有的消息并处理。<br>RoutingKey：生产者在将消息发送给Exchange的时候，一般会指定一个routing key， 来指定这个消息的路由规则，而这个routing key需要与Exchange Type及binding key联 合使用才能终生效。在Exchange Type与binding key固定的情况下（在正常使用时一 般这些内容都是固定配置好的），我们的生产者就可以在发送消息给Exchange时，通过 指定routing key来决定消息流向哪里。RabbitMQ为routing key设定的长度限制为255 bytes。<br>Connection： （连接）：Producer和Consumer都是通过TCP连接到RabbitMQ Server 的。以后我们可以看到，程序的起始处就是建立这个TCP连接。<br>Channels： （信道）：它建立在上述的TCP连接中。数据流动都是在Channel中进行 的。也就是说，一般情况是程序起始建立TCP连接，第二步就是建立这个Channel。<br>VirtualHost：权限控制的基本单位，一个VirtualHost里面有若干Exchange和 MessageQueue，以及指定被哪些user使用 </p><h3 id="docker环境下安装RabbitMQ"><a href="#docker环境下安装RabbitMQ" class="headerlink" title="docker环境下安装RabbitMQ"></a>docker环境下安装RabbitMQ</h3><p>(1)下载镜像<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull rabbitmq:management</span><br></pre></td></tr></table></figure><br>(2)创建容器，rabbitmq需要有映射以下端口:  5671   5672  4369  15671   15672   25672 </p><ul><li>15672 (if management plugin is enabled) </li><li>15671  management监听端口</li><li>5672, 5671 (AMQP 0-9-1 without and with TLS) </li><li>4369 (epmd)   epmd  代表 Erlang 端口映射守护进程 </li><li>25672 (Erlang distribution)<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run ‐di ‐‐name&#x3D;rabbitmq ‐p 5671:5617 ‐p 5672:5672 ‐p  4369:4369 ‐p 15671:15671 ‐p 15672:15672 ‐p 25672:25672 rabbitmq:management</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> rabbitmq </category>
          
      </categories>
      
      
        <tags>
            
            <tag> rabbitmq </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>布隆过滤器</title>
      <link href="/2020/12/11/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/"/>
      <url>/2020/12/11/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h3 id="布隆过滤器的优缺点概述"><a href="#布隆过滤器的优缺点概述" class="headerlink" title="布隆过滤器的优缺点概述"></a>布隆过滤器的优缺点概述</h3><h4 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h4><ul><li><p>由于存储的是二进制数据，所以占用的空间很小</p></li><li><p>它的插入和查询速度是非常快的，时间复杂度是O（K），可以联想一下HashMap的过程</p></li><li><p>保密性很好，因为本身不存储任何原始数据，只有二进制数据</p></li></ul><h4 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h4><ul><li><p>存在误判，详细说明与例子见上文布隆器基础介绍部分。</p></li><li><p>删除困难，试想布隆过滤器存入的几个数据经过计算的hash值相同，那么他们的二进制数组下标也一定相同，删除后导致与业务不相符的逻辑——删除了不应删除的hash值相同的数据。</p></li></ul><h3 id="布隆过滤器实现"><a href="#布隆过滤器实现" class="headerlink" title="布隆过滤器实现"></a>布隆过滤器实现</h3><h4 id="google-guava工具类实现"><a href="#google-guava工具类实现" class="headerlink" title="google.guava工具类实现"></a>google.guava工具类实现</h4><h5 id="demo理解"><a href="#demo理解" class="headerlink" title="demo理解"></a>demo理解</h5><ol><li><p>引入Guava pom配置</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.google.guava<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>guava<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>29.0-jre<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>代码实现(demo版)</p></li></ol><p>向布隆过滤器中插入100万个数据，使用bloomFilter.mightContain方法判断再添加数据会出现下标重合的误判。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.google.common.hash.BloomFilter;</span><br><span class="line"><span class="keyword">import</span> com.google.common.hash.Funnels;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BloomFilterCase</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 预计要插入多少数据</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> size = <span class="number">1000000</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 期望的误判率</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">double</span> fpp = <span class="number">0.01</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 布隆过滤器</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> BloomFilter&lt;Integer&gt; bloomFilter = BloomFilter.create(Funnels.integerFunnel(), size, fpp);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 插入10万样本数据</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">      bloomFilter.put(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用另外十万测试数据，测试误判率</span></span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = size; i &lt; size + <span class="number">100000</span>; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (bloomFilter.mightContain(i)) &#123;</span><br><span class="line">        count++;</span><br><span class="line">        System.out.println(i + <span class="string">"误判了"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">"总共的误判数:"</span> + count);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>运行结果</li></ol><p><img src="C:\Users\admin\AppData\Roaming\Typora\typora-user-images\image-20201221134211518.png" alt="image-20201221134211518"></p><p>10万数据里有947个误判，约等于0.01%，也就是我们代码里设置的误判率：fpp = 0.01。</p><ol><li>核心源码分析(guava  29.0-jre 版本)</li></ol><p><strong>创建布隆过滤器</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">BloomFilter&lt;T&gt; <span class="title">create</span><span class="params">(Funnel&lt;? <span class="keyword">super</span> T&gt; funnel, <span class="keyword">int</span> expectedInsertions, <span class="keyword">double</span> fpp)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> create(funnel, (<span class="keyword">long</span>)expectedInsertions, fpp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">BloomFilter&lt;T&gt; <span class="title">create</span><span class="params">(Funnel&lt;? <span class="keyword">super</span> T&gt; funnel, <span class="keyword">long</span> expectedInsertions, <span class="keyword">double</span> fpp)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> create(funnel, expectedInsertions, fpp, BloomFilterStrategies.MURMUR128_MITZ_64);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@VisibleForTesting</span></span><br><span class="line">    <span class="keyword">static</span> &lt;T&gt; <span class="function">BloomFilter&lt;T&gt; <span class="title">create</span><span class="params">(Funnel&lt;? <span class="keyword">super</span> T&gt; funnel, <span class="keyword">long</span> expectedInsertions, <span class="keyword">double</span> fpp, BloomFilter.Strategy strategy)</span> </span>&#123;</span><br><span class="line">        Preconditions.checkNotNull(funnel);</span><br><span class="line">        Preconditions.checkArgument(expectedInsertions &gt;= <span class="number">0L</span>, <span class="string">"Expected insertions (%s) must be &gt;= 0"</span>, expectedInsertions);</span><br><span class="line">        Preconditions.checkArgument(fpp &gt; <span class="number">0.0</span>D, <span class="string">"False positive probability (%s) must be &gt; 0.0"</span>, fpp);</span><br><span class="line">        Preconditions.checkArgument(fpp &lt; <span class="number">1.0</span>D, <span class="string">"False positive probability (%s) must be &lt; 1.0"</span>, fpp);</span><br><span class="line">        Preconditions.checkNotNull(strategy);</span><br><span class="line">        <span class="keyword">if</span> (expectedInsertions == <span class="number">0L</span>) &#123;</span><br><span class="line">            expectedInsertions = <span class="number">1L</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> numBits = optimalNumOfBits(expectedInsertions, fpp);</span><br><span class="line">        <span class="keyword">int</span> numHashFunctions = optimalNumOfHashFunctions(expectedInsertions, numBits);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> BloomFilter(<span class="keyword">new</span> LockFreeBitArray(numBits), numHashFunctions, funnel, strategy);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalArgumentException var10) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Could not create BloomFilter of "</span> + numBits + <span class="string">" bits"</span>, var10);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>所需参数：</p><ul><li><code>funnel</code>：数据类型(一般是调用Funnels工具类中的)</li><li><code>expectedInsertions</code>：期望插入的值的个数</li><li><code>fpp</code>：误判率(默认值为0.03)</li><li><code>strategy</code>：哈希算法</li></ul><p><strong>参数fpp误判率与所占内存</strong></p><p><strong>情景一：fpp = 0.01</strong></p><ul><li>误判个数： 947</li></ul><p><img src="C:\Users\admin\Desktop\blog\fpp001.jpg" alt="fpp001"></p><ul><li>占内存大小</li></ul><p><img src="C:\Users\admin\Desktop\blog\fpp001bites.jpg" alt="fpp001bites"></p><p><strong>情景二：fpp=0.03</strong></p><ul><li>误判个数：</li></ul><p><img src="C:\Users\admin\Desktop\blog\fp003.jpg" alt="fp003"></p><ul><li>占内存大小</li></ul><p><img src="C:\Users\admin\Desktop\blog\fpp003bites.jpg" alt="fpp003bites"></p><p><strong>情景总结</strong></p><ul><li>误判率可以通过<code>fpp</code>参数进行调节</li><li>fpp越小，需要的内存空间就越大：0.01需要900多万位数，0.03需要700多万位数。</li><li>fpp越小，集合添加数据时，就需要更多的hash函数运算更多的hash值，去存储到对应的数组下标里。（忘了去看上面的布隆过滤存入数据的过程）</li></ul><p>上面的<code>numBits</code>，表示存一百万个int类型数字，需要的位数为7298440，700多万位。理论上存一百万个数，一个int是4字节32位，需要481000000=3200万位。如果使用HashMap去存，按HashMap50%的存储效率，需要6400万位。可以看出BloomFilter的存储空间很小，只有HashMap的1/10左右</p><p>上面的<code>numHashFunctions</code>表示需要几个hash函数运算，去映射不同的下标存这些数字是否存在（0 or 1）。</p><p>布隆过滤器中添加、判断是否误判方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> BloomFilterStrategies implements Strategy &#123;</span><br><span class="line">MURMUR128_MITZ_64 &#123;</span><br><span class="line">        <span class="keyword">public</span> &lt;T&gt; <span class="function"><span class="keyword">boolean</span> <span class="title">put</span><span class="params">(T object, Funnel&lt;? <span class="keyword">super</span> T&gt; funnel, <span class="keyword">int</span> numHashFunctions, BloomFilterStrategies.LockFreeBitArray bits)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">long</span> bitSize = bits.bitSize();</span><br><span class="line">            <span class="keyword">byte</span>[] bytes = Hashing.murmur3_128().hashObject(object, funnel).getBytesInternal();</span><br><span class="line">            <span class="keyword">long</span> hash1 = <span class="keyword">this</span>.lowerEight(bytes);</span><br><span class="line">            <span class="keyword">long</span> hash2 = <span class="keyword">this</span>.upperEight(bytes);</span><br><span class="line">            <span class="keyword">boolean</span> bitsChanged = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">long</span> combinedHash = hash1;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numHashFunctions; ++i) &#123;</span><br><span class="line">                bitsChanged |= bits.set((combinedHash &amp; <span class="number">9223372036854775807L</span>) % bitSize);</span><br><span class="line">                combinedHash += hash2;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> bitsChanged;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> &lt;T&gt; <span class="function"><span class="keyword">boolean</span> <span class="title">mightContain</span><span class="params">(T object, Funnel&lt;? <span class="keyword">super</span> T&gt; funnel, <span class="keyword">int</span> numHashFunctions, BloomFilterStrategies.LockFreeBitArray bits)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">long</span> bitSize = bits.bitSize();</span><br><span class="line">            <span class="keyword">byte</span>[] bytes = Hashing.murmur3_128().hashObject(object, funnel).getBytesInternal();</span><br><span class="line">            <span class="keyword">long</span> hash1 = <span class="keyword">this</span>.lowerEight(bytes);</span><br><span class="line">            <span class="keyword">long</span> hash2 = <span class="keyword">this</span>.upperEight(bytes);</span><br><span class="line">            <span class="keyword">long</span> combinedHash = hash1;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numHashFunctions; ++i) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!bits.get((combinedHash &amp; <span class="number">9223372036854775807L</span>) % bitSize)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                combinedHash += hash2;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    .........</span><br></pre></td></tr></table></figure><h4 id="Redis实现"><a href="#Redis实现" class="headerlink" title="Redis实现"></a>Redis实现</h4><p>上面使用Guava实现的布隆过滤器是把数据放在了本地内存中。分布式的场景中就不合适了，无法共享内存。<br>我们还可以用Redis来实现布隆过滤器，这里使用Redis封装好的客户端工具Redisson。<br>其底层是使用数据结构bitMap</p><h5 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h5><ol><li><p>导入配置</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.redisson<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>redisson-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.13.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>java代码</p></li></ol><p>guava工具类使用mightContain()判断是否存在，可在访问要求查缓存前查询缓存是否存在，避免缓存穿透。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedissonBloomFilter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Config config = <span class="keyword">new</span> Config();</span><br><span class="line">    config.useSingleServer().setAddress(<span class="string">"redis://127.0.0.1:6379"</span>);</span><br><span class="line">    config.useSingleServer().setPassword(<span class="string">"1234"</span>);</span><br><span class="line">    <span class="comment">//构造Redisson</span></span><br><span class="line">    RedissonClient redisson = Redisson.create(config);</span><br><span class="line"></span><br><span class="line">    RBloomFilter&lt;String&gt; bloomFilter = redisson.getBloomFilter(<span class="string">"phoneList"</span>);</span><br><span class="line">    <span class="comment">//初始化布隆过滤器：预计元素为100000000L,误差率为3%</span></span><br><span class="line">    bloomFilter.tryInit(<span class="number">100000000L</span>,<span class="number">0.03</span>);</span><br><span class="line">    <span class="comment">//将号码10086插入到布隆过滤器中</span></span><br><span class="line">    bloomFilter.add(<span class="string">"10086"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断下面号码是否在布隆过滤器中</span></span><br><span class="line">    <span class="comment">//输出false</span></span><br><span class="line">    System.out.println(bloomFilter.contains(<span class="string">"123456"</span>));</span><br><span class="line">    <span class="comment">//输出true</span></span><br><span class="line">    System.out.println(bloomFilter.contains(<span class="string">"10086"</span>));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 布隆过滤器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 布隆过滤器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常见Java并发中断相关方法</title>
      <link href="/2020/11/26/%E5%B8%B8%E8%A7%81Java%E5%B9%B6%E5%8F%91%E4%B8%AD%E6%96%AD%E6%96%B9%E6%B3%95/"/>
      <url>/2020/11/26/%E5%B8%B8%E8%A7%81Java%E5%B9%B6%E5%8F%91%E4%B8%AD%E6%96%AD%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>在极客时间学习09Java线程的生命周期(上)时，课后思考出现了本文没有介绍的isInterrupted()方法，特此记录学习Java并发中断方法。</p><h2 id="中断介绍"><a href="#中断介绍" class="headerlink" title="中断介绍"></a>中断介绍</h2><p>并发编程引用了中断机制无疑证明了中断对多线程并发的裨益，想想死锁的四个条件：互斥、请求与保持、环路等待、不可抢占。中断可以完美的破坏请求与保持、环路等待的死锁条件。再比如有的线程可能迷失在怪圈无法自拔（自旋浪费资源），这时就可以用其他线程在恰当的时机给它个中断通知，被“中断”的线程可以选择在恰当的时机选择跳出怪圈，最大化的利用资源。</p><p>了解Thread类中断方法之前我们先了解一下中断标识，Java 的每个线程对象里都有一个 boolean 类型的标识，代表是否有中断请求，注：这个标识通过底层 native 方法实现的。</p><h2 id="中断相关方法"><a href="#中断相关方法" class="headerlink" title="中断相关方法"></a>中断相关方法</h2><p>先上源码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Deprecated</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    SecurityManager security = System.getSecurityManager();</span><br><span class="line">    <span class="keyword">if</span> (security != <span class="keyword">null</span>) &#123;</span><br><span class="line">        checkAccess();</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> != Thread.currentThread()) &#123;</span><br><span class="line">            security.checkPermission(SecurityConstants.STOP_THREAD_PERMISSION);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// A zero status value corresponds to "NEW", it can't change to</span></span><br><span class="line">    <span class="comment">// not-NEW because we hold the lock.</span></span><br><span class="line">    <span class="keyword">if</span> (threadStatus != <span class="number">0</span>) &#123;</span><br><span class="line">        resume(); <span class="comment">// Wake up thread if it was suspended; no-op otherwise</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The VM can handle all thread states</span></span><br><span class="line">    stop0(<span class="keyword">new</span> ThreadDeath());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Deprecated</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">(Throwable obj)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">interrupt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> != Thread.currentThread())</span><br><span class="line">        checkAccess();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (blockerLock) &#123;</span><br><span class="line">        Interruptible b = blocker;</span><br><span class="line">        <span class="keyword">if</span> (b != <span class="keyword">null</span>) &#123;</span><br><span class="line">            interrupt0();           <span class="comment">// Just to set the interrupt flag</span></span><br><span class="line">            b.interrupt(<span class="keyword">this</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    interrupt0();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">interrupted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> currentThread().isInterrupted(<span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isInterrupted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> isInterrupted(<span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">isInterrupted</span><span class="params">(<span class="keyword">boolean</span> ClearInterrupted)</span></span>;</span><br></pre></td></tr></table></figure></p><ol><li>stop():<br>虽然 stop() 方法确实可以停止一个正在运行的线程，但我们通过源码可以发现：该方法已被@Deprecated标识,表没该方法已被弃用，不推荐使用。<br>弃用原因：</li></ol><ul><li>调用 stop() 方法会立刻停止 run() 方法中剩余的全部工作，包括在 catch 或 finally 语句中的，并抛出ThreadDeath异常(通常情况下此异常不需要显示的捕获)，因此可能会导致一些清理性的工作的得不到完成，如文件，数据库等的关闭。</li><li>调用 stop() 方法会立即释放该线程所持有的所有的锁，导致数据得不到同步，出现数据不一致的问题。<br>同理还有类似suspend()、resume()方法，本文就不过多介绍这类弃用方法了。</li></ul><ol><li>interrupt():<br>interrupt() 方法是 唯一一个 可以将上面提到中断标志设置为 true 的方法，从上面源码可以看出，这是一个 Thread 类 public的对象方法，所以可以推断出任何线程对象都可以调用该方法，进一步说明就是可以一个线程 interrupt 其他线程，也可以 interrupt自己。其中，中断标识的设置是通过 native 方法 interrupt0 完成的。<br><img src="/img/thread/interrupt0.png" alt="interrupt0"> </li></ol><p>同时，我们关注一下源码注释：<br><img src="/img/thread/threadBlocked.png" alt="threadBlocked"><br>表达为当线程被阻塞在：wait()、join()、sleep()这些方法时，如果被中断，就会抛出 InterruptedException 异常。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">wait</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    wait(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>同理，这些抛出了InterruptedException异常的方法表明这些是可以中断的。<br>总结：当调用了interrupt()方法，线程的中断标志变为true。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">interrupt0();           <span class="comment">// Just to set the interrupt flag即只修改</span></span><br></pre></td></tr></table></figure></p><ol><li>isInterrupted():<br>该方法就是返回中断标识的结果：</li></ol><ul><li>true：线程被中断，</li><li>false：线程没被中断或被清空了中断标识（如何清空我们一会看）<br>拿到这个标识后，线程就可以判断这个标识来执行后续的逻辑</li></ul><ol><li>interrupted():<br>和上面的 isInterrupted() 方法差不多，两个方法都是调用 private 的 isInterrupted() 方法， 唯一差别就是会清空中断标识。常用于当处理线程要被大量中断并且只处理其中一次中断。</li></ol><h2 id="interrupt-方法理解注意："><a href="#interrupt-方法理解注意：" class="headerlink" title="interrupt()方法理解注意："></a>interrupt()方法理解注意：</h2><p>interrupt() 方法仅仅是通知线程，线程有机会执行一些后续操作，同时也可以无视这个通知。被 interrupt 的线程，是怎么收到通知的呢？一种是异<br>常，另一种是主动检测。当线程 A 处于 WAITING、TIMED_WAITING 状态时，如果其他线程调用线程 A 的interrupt() 方法，会使线程 A 返回到 RUNNABLE 状态，同时线程 A 的代码会触发InterruptedException 异常。上面我们提到转换到 WAITING、TIMED_WAITING状态的触发条件，都是调用了类似wait()、join()、sleep() 这样的方法，我们看这些方法的签名，发现都会 throws InterruptedException 这个异常。这个异常的触发条件就是：其他线程调用了该线程的 interrupt() 方法。当线程 A 处于 RUNNABLE 状态时，并且阻塞在 java.nio.channels.InterruptibleChannel上时，如果其他线程调用线程 A 的 interrupt() 方法，线程 A 会触发java.nio.channels.ClosedByInterruptException 这个异常；而阻塞在java.nio.channels.Selector 上时，如果其他线程调用线程 A 的 interrupt() 方法，线程 A的 java.nio.channels.Selector 会立即返回。上面这两种情况属于被中断的线程通过异常的方式获得了通知。还有一种是主动检测，如果线程处于 RUNNABLE 状态，并且没有阻塞在某个 I/O 操作上，例如中断计算圆周率的线程 A，这时就得依赖线程 A 主动检测中断状态了。如果其他线程调用线程 A 的interrupt()方法，那么线程 A 可以通过 isInterrupted() 方法，检测是不是自己被中断了。</p><font color='red'>即抛出异常throws InterruptedException的方法实现线程中断，interrupt方法用于通知中断</font>]]></content>
      
      
      <categories>
          
          <category> 并发编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 并发编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>并发编程初步认识与基础理论（一）</title>
      <link href="/2020/11/25/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%88%9D%E6%AD%A5%E8%AE%A4%E8%AF%86%E4%B8%8E%E5%9F%BA%E7%A1%80%E7%90%86%E8%AE%BA%EF%BC%88%E4%B8%80%EF%BC%89/"/>
      <url>/2020/11/25/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%88%9D%E6%AD%A5%E8%AE%A4%E8%AF%86%E4%B8%8E%E5%9F%BA%E7%A1%80%E7%90%86%E8%AE%BA%EF%BC%88%E4%B8%80%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="学习资源总结来源"><a href="#学习资源总结来源" class="headerlink" title="学习资源总结来源"></a>学习资源总结来源</h2><p>感谢这位大佬课程的教育与分享，从中我得以管中窥豹一番，本文为并发编程基础理论的个人总结笔记，欢迎大家于下方链接去学习更全面的Java并发编程知识。<br>来源：<a href="https://time.geekbang.org/column/intro/159?utm_campaign=guanwang&amp;utm_source=baidu-ad&amp;utm_medium=ppzq-pc&amp;utm_content=title&amp;utm_term=baidu-ad-ppzq-title" target="_blank" rel="noopener">https://time.geekbang.org/column/intro/159?utm_campaign=guanwang&amp;utm_source=baidu-ad&amp;utm_medium=ppzq-pc&amp;utm_content=title&amp;utm_term=baidu-ad-ppzq-title</a></p><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>为什么我们需要并发编程？我们使用并发编程肯定是因为他能为我们带来计算机任务运行效率的提升，让我们先回顾一下计算机组成原理，关注其中的CPU、内存、 I/O设备。我们知道CPU负责运算和处理不能存储数据,内存负责交换数据本身有一定的内存空间,I/O设备负责吧数据、指令及某些标志信息以及处理结果输入计算机或输出表示出来。</p><p>这三者间的速度差异巨大，CPU 和内存的速度差异可以形象地描述为：CPU 是天上一天，内存是地上一年（假设 CPU 执行一条普通指令需要一天，那么 CPU 读写内存得等待一年的时间）。内存和 I/O 设备的速度差异就更大了，内存是天上一天，I/O 设备是地上十年。</p><p>程序里大部分语句都要访问内存，有些还要访问 I/O，根据木桶理论（一只水桶能装多少水取决于它最短的那块木板），程序整体的性能取决于最慢的操作——读写 I/O 设备，也就是说单方面提高 CPU 性能是无效的。从性能角度讲，我们为了提高执行一定计算机任务的效率，在IO等待的时候不能让CPU闲这，我们把任务拆分交替执行，于是我们有了分时操作系统即此出现了并发，后来多核CPU使得计算机可以并行(同时处理多个任务)这时我们便需要对任务分配进行组织编排，也就是对线程组织编排。</p><p>这时线程之间需要通信，于是操作系统提供了一些让进程，线程之间通信的方式使得任务之间可以更有效的协作(一个线程执行完了唤醒其他线程通知他们执行)。但是事物总不是完美的。并发和通信带来了较高的编程复杂度，同时也出现了多线程并发操作共享资源的问题。于是天下大势，分久必合，我们又要将对共享资源的访问串行化(原因见后文常见并发问题，简要说可参考类似一个线程还未执行完其他线程使用线程共享对象资源导致预计与结果不一致的行为)。所以我们根据现实世界的做法设计了了锁，信号量等等来补充这套体系。</p><h2 id="并发问题源头"><a href="#并发问题源头" class="headerlink" title="并发问题源头"></a>并发问题源头</h2><h3 id="源头一：缓存导致的可见性问题"><a href="#源头一：缓存导致的可见性问题" class="headerlink" title="源头一：缓存导致的可见性问题"></a>源头一：缓存导致的可见性问题</h3><p>一个线程对共享变量的修改，另外一个线程能够立刻看到，我们称为可见性。</p><p>在单核时代，所有的线程都是在一颗 CPU 上执行，CPU 缓存与内存的数据一致性容易解决。因为所有线程都是操作同一个 CPU 的缓存，一个线程对缓存的写，对另外一个线程来说一定是可见的。例如在下面的图中，线程 A 和线程 B 都是操作同一个 CPU 里面的缓存，所以线程 A 更新了变量 V 的值，那么线程 B 之后再访问变量 V，得到的一定是 V 的最新值（线程 A 写过的值）。<br><img src="/img/thread/CPU缓存与内存的关系图.png" alt="CPU缓存与内存的关系图"> </p><p>多核时代，每颗 CPU 都有自己的缓存，这时 CPU 缓存与内存的数据一致性就没那么容易解决了，当多个线程在不同的 CPU 上执行时，这些线程操作的是不同的 CPU 缓存。比如下图中，线程 A 操作的是 CPU-1 上的缓存，而线程 B 操作的是 CPU-2 上的缓存，很明显，这个时候线程 A 对变量 V 的操作对于线程 B 而言就不具备可见性了。这个就属于硬件程序员给软件程序员挖的“坑”。<br><img src="/img/thread/多核CPU的缓存与内存关系图.png" alt="多核CPU的缓存与内存关系图"></p><p>下面我们再用一段代码来验证一下多核场景下的可见性问题。下面的代码，每执行一次add10K() 方法，都会循环 10000 次 count+=1 操作。在 calc() 方法中我们创建了两个线程，每个线程调用一次 add10K() 方法，我们来想一想执行 calc() 方法得到的结果应该是多少呢？<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">long</span> count = <span class="number">0</span>;</span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">add10K</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> <span class="keyword">int</span> idx = <span class="number">0</span>;</span><br><span class="line"> <span class="keyword">while</span>(idx++ &lt; <span class="number">10000</span>) &#123;</span><br><span class="line"> count += <span class="number">1</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">calc</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> <span class="keyword">final</span> Test test = <span class="keyword">new</span> Test();</span><br><span class="line"> <span class="comment">// 创建两个线程，执行 add() 操作</span></span><br><span class="line"> Thread th1 = <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line"> test.add10K();</span><br><span class="line"> &#125;);</span><br><span class="line"> Thread th2 = <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line"> test.add10K();</span><br><span class="line"> &#125;);</span><br><span class="line"> <span class="comment">// 启动两个线程</span></span><br><span class="line"> th1.start();</span><br><span class="line"> th2.start();</span><br><span class="line"> <span class="comment">// 等待两个线程执行结束</span></span><br><span class="line"> th1.join();</span><br><span class="line"> th2.join();</span><br><span class="line"> <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>直觉告诉我们应该是 20000，因为在单线程里调用两次 add10K() 方法，count 的值就是20000，但实际上 calc() 的执行结果是个 10000 到 20000 之间的随机数。为什么呢？我们假设线程 A 和线程 B 同时开始执行，那么第一次都会将 count=0 读到各自的 CPU 缓存里，执行完 count+=1 之后，各自 CPU 缓存里的值都是 1，同时写入内存后，我们会发现内存中是 1，而不是我们期望的 2。之后由于各自的 CPU 缓存里都有了 count 的值，两个线程都是基于 CPU 缓存里的 count 值来计算，所以导致最终 count 的值都是小于20000 的。这就是缓存的可见性问题。循环 10000 次count+=1 操作如果改为循环 1 亿次，你会发现效果更明显，最终 count的值接近 1 亿，而不是 2 亿。如果循环 10000 次，count 的值接近 20000，原因是两个线程不是同时启动的，有一个时差。<br><img src="/img/thread/变量count在CPU缓存和内存的分布图.png" alt="变量count在CPU缓存和内存的分布图"></p><h3 id="源头二-线程切换带来的原子性问题"><a href="#源头二-线程切换带来的原子性问题" class="headerlink" title="源头二:线程切换带来的原子性问题:"></a>源头二:线程切换带来的原子性问题:</h3><p>由于 IO 太慢，早期的操作系统就发明了多进程，即便在单核的 CPU 上我们也可以一边听着歌，一边写Bug，这个就是多进程的功劳。操作系统允许某个进程执行一小段时间，例如 50 毫秒，过了50毫秒操作系统就会重新选择一个进程来执行（我们称为“任务切换”），这个50毫秒称为“时间片”。<br><img src="/img/thread/线程切换示意图.png" alt="线程切换示意图"></p><p>在一个时间片内，如果一个进程进行一个 IO 操作，例如读个文件，这个时候该进程可以把自己标记为“休眠状态”并出让 CPU 的使用权，待文件读进内存，操作系统会把这个休眠的进程唤醒，唤醒后的进程就有机会重新获得 CPU 的使用权了。</p><p>这里的进程在等待 IO 时之所以会释放 CPU 使用权，是为了让 CPU在这段等待时间里可以<br>做别的事情，这样一来CPU的使用率就上来了；此外，如果这时有另外一个进程也读文件，读文件的操作就会排队，磁盘驱动在完成一个进程的读操作后，发现有排队的任务，就会立即启动下一个读操作，这样 IO 的使用率也上来了。</p><p>是不是很简单的逻辑？但是，虽然看似简单，支持多进程分时复用在操作系统的发展史上却具有里程碑意义，Unix 就是因为解决了这个问题而名噪天下的。</p><p>早期的操作系统基于进程来调度 CPU，不同进程间是不共享内存空间的，所以进程要做任务切换就要切换内存映射地址，而一个进程创建的所有线程，都是共享一个内存空间的，所以线程做任务切换成本就很低了。现代的操作系统都基于更轻量的线程来调度，现在我们提到的“任务切换”都是指“线程切换”。</p><p>Java 并发程序都是基于多线程的，自然也会涉及到任务切换，也许你想不到，任务切换竟然也是并发编程里诡异 Bug 的源头之一。任务切换的时机大多数是在时间片结束的时候，我们现在基本都使用高级语言编程，高级语言里一条语句往往需要多条 CPU 指令完成，例如上面代码中的count += 1，至少需要三条 CPU 指令。</p><p>指令 1：首先，需要把变量 count 从内存加载到 CPU 的寄存器；</p><p>指令 2：之后，在寄存器中执行 +1 操作；</p><p>指令 3：最后，将结果写入内存（缓存机制导致可能写入的是 CPU 缓存而不是内存）。</p><p>操作系统做任务切换，可以发生在任何一条 CPU 指令执行完，是的，是 CPU 指令，而不是高级语言里的一条语句。对于上面的三条指令来说，我们假设 count=0，如果线程 A 在指令 1 执行完后做线程切换，线程 A 和线程 B 按照下图的序列执行，那么我们会发现两个线程都执行了 count+=1 的操作，但是得到的结果不是我们期望的 2，而是 1。</p><p><img src="/img/thread/非原子操作的执行路径示意图.png" alt="非原子操作的执行路径示意图"></p><p>我们潜意识里面觉得 count+=1 这个操作是一个不可分割的整体，就像一个原子一样，线程的切换可以发生在 count+=1 之前，也可以发生在 count+=1 之后，但就是不会发生在中间。我们把一个或者多个操作在 CPU 执行的过程中不被中断的特性称为原子性。CPU 能保证的原子操作是 CPU 指令级别的，而不是高级语言的操作符，这是违背我们直觉的地方。因此，很多时候我们需要在高级语言层面保证操作的原子性。</p><h3 id="源头三：编译优化带来的有序性问题"><a href="#源头三：编译优化带来的有序性问题" class="headerlink" title="源头三：编译优化带来的有序性问题"></a>源头三：编译优化带来的有序性问题</h3><p>那并发编程里还有没有其他有违直觉容易导致诡异 Bug 的技术呢？有的，就是有序性。顾名思义，有序性指的是程序按照代码的先后顺序执行。编译器为了优化性能，有时候会改变程序中语句的先后顺序，例如程序中：“a=6；b=7；”编译器优化后可能变成“b=7；a=6；”，在这个例子中，编译器调整了语句的顺序，但是不影响程序的最终结果。不过有时候编译器及解释器的优化可能导致意想不到的 Bug。</p><p>在 Java 领域一个经典的案例就是利用双重检查创建单例对象，例如下面的代码：在获取实例 getInstance() 的方法中，我们首先判断 instance 是否为空，如果为空，则锁定 Singleton.class 并再次检查 instance 是否为空，如果还为空则创建 Singleton 的一个实例。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">static</span> Singleton instance;</span><br><span class="line">  <span class="function"><span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">​    <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">​      <span class="keyword">synchronized</span>(Singleton<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">​        <span class="keyword">if</span> (instance == <span class="keyword">null</span>)</span><br><span class="line">​          instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">​        &#125;</span><br><span class="line">​    &#125;</span><br><span class="line">​    <span class="keyword">return</span> instance;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>假设有两个线程 A、B 同时调用 getInstance() 方法，他们会同时发现 instance == null ，于是同时对 Singleton.class 加锁，此时 JVM 保证只有一个线程能够加锁成功（假设是线程 A），另外一个线程则会处于等待状态（假设是线程 B）；线程 A 会创建一个 Singleton 实例，之后释放锁，锁释放后，线程 B 被唤醒，线程 B 再次尝试加锁，此时是可以加锁成功的，加锁成功后，线程 B 检查 instance == null 时会发现，已经创建过 Singleton 实例了，所以线程 B 不会再创建一个 Singleton 实例。</p><p>这看上去一切都很完美，无懈可击，但实际上这个 getInstance() 方法并不完美。问题出在哪里呢？出在 new 操作上，我们以为的 new 操作应该是：</p><p>分配一块内存 M；</p><p>在内存 M 上初始化 Singleton 对象；</p><p>然后 M 的地址赋值给 instance 变量。</p><p>但是实际上优化后的执行路径却是这样的：</p><p>分配一块内存 M；</p><p>将 M 的地址赋值给 instance 变量；</p><p>最后在内存 M 上初始化 Singleton 对象。</p><p>优化后会导致什么问题呢？我们假设线程 A 先执行 getInstance() 方法，当执行完指令 2 时恰好发生了线程切换，切换到了线程 B 上；如果此时线程 B 也执行 getInstance() 方法，那么线程 B 在执行第一个判断时会发现 instance != null ，所以直接返回 instance，而此时的 instance 是没有初始化过的，如果我们这个时候访问 instance 的成员变量就可能触发空指针异常。</p><p><img src="/img/thread/双重检查创建单例的异常执行路径.png" alt="双重检查创建单例的异常执行路径"></p><h2 id="并发源头问题解决方案"><a href="#并发源头问题解决方案" class="headerlink" title="并发源头问题解决方案"></a>并发源头问题解决方案</h2><h3 id="Java内存模型-JMM-解决可见性问题与有序性问题"><a href="#Java内存模型-JMM-解决可见性问题与有序性问题" class="headerlink" title="Java内存模型(JMM)解决可见性问题与有序性问题"></a>Java内存模型(JMM)解决可见性问题与有序性问题</h3><h4 id="什么是Java内存模型"><a href="#什么是Java内存模型" class="headerlink" title="什么是Java内存模型"></a>什么是Java内存模型</h4><p>你已经知道，导致可见性的原因是缓存，导致有序性的原因是编译优化，那解决可见性、有序性最直接的办法就是禁用缓存和编译优化，但是这样问题虽然解决了，我们程序的性能可就堪忧了。</p><p>合理的方案应该是按需禁用缓存以及编译优化。那么，如何做到“按需禁用”呢？对于并发程序，何时禁用缓存以及编译优化只有程序员知道，那所谓“按需禁用”其实就是指按照程序员的要求来禁用。所以，为了解决可见性和有序性问题，只需要提供给程序员按需禁用缓存和编译优化的方法即可。</p><p>Java 内存模型是个很复杂的规范，可以从不同的视角来解读，站在我们这些程序员的视角，本质上可以理解为，Java 内存模型规范了 JVM 如何提供按需禁用缓存和编译优化的方法。具体来说，这些方法包括 volatile、synchronized 和 final 三个关键字，以及六项Happens-Before 规则，</p><h4 id="Java内存模型版本变动及volatile关键字使用"><a href="#Java内存模型版本变动及volatile关键字使用" class="headerlink" title="Java内存模型版本变动及volatile关键字使用"></a>Java内存模型版本变动及volatile关键字使用</h4><p>在 JDK1.2 之前，Java的内存模型实现总是从主存（即共享内存）读取变量，是不需要进⾏特别的注意的。⽽在当前的 Java 内存模型下，线程可以把变量保存本地内存（⽐如机器的寄存器）中，⽽不是直接在主存中进⾏读写。这就可能造成⼀个线程在主存中修改了⼀个变量的值，⽽另外⼀个线程还继续使⽤它在寄存器中的变量值的拷⻉，造成数据的不⼀致。要解决这个问题，就需要把变量声明为volatile，这就指示 JVM，这个变量是不稳定的，每次使⽤它都到主存中进⾏读取。说⽩了， volatile 关键字的主要作⽤就是保证变量的可⻅性然后还有⼀个作⽤是防⽌指令重排序。<br><img src="/img/thread/JMM.png" alt="java内存模型JMM"><br><img src="/img/thread/volatile.png" alt="volatile保证可见性原理"> </p><h4 id="Happens-Before-规则"><a href="#Happens-Before-规则" class="headerlink" title="Happens-Before 规则"></a>Happens-Before 规则</h4><p>如何理解 Happens-Before 呢？如果望文生义（很多网文也都爱按字面意思翻译成“先行发生”），那就南辕北辙了，Happens-Before 并不是说前面一个操作发生在后续操作的前面，它真正要表达的是：前面一个操作的结果对后续操作是可见的。就像有心灵感应的两个人，虽然远隔千里，一个人心之所想，另一个人都看得到。Happens-Before 规则就是要保证线程之间的这种“心灵感应”。所以比较正式的说法是：Happens-Before 约束了编译器的优化行为，虽允许编译器优化，但是要求编译器优化后一定遵守 Happens-Before 规则。</p><p>Happens-Before 规则应该是 Java 内存模型里面最晦涩的内容了，和程序员相关的规则一共有如下六项，都是关于可见性的。</p><p>恰好前面示例代码涉及到这六项规则中的前三项，为便于你理解，我也会分析上面的示例代码，来看看规则 1、2 和 3 到底该如何理解。至于其他三项，我也会结合其他例子作以说明。</p><ol><li><p>程序的顺序性规则<br>这条规则是指在一个线程中，按照程序顺序，前面的操作 Happens-Before 于后续的任意操作。这还是比较容易理解的，比如刚才那段示例代码，按照程序的顺序，第 6 行代码 “x = 42;” Happens-Before 于第 7 行代码 “v = true;”，这就是规则 1 的内容，也比较符合单线程里面的思维：程序前面对某个变量的修改一定是对后续操作可见的。<br>（为方便你查看，我将那段示例代码在这儿再呈现一遍）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VolatileExample</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">volatile</span> <span class="keyword">boolean</span> v = <span class="keyword">false</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">x = <span class="number">42</span>;</span><br><span class="line">v = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reader</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (v == <span class="keyword">true</span>) &#123;</span><br><span class="line"><span class="comment">// 这里 x 会是多少呢？</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>volatile 变量规则<br>这条规则是指对一个 volatile 变量的写操作， Happens-Before 于后续对这个 volatile 变量的读操作。<br>这个就有点费解了，对一个 volatile 变量的写操作相对于后续对这个 volatile 变量的读操作可见，这怎么看都是禁用缓存的意思啊，貌似和 1.5 版本以前的语义没有变化啊？如果单看这个规则，的确是这样，但是如果我们关联一下规则 3，就有点不一样的感觉了。</p></li><li><p>传递性<br>这条规则是指如果 A Happens-Before B，且 B Happens-Before C，那么 A Happens-Before C。<br>我们将规则 3 的传递性应用到我们的例子中，会发生什么呢？可以看下面这幅图：<br><img src="/img/thread/示例代码中的传递性规则.png" alt="示例代码中的传递性规则"> </p></li></ol><p>从图中，我们可以看到：<br>“x=42” Happens-Before 写变量 “v=true” ，这是规则 1 的内容；<br>写变量“v=true” Happens-Before 读变量 “v=true”，这是规则 2 的内容 。<br>再根据这个传递性规则，我们得到结果：“x=42” Happens-Before 读变量“v=true”。这意味着什么呢？<br>如果线程 B 读到了“v=true”，那么线程 A 设置的“x=42”对线程 B 是可见的。也就是说，线程 B 能看到 “x == 42” ，有没有一种恍然大悟的感觉？这就是 1.5 版本对 volatile 语义的增强，这个增强意义重大，1.5 版本的并发工具包（java.util.concurrent）就是靠volatile 语义来搞定可见性的，这个在后面的内容中会详细介绍。</p><ol><li>管程中锁的规则<br>这条规则是指对一个锁的解锁 Happens-Before 于后续对这个锁的加锁。<br>要理解这个规则，就首先要了解“管程指的是什么”。管程是一种通用的同步原语，在 Java 中指的就是 synchronized，synchronized 是 Java 里对管程的实现。<br>管程中的锁在 Java 里是隐式实现的，例如下面的代码，在进入同步块之前，会自动加锁，而在代码块执行完会自动释放锁，加锁以及释放锁都是编译器帮我们实现的。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123; <span class="comment">// 此处自动加锁</span></span><br><span class="line"><span class="comment">// x 是共享变量, 初始值 =10</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.x &lt; <span class="number">12</span>) &#123;</span><br><span class="line"><span class="keyword">this</span>.x = <span class="number">12</span>; </span><br><span class="line">&#125; </span><br><span class="line">&#125; <span class="comment">// 此处自动解锁</span></span><br></pre></td></tr></table></figure></li></ol><p>所以结合规则4——管程中锁的规则，可以这样理解：假设 x 的初始值是 10，线程 A 执行完代码块后 x 的值会变成 12（执行完自动释放锁），线程 B 进入代码块时，能够看到线程 A 对 x 的写操作，也就是线程 B 能够看到 x==12。这个也是符合我们直觉的，应该不难理解。</p><ol><li><p>线程 start() 规则<br>这条是关于线程启动的。它是指主线程 A 启动子线程 B 后，子线程 B 能够看到主线程在启动子线程 B 前的操作。<br>换句话说就是，如果线程 A 调用线程 B 的 start() 方法（即在线程 A 中启动线程 B），那么该 start() 操作 Happens-Before 于线程 B 中的任意操作。具体可参考下面示例代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Thread B = <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line"><span class="comment">// 主线程调用 B.start() 之前</span></span><br><span class="line"><span class="comment">// 所有对共享变量的修改，此处皆可见</span></span><br><span class="line"><span class="comment">// 此例中，var==77</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 此处对共享变量 var 修改</span></span><br><span class="line"><span class="keyword">var</span> = <span class="number">77</span>;</span><br><span class="line"><span class="comment">// 主线程启动子线程</span></span><br><span class="line">B.start();</span><br></pre></td></tr></table></figure></li><li><p>线程 join() 规则<br>这条是关于线程等待的。它是指主线程 A 等待子线程 B 完成（主线程 A 通过调用子线程 B 的 join() 方法实现），当子线程 B 完成后（主线程 A 中 join() 方法返回），主线程能够看到子线程的操作。当然所谓的“看到”，指的是对共享变量的操作。<br>换句话说就是，如果在线程 A 中，调用线程 B 的 join() 并成功返回，那么线程 B 中的任意操作 Happens-Before 于该 join() 操作的返回。具体可参考下面示例代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Thread B = <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line"><span class="comment">// 此处对共享变量 var 修改</span></span><br><span class="line"><span class="keyword">var</span> = <span class="number">66</span>;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 例如此处对共享变量修改，</span></span><br><span class="line"><span class="comment">// 则这个修改结果对线程 B 可见</span></span><br><span class="line"><span class="comment">// 主线程启动子线程</span></span><br><span class="line">B.start();</span><br><span class="line">B.join()</span><br><span class="line"><span class="comment">// 子线程所有对共享变量的修改</span></span><br><span class="line"><span class="comment">// 在主线程调用 B.join() 之后皆可见</span></span><br><span class="line"><span class="comment">// 此例中，var==66</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="解决原子性问题"><a href="#解决原子性问题" class="headerlink" title="解决原子性问题"></a>解决原子性问题</h3><p>根据上文源头我们已经知道，原子性问题的源头是线程切换，如果能够禁用线程切换那不就能解决这个问题了吗？而操作系统做线程切换是依赖 CPU 中断的，所以禁止CPU 发生中断就能够禁止线程切换。</p><p>在早期单核 CPU 时代，这个方案的确是可行的，而且也有很多应用案例，但是并不适合多核场景。这里我们以 32 位 CPU 上执行 long 型变量的写操作为例来说明这个问题，long型变量是 64 位，在 32 位 CPU 上执行写操作会被拆分成两次写操作（写高 32 位和写低32 位，如下图所示）。<br><img src="/img/thread/32位CPU执行64位变量long的写操作.png" alt="32位CPU执行64位变量long的写操作"> </p><p>在单核 CPU 场景下，同一时刻只有一个线程执行，禁止 CPU 中断，意味着操作系统不会重新调度线程，也就是禁止了线程切换，获得 CPU 使用权的线程就可以不间断地执行，所以两次写操作一定是：要么都被执行，要么都没有被执行，具有原子性。但是在多核场景下，同一时刻，有可能有两个线程同时在执行，一个线程执行在 CPU-1上，一个线程执行在 CPU-2 上，此时禁止 CPU 中断，只能保证 CPU 上的线程连续执行，并不能保证同一时刻只有一个线程执行，如果这两个线程同时写 long 型变量高 32 位的话，那就有可能出现我们开头提及的诡异Bug了。“同一时刻只有一个线程执行”这个条件非常重要，我们称之为互斥。如果我们能够保证对共享变量的修改是互斥的，那么，无论是单核 CPU 还是多核 CPU，就都能保证原子性了。</p><h4 id="简易锁模型"><a href="#简易锁模型" class="headerlink" title="简易锁模型"></a>简易锁模型</h4><p>当谈到互斥，相信聪明的你一定想到了那个杀手级解决方案：锁。同时大脑中还会出现以下模型：<br><img src="/img/thread/简易锁模型.png" alt="简易锁模型"> </p><p>我们把一段需要互斥执行的代码称为临界区。线程在进入临界区之前，首先尝试加锁lock()，如果成功，则进入临界区，此时我们称这个线程持有锁；否则呢就等待，直到持有锁的线程解锁；持有锁的线程执行完临界区的代码后，执行解锁 unlock()。这个过程非常像办公室里高峰期抢占坑位，每个人都是进坑锁门（加锁），出坑开门（解锁），如厕这个事就是临界区。很长时间里，我也是这么理解的。这样理解本身没有问题，但却很容易让我们忽视两个非常非常重要的点：我们锁的是什么？我们保护的又是什么？</p><h4 id="改进后的锁模型"><a href="#改进后的锁模型" class="headerlink" title="改进后的锁模型"></a>改进后的锁模型</h4><p>我们知道在现实世界里，锁和锁要保护的资源是有对应关系的，比如你用你家的锁保护你家的东西，我用我家的锁保护我家的东西。在并发编程世界里，锁和资源也应该有这个关系，但这个关系在我们上面的模型中是没有体现的，所以我们需要完善一下我们的模型。<br><img src="/img/thread/改进后的锁模型.png" alt="改进后的锁模型"></p><p>首先，我们要把临界区要保护的资源标注出来，如图中临界区里增加了一个元素：受保护的资源 R；其次，我们要保护资源 R 就得为它创建一把锁 LR；最后，针对这把锁 LR，我们还需在进出临界区时添上加锁操作和解锁操作。另外，在锁 LR 和受保护资源之间，我特地用一条线做了关联，这个关联关系非常重要。很多并发Bug的出现都是因为把它忽略了，然后就出现了类似锁自家门来保护他家资产的事情，这样的 Bug 非常不好诊断，因为潜意识里我们认为已经正确加锁了。 </p><h4 id="Java-语言提供的锁技术：synchronized"><a href="#Java-语言提供的锁技术：synchronized" class="headerlink" title="Java 语言提供的锁技术：synchronized"></a>Java 语言提供的锁技术：synchronized</h4><p>锁是一种通用的技术方案，Java 语言提供的 synchronized 关键字，就是锁的一种实现。<br>synchronized 关键字可以用来修饰方法，也可以用来修饰代码块，它的使用示例基本上都<br>是下面这个样子：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">X</span> </span>&#123;</span><br><span class="line"><span class="comment">// 修饰非静态方法</span></span><br><span class="line"><span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// 临界区</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 修饰静态方法</span></span><br><span class="line"><span class="function"><span class="keyword">synchronized</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bar</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// 临界区</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 修饰代码块</span></span><br><span class="line">Object obj = <span class="keyword">new</span> Object()；</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">baz</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">synchronized</span>(obj) &#123;</span><br><span class="line"><span class="comment">// 临界区</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>看完之后你可能会觉得有点奇怪，这个和我们上面提到的模型有点对不上号啊，加锁 lock()<br>和解锁 unlock() 在哪里呢？其实这两个操作都是有的，只是这两个操作是被 Java 默默加<br>上的，Java 编译器会在 synchronized 修饰的方法或代码块前后自动加上加锁 lock() 和解<br>锁 unlock()，这样做的好处就是加锁 lock() 和解锁 unlock() 一定是成对出现的，毕竟忘记<br>解锁 unlock() 可是个致命的 Bug（意味着其他线程只能死等下去了）。<br>那 synchronized 里的加锁 lock() 和解锁 unlock() 锁定的对象在哪里呢？上面的代码我们<br>看到只有修饰代码块的时候，锁定了一个 obj 对象，那修饰方法的时候锁定的是什么呢？<br>这个也是 Java 的一条隐式规则：</p><blockquote><p>当修饰静态方法的时候，锁定的是当前类的 Class 对象，在上面的例子中就<br>是 Class X；<br>当修饰非静态方法的时候，锁定的是当前实例对象 this。</p></blockquote><p>对于上面的例子，synchronized 修饰静态方法相当于:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">X</span> </span>&#123;</span><br><span class="line"><span class="comment">// 修饰静态方法</span></span><br><span class="line"><span class="keyword">synchronized</span>(X<span class="class">.<span class="keyword">class</span>) <span class="title">static</span> <span class="title">void</span> <span class="title">bar</span>() </span>&#123;</span><br><span class="line"><span class="comment">// 临界区</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>修饰非静态方法，相当于：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">X</span> </span>&#123;</span><br><span class="line"> <span class="comment">// 修饰非静态方法</span></span><br><span class="line"> <span class="keyword">synchronized</span>(<span class="keyword">this</span>) <span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> <span class="comment">// 临界区</span></span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="用-synchronized-解决-count-1-问题"><a href="#用-synchronized-解决-count-1-问题" class="headerlink" title="用 synchronized 解决 count+=1 问题"></a>用 synchronized 解决 count+=1 问题</h4><p>相信你一定记得我们前面文章中提到过的 count+=1 存在的并发问题，现在我们可以尝试用 synchronized 来小试牛刀一把，代码如下所示。SafeCalc 这个类有两个方法：一个是get() 方法，用来获得 value 的值；另一个是 addOne() 方法，用来给 value 加 1，并且addOne() 方法我们用 synchronized修饰。那么我们使用的这两个方法有没有并发问题呢？<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SafeCalc</span> </span>&#123;</span><br><span class="line"> <span class="keyword">long</span> value = <span class="number">0L</span>;</span><br><span class="line"> <span class="function"><span class="keyword">long</span> <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> <span class="keyword">return</span> value;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">addOne</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> value += <span class="number">1</span>;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们先来看看 addOne() 方法，首先可以肯定，被 synchronized 修饰后，无论是单核CPU 还是多核 CPU，只有一个线程能够执行 addOne() 方法，所以一定能保证原子操作，那是否有可见性问题呢？要回答这问题，就要重温一下上文中提到的管程中锁的规则。</p><blockquote><p>管程中锁的规则：对一个锁的解锁 Happens-Before 于后续对这个锁的加锁</p></blockquote><p>管程，就是我们这里的 synchronized（至于为什么叫管程，下篇文章介绍），我们知道synchronized 修饰的临界区是互斥的，也就是说同一时刻只有一个线程执行临界区的代码；而所谓“对一个锁解锁 Happens-Before 后续对这个锁的加锁”，指的是前一个线程<br>的解锁操作对后一个线程的加锁操作可见，综合 Happens-Before 的传递性原则，我们就能得出前一个线程在临界区修改的共享变量（该操作在解锁之前），对后续进入临界区（该操作在加锁之后）的线程是可见的。</p><p>按照这个规则，如果多个线程同时执行 addOne() 方法，可见性是可以保证的，也就说如果有 1000 个线程执行 addOne() 方法，最终结果一定是 value 的值增加了 1000。看到这个结果，我们长出一口气，问题终于解决了。</p><p>但也许，你一不小心就忽视了get()方法。执行addOne()方法后，value的值对get()方法是可见的吗？这个可见性是没法保证的。管程中锁的规则，是只保证后续对这个锁的加锁的可见性，而 get() 方法并没有加锁操作，所以可见性没法保证。那如何解决呢？很简单，就是 get() 方法也 synchronized 一下，完整的代码如下所示。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SafeCalc</span> </span>&#123;</span><br><span class="line"><span class="keyword">long</span> value = <span class="number">0L</span>;</span><br><span class="line"><span class="function"><span class="keyword">synchronized</span> <span class="keyword">long</span> <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">addOne</span><span class="params">()</span> </span>&#123;</span><br><span class="line">value += <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上面的代码转换为我们提到的锁模型，就是下面图示这个样子。get() 方法和 addOne() 方法都需要访问 value 这个受保护的资源，这个资源用 this 这把锁来保护。线程要进入临界区 get() 和 addOne()，必须先获得 this 这把锁，这样 get() 和 addOne() 也是互斥的。<br><img src="/img/thread/保护临界区get和addOne的示意图.png" alt="保护临界区get()和addOne()的示意图"></p><p>这个模型更像现实世界里面球赛门票的管理，一个座位只允许一个人使用，这个座位就是“受保护资源”，球场的入口就是 Java 类里的方法，而门票就是用来保护资源的“锁”，Java 里的检票工作是由 synchronized 解决的。锁和受保护资源的关系我们前面提到，受保护资源和锁之间的关联关系非常重要，他们的关系是怎样的呢？一个合理的关系是：受保护资源和锁之间的关联关系是 N:1 的关系。还拿前面球赛门票的管理来类比，就是一个座位，我们只能用一张票来保护，如果多发了重复的票，那就要打架了。现实世界里，我们可以用多把锁来保护同一个资源，但在并发领域是不行的，并发领域的锁和现实世界的锁不是完全匹配的。不过倒是可以用同一把锁来保护多个资源，这个对应到现实世界就是我们所谓的“包场”了。上面那个例子我稍作改动，把 value 改成静态变量，把 addOne() 方法改成静态方法，此时 get() 方法和 addOne() 方法是否存在并发问题呢？<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SafeCalc</span> </span>&#123;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">long</span> value = <span class="number">0L</span>;</span><br><span class="line"><span class="function"><span class="keyword">synchronized</span> <span class="keyword">long</span> <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">synchronized</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">addOne</span><span class="params">()</span> </span>&#123;</span><br><span class="line">value += <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如果你仔细观察，就会发现改动后的代码是用两个锁保护一个资源。这个受保护的资源就是静态变量value，两个锁分别是this和SafeCalc.class。我们可以用下面这幅图来形象描述这个关系。由于临界区 get() 和 addOne() 是用两个锁保护的，因此这两个临界区没有互斥关系，临界区 addOne() 对 value 的修改对临界区 get() 也没有可见性保证，这就导致并发问题了。<br><img src="/img/thread/两把锁保护一个资源的示意图.png" alt="两把锁保护一个资源的示意图"></p>]]></content>
      
      
      <categories>
          
          <category> 并发编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 并发编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>element-ui+mybatis-plus+springboot解决IPage分页问题</title>
      <link href="/2020/11/06/element-ui-mybatis-plus-springboot%E8%A7%A3%E5%86%B3IPage%E5%88%86%E9%A1%B5%E9%97%AE%E9%A2%98/"/>
      <url>/2020/11/06/element-ui-mybatis-plus-springboot%E8%A7%A3%E5%86%B3IPage%E5%88%86%E9%A1%B5%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>本文应用于ssm框架，解决controller接口返回mybatis-plus封装的IPage类型与Vue.element-ui前端的接收与分页</p><h2 id="mybatis-plus中的IPage与Page类"><a href="#mybatis-plus中的IPage与Page类" class="headerlink" title="mybatis-plus中的IPage与Page类"></a>mybatis-plus中的IPage与Page类</h2><p>首先上源码(部分)<br>接口Ipage类型：<br><img src="/img/vue/IPage.PNG" alt="Ipage部分源码"><br>IPage的实现类Page:<br><img src="/img/vue/Page.PNG" alt="Page部分源码"></p><p>源码可见Page是IPage的实现类，可见想使用mybatis-plus的封装分页则要明白Page类的属性<br>Page类的属性介绍：<br>records 用来存放查询出来的数据<br>total 返回记录的总数<br>size 每页显示条数，默认 10<br>current 当前页,默认1<br>orders 排序字段信息<br>optimizeCountSql 自动优化 COUNT SQL,默认true<br>isSearchCount 是否进行 count 查询,默认true<br>hitCount 是否命中count缓存,默认false</p><h2 id="实战实现"><a href="#实战实现" class="headerlink" title="实战实现"></a>实战实现</h2><h3 id="后端接口："><a href="#后端接口：" class="headerlink" title="后端接口："></a>后端接口：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/getOtherWorkList"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> IPage&lt;Work&gt; <span class="title">getOtherWorkByParam</span><span class="params">(@RequestParam <span class="keyword">long</span> size, @RequestParam <span class="keyword">long</span> current, HttpServletRequest request, WorkParam workParam)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        TokenUtil tokenUtil = <span class="keyword">new</span> TokenUtil();</span><br><span class="line">        String userId = tokenUtil.getRequestToken(request, redisService);</span><br><span class="line">        Page&lt;Work&gt; page = <span class="keyword">new</span> Page&lt;&gt;();</span><br><span class="line">        page.setCurrent(current);</span><br><span class="line">        page.setSize(size);</span><br><span class="line">        Page&lt;Work&gt; workPage = workService.page(page,Wrappers.&lt;Work&gt;lambdaQuery()</span><br><span class="line">                .eq(!workParam.getTitle().isEmpty() &amp;&amp; !workParam.getTitle().equals(<span class="string">""</span>), Work::getTitle, workParam.getTitle())</span><br><span class="line">                .eq(workParam.getStatus()!=<span class="keyword">null</span>, Work::getStatus, workParam.getStatus())</span><br><span class="line">                .eq(workParam.getType() != <span class="keyword">null</span>, Work::getType, workParam.getType())</span><br><span class="line">                .ne(userId!=<span class="keyword">null</span>, Work::getUserId, userId)</span><br><span class="line">                .between(workParam.getStartDate() != <span class="keyword">null</span> &amp;&amp; workParam.getStartDate().before(workParam.getEndDate()), Work::getCreateDate, workParam.getStartDate(), workParam.getEndDate()));</span><br><span class="line">        <span class="keyword">return</span> workPage;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>形参中size和current分别代表每页容量、当前页与Page类中属性名对应，形参能使用参数Page<Work> page更好，request用户获取请求头token验证登录用户，workParm为查询条件为前端table传来的检索条件</p><p>方便理解可以简化成以下代码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/getOtherWorkList"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> IPage&lt;Work&gt; <span class="title">getOtherWorkByParam</span><span class="params">(Page&lt;Work&gt; page)</span></span>&#123;</span><br><span class="line">        Page&lt;Work&gt; workPage = workService.page(page);</span><br><span class="line">        <span class="keyword">return</span> workPage;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><h3 id="前端请求发送与数据分页"><a href="#前端请求发送与数据分页" class="headerlink" title="前端请求发送与数据分页"></a>前端请求发送与数据分页</h3><p>前端分页</p><p>分页组件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class&#x3D;&quot;pagination&quot;&gt;</span><br><span class="line">     &lt;el-pagination</span><br><span class="line">        @size-change&#x3D;&quot;handleSizeChange&quot;</span><br><span class="line">        @current-change&#x3D;&quot;handleCurrentChange&quot;</span><br><span class="line">        :current-page&#x3D;&quot;page.current&quot;</span><br><span class="line">        :page-sizes&#x3D;&quot;[1, 5, 10, 20]&quot;</span><br><span class="line">        :page-size&#x3D;&quot;page.size&quot;</span><br><span class="line">        layout&#x3D;&quot;total, sizes, prev, pager, next, jumper&quot;</span><br><span class="line">        :total&#x3D;&quot;pageTotal&quot;&gt;</span><br><span class="line">    &lt;&#x2F;el-pagination&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure></p><p>table组件与处理数据分页:<br>注意：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:data&#x3D;&quot;records.slice((page.current-1)*page.size,page.current*page.size)&quot;</span><br></pre></td></tr></table></figure><br>请务必加上，page.current和page.size取决于你自己vue定义的数据属性</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;el-table</span><br><span class="line">               :data&#x3D;&quot;records.slice((page.current-1)*page.size,page.current*page.size)&quot;</span><br><span class="line">               border</span><br><span class="line">               class&#x3D;&quot;table&quot;</span><br><span class="line">               ref&#x3D;&quot;multipleTable&quot;</span><br><span class="line">               header-cell-class-name&#x3D;&quot;table-header&quot;</span><br><span class="line">               @selection-change&#x3D;&quot;handleSelectionChange&quot;</span><br><span class="line">           &gt;</span><br></pre></td></tr></table></figure><p>Vue定义绑定数据:<br>注意：Page数据在records中，注意看Page源码属性类型介绍<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">data() &#123;</span><br><span class="line">        return &#123;</span><br><span class="line">            tableData: [],</span><br><span class="line">            records: [],</span><br><span class="line">            multipleSelection: [],</span><br><span class="line">            page: &#123;</span><br><span class="line">                size: 1,</span><br><span class="line">                current: 1</span><br><span class="line">            &#125;,</span><br><span class="line">            workParam: &#123;&#125;,</span><br><span class="line">        &#125;;</span><br></pre></td></tr></table></figure></p><p>Vue请求发送与接收数据:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">created() &#123;</span><br><span class="line">       this.getData();</span><br><span class="line">   &#125;,</span><br><span class="line">   methods: &#123;</span><br><span class="line">       &#x2F;&#x2F; 获取 easy-mock 的模拟数据</span><br><span class="line">       async getData() &#123;</span><br><span class="line">           this.$http</span><br><span class="line">           .get(&#96;&#x2F;api&#x2F;work&#x2F;getOtherWorkList&#96;, &#123;</span><br><span class="line">           params: &#123;</span><br><span class="line">               size: this.page.size,</span><br><span class="line">               current: this.page.current</span><br><span class="line">           &#125;,</span><br><span class="line">           headers: &#123;</span><br><span class="line">           token: this.token,</span><br><span class="line">           &#125;,</span><br><span class="line">           &#125;)</span><br><span class="line">           .then((response) &#x3D;&gt; &#123;</span><br><span class="line">               this.records &#x3D; response.data.records;</span><br><span class="line">               console.log(this.records);</span><br><span class="line">               this.pageTotal &#x3D; response.data.total;</span><br><span class="line">               console.log(this.pageTotal);</span><br><span class="line">           &#125;)</span><br><span class="line">       &#125;,</span><br></pre></td></tr></table></figure></p><p>选择页面size事件方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">handleSizeChange(newSize)&#123;</span><br><span class="line">    console.log(newSize)</span><br><span class="line">    this.page.size &#x3D; newSize;</span><br><span class="line">    console.log(&#96;目前页面容量&#96;+this.query.pageSize)</span><br><span class="line">    this.getData()</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure></p><p>选择页码事件方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">handleCurrentChange(newPage)&#123;</span><br><span class="line">    console.log(newPage)</span><br><span class="line">    this.page.current &#x3D; newPage;</span><br><span class="line">    this.getData()</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure></p><h4 id="实现效果展示"><a href="#实现效果展示" class="headerlink" title="实现效果展示"></a>实现效果展示</h4><p><img src="/img/vue/分页1.PNG" alt="分页1"><br><img src="/img/vue/分页2.PNG" alt="分页2"><br><img src="/img/vue/分页3.PNG" alt="分页3"></p><h3 id="后端分页"><a href="#后端分页" class="headerlink" title="后端分页"></a>后端分页</h3><p>数据量较大每次由后端分页并发送给前端</p><p>后端分页代码发送前端数据代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line">** PageUtil.listToPage()方法作用为将list转化为Page类对象</span><br><span class="line">*&#x2F;</span><br><span class="line">@GetMapping(&quot;&#x2F;noParams&#x2F;getTableDataChartData&quot;)</span><br><span class="line">public Page&lt;BidInfor&gt; getTableData()&#123;</span><br><span class="line">    EchartsVo echartsVo &#x3D; new EchartsVo();</span><br><span class="line">    &#x2F;&#x2F; 查看redis缓存</span><br><span class="line">    if (redisService.get(Constant.REDIS_CACHE_SYS_NO_PARAMS_TABLE_CHARTS) !&#x3D; null) &#123;</span><br><span class="line">        String echartsVojSON &#x3D; redisService.get(Constant.REDIS_CACHE_SYS_NO_PARAMS_TABLE_CHARTS).toString();</span><br><span class="line">        echartsVo &#x3D; JSONObject.parseObject(echartsVojSON, EchartsVo.class);</span><br><span class="line">        List&lt;BidInfor&gt; bidInforList &#x3D; echartsVo.getTableData();</span><br><span class="line">        return PageUtil.listToPage(bidInforList, 1, 100);</span><br><span class="line">    &#125;</span><br><span class="line">    List&lt;BidInfor&gt; bidInforList &#x3D; bidInforService.tableDataOrderByAmount();</span><br><span class="line">    echartsVo.setTableData(bidInforList);</span><br><span class="line">    redisService.set(Constant.REDIS_CACHE_SYS_NO_PARAMS_TABLE_CHARTS, echartsVo);</span><br><span class="line">    return PageUtil.listToPage(bidInforList, 1, 100);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;*</span><br><span class="line">** 简化代码</span><br><span class="line">*&#x2F;</span><br><span class="line">@GetMapping(&quot;&#x2F;noParams&#x2F;getTableDataChartData&quot;)</span><br><span class="line">public Page&lt;BidInfor&gt; getTableData()&#123;</span><br><span class="line">    List&lt;BidInfor&gt; bidInforList &#x3D; bidInforService.tableDataOrderByAmount();</span><br><span class="line">    return PageUtil.listToPage(bidInforList, 1, 100);</span><br></pre></td></tr></table></figure></p><p>前端部分<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">      &lt;&#x2F;el-table&gt;</span><br><span class="line">      &lt;div class&#x3D;&quot;pagination&quot;&gt;</span><br><span class="line">        &lt;el-pagination</span><br><span class="line">          @size-change&#x3D;&quot;handleSizeChange&quot;</span><br><span class="line">          @current-change&#x3D;&quot;handleCurrentChange&quot;</span><br><span class="line">          :current-page&#x3D;&quot;page.current&quot;</span><br><span class="line">          :page-sizes&#x3D;&quot;[100, 500, 1000]&quot;</span><br><span class="line">          :page-size&#x3D;&quot;page.size&quot;</span><br><span class="line">          layout&#x3D;&quot;total, sizes, prev, pager, next, jumper&quot;</span><br><span class="line">          :total&#x3D;&quot;pageTotal&quot;</span><br><span class="line">        &gt;</span><br><span class="line">        &lt;&#x2F;el-pagination&gt;</span><br><span class="line">      &lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">data() &#123;</span><br><span class="line">  return &#123;</span><br><span class="line">        records: [],</span><br><span class="line">        pageTotal: null,</span><br><span class="line">        total: null,</span><br><span class="line">        page: &#123;</span><br><span class="line">          size: 100,</span><br><span class="line">          current: 1</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">methods: &#123;</span><br><span class="line">    handleCurrentChange(newPage) &#123;</span><br><span class="line">    console.log(newPage)</span><br><span class="line">    this.page.current &#x3D; newPage</span><br><span class="line">    this.likeSearch()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">    likeSearch() &#123;</span><br><span class="line">    this.$axios</span><br><span class="line">      .post(&#39;&#x2F;xxxxx, &#123;</span><br><span class="line">        frontParamVo: this.frontParamVo,</span><br><span class="line">        current: this.page.current,</span><br><span class="line">        size: this.page.size,</span><br><span class="line">        dataType: &#39;json&#39;,</span><br><span class="line">        headers: &#123;</span><br><span class="line">          &#39;Content-Type&#39;: &#39;application&#x2F;json;charset&#x3D;UTF-8&#39;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">      .then(res &#x3D;&gt; &#123;</span><br><span class="line">        res &#x3D; res.data</span><br><span class="line">        this.records &#x3D; []</span><br><span class="line">        this.records &#x3D; res.records</span><br><span class="line">        this.pageTotal &#x3D; res.total</span><br><span class="line">      &#125;)</span><br><span class="line">      .catch(error &#x3D;&gt; &#123;</span><br><span class="line">        console.log(error)</span><br><span class="line">      &#125;)</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> springboot </tag>
            
            <tag> mybatis-plus </tag>
            
            <tag> element-ui </tag>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis缓存雪崩、缓存穿透、缓存击穿与布隆过滤器</title>
      <link href="/2020/11/02/redis%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/"/>
      <url>/2020/11/02/redis%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>redis作为基于内存的非关系型数据库，通过读取缓存有效降低了大数据量访问系统(如购物商城网站)导致的数据库大量的磁盘读写操作，减少了数据库瘫痪、服务器宕机的风险。但是引入redis后也可能会产生新的问题导致redis缓存失效，大量数据访问依旧直接落在数据库上导致数据库瘫痪。本文主要介绍redis缓存雪崩、缓存穿透、缓存击穿与他们的解决方案。</p><h2 id="redis常见问题"><a href="#redis常见问题" class="headerlink" title="redis常见问题"></a>redis常见问题</h2><h3 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h3><p>我们知道redis存储的数据大部分会设置过期时间这就导致有可能大量数据过期时间相近使得某时段大量缓存失效，又或者redis集群(即多台执行相同redis缓存服务的服务器群)宕机、重启导致服务器服务失效无缓存可用。想象一下，redis集群是高山积雪底层的雪堆，发生上述两大类问题后就如同积雪的底层不再起支持作用，大量的数据访问如雪崩一样冲向山下的数据库，这无疑让数据库离瘫痪、服务器宕机不远了。下图为避免雪崩的数据访问流程图。<br><img src="/img/Redis/雪崩.png" alt="避免缓存雪崩的系统设计访问流程图"> </p><p>解决方案：</p><ol><li><p>设计上使用加锁或者队列的方式保证来保证不会有大量的线程对数据库一次性进行读写，从而避免失效时大量的并发请求落到底层存储系统上。<br>注意：加锁排队只是为了减轻数据库的压力，并没有提高系统吞吐量。假设在高并发下，缓存重建期间key是锁着的，这是过来1000个请求999个都在阻塞的。同样会导致用户等待超时</p></li><li><p>缓存失效时间分散开，比如我们可以在原有的失效时间基础上增加一个随机值，比如1-5分钟随机，这样每一个缓存的过期时间的重复率就会降低，就很难引发集体失效的事件。</p></li></ol><p>雪崩处理：</p><p>发生前：尽量保证整个 redis 集群的⾼可⽤性，发现机器宕机尽快补上。选择合适的内存淘汰策<br>略。降低失效时间重复率。</p><p>发生中：错峰限流降低对数据库的访问量，避免数据库瘫痪。</p><p>发生后：使用redis持久化策略RDB(快照)、AOF(文件追加)的文件尽快进行缓存恢复。</p><h3 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h3><p>缓存穿透说简单点就是⼤量请求的key根本不存在于缓存中,导致请求直接到了数据库上，根本没有经过缓存这⼀层。举个例⼦：某个⿊客故意制造我们缓存中不存在的key发起⼤量请求，导致⼤量请求落到数据库。下图分别为正常读取缓存流程、缓存中不存在该key直接访问数据库、设置布隆过滤器过滤非法key的流程。<br><img src="/img/Redis/穿透1.png" alt="正常读取缓存流程"><br><img src="/img/Redis/穿透2.png" alt="缓存中不存在该key直接访问数据库"><br><img src="/img/Redis/穿透3.png" alt="设置布隆过滤器过滤非法key"><br>解决方案：</p><ol><li><p>上线前做好基本的参数校验，⼀些不合法的参数请求直接抛出异常信息返回给客户端。⽐如查询的数据库id不能⼩于0、传⼊的邮箱格式不对的时候直接返回错误消息给客户端等等。</p></li><li><p>请求redis读取缓存前添加布隆过滤器过滤非法的key,布隆过滤器可用判断该数据在数据库中是否存在从而避免非法和不存在的key去访问我们的数据库。下文详细介绍布隆过滤器。</p></li><li><p>设置缓存⽆效 key : 如果缓存和数据库都查不到某个 key 的数据就写⼀个key到 redis 中去并设置过期时间。这种⽅式可以解决请求的 key 变化不频繁的情况，如果⿊客恶意攻击，每次构建不同的请求key，会导致redis中缓存⼤量⽆效的key。很明显，这种⽅案并不能从根本上解决此问题。如果⾮要⽤这种⽅式来解决穿透问题的话，尽量将⽆效的 key的过期时间设置短⼀点⽐如 1 分钟。</p></li></ol><h3 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h3><p>缓存雪崩和缓存穿透都理解的话，缓存击穿可以说是非常简单了。缓存击穿聚焦于热点的key数据，大并发集中对这些点进行访问，当这些热点数据发生过期失效可想而知持续的大并发就穿破缓存，直接请求数据库，就像在一个屏障上凿开了一个洞。举个例子：电商网站上某个商品是爆款，一群用户访问这个商品信息结果这个商品信息的key在缓存中失效了，然后数据库就崩了，大家就都买不成了跑别的解决击穿问题的商城网站去买了。击穿的流程图可看上文缓存穿透流程图中缓存中不存在该key直接访问数据库的流程图。</p><p>解决方案：</p><ol><li><p>业界比较常用的做法，是使用mutex。简单地来说，就是在缓存失效的时候（判断拿出来的值为空），不是立即去load db，而是先使用缓存工具的某些带成功操作返回值的操作（比如Redis的SETNX或者Memcache的ADD）去set一个mutex key，当操作返回成功时，再进行load db的操作并回设缓存；否则，就重试整个get缓存的方法。<br>SETNX，是「SET if Not eXists」的缩写，也就是只有不存在的时候才设置，可以利用它来实现锁的效果。</p></li><li><p>将热点数据的key直接设置过期时间特别长或永不过期自然解决，但注意这中不过期的key数据维护。</p></li></ol><h2 id="布隆过滤器"><a href="#布隆过滤器" class="headerlink" title="布隆过滤器"></a>布隆过滤器</h2><p>布隆过滤器（Bloom Filter）是一个数据结构，由布隆（Burton Howard Bloom）于1970年提出的。它实际上是一个很长的二进制向量和一系列随机映射函数。<br>通俗的讲，布隆过滤器原理是将数据经过多次散列函数(几次取决于你的系统设置中对误差率的要求)将对应的二进制向量下标位置进行变1标注，当数据进入布隆过滤器根据散列函数散列后的下标便可以确认该数据是否存在。可以参考java中hashset判重与hascode()原理。<br>布隆过滤器误差：布隆过滤器不能完美的判断数据是否存在，举个例子说明：假设有个数组长度为8，值默认都是0，布隆过滤器放入2个数后，下标分别为0135、1246的值全变为了1，放入第3个数时，发现这个数经过多次散列函数后该标记的下标分别为0346，由于这些下标全部被标记为1布隆过滤器就会误以为该数已经存在不再更新下标值。</p>]]></content>
      
      
      <categories>
          
          <category> redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis基础认识</title>
      <link href="/2020/09/08/redis%E5%9F%BA%E7%A1%80%E8%AE%A4%E8%AF%86/"/>
      <url>/2020/09/08/redis%E5%9F%BA%E7%A1%80%E8%AE%A4%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Redis属于NOSQL((NoSQL = Not Only SQL )，意即“不仅仅是SQL”。NoSQL 数据库种类繁多(Redis、Mongodb、HBase、Elasticsearch 等等)),NOSQL的特点是去掉关系数据库的关系型特性。数据之间无关系，这样就非常容易扩展。无形之间也在架构的层面上带来了可扩展的能力。NoSQL数据库都具有非常高的读写性能，尤其在大量下数据，更能体现它的优势。这得益于它的无关系性，数据库的结构简单。</p><p>Redis本质上是一个Key-Value类型的内存数据库，很像memcached，整个数据库在内存当中进行操作，定期通过异步操作把数据库数据写到硬盘上进行保存。因为是纯内存操作，Redis的性能非常出色，每秒可以处理超过 10万次读写操作，是已知性能最快的Key- Value DB。 Redis的出色之处不仅仅是性能，Redis最大的魅力是支持保存多种数据结构，此外单个value的最大限制是1GB，不像memcached只能保存1MB的数据，因此Redis可以用来实现很多有用的功能。默认16个数据库，类似数组下标是从零开始，初始默认使用零号库，统一的密码管理，16个库都是同样密码，要么都连上要么一个也连接不上，redis默认端口是6379。</p><p>在 Redis 中，事务总是具有原子性 （Atomicity)、一致性(Consistency)和隔离性（Isolation），并且当 Redis 运行在某种特定的持久化模式下时(快照、文件追加)，事务也具有持久性（Durability）。 </p><p>快照（snapshotting）持久化（RDB） Redis可以通过创建快照来获得存储在内存里面的数据在某个时间点上的副本。Redis创建快照之后，可以对快照进行 备份，可以将快照复制到其他服务器从而创建具有相同数据的服务器副本（Redis主从结构，主要用来提高Redis性 能），还可以将快照留在原地以便重启服务器的时候使用。<br>快照实例配置<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">save 900 1              #在900秒(15分钟)之后，如果至少有1个key发生变化，Redis就会自动触发BGSAVE命令 创建快照。</span><br></pre></td></tr></table></figure></p><p>AOF（append-only ﬁle）持久化 与快照持久化相比，AOF持久化 的实时性更好，因此已成为主流的持久化方案。默认情况下Redis没有开启 AOF（append only ﬁle）方式的持久化，可以通过appendonly参数开启：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">appendonly yes</span><br></pre></td></tr></table></figure><br>开启AOF持久化后每执行一条会更改Redis中的数据的命令，Redis就会将该命令写入硬盘中的AOF文件。AOF文件的 保存位置和RDB文件的位置相同，都是通过dir参数设置的，默认的文件名是appendonly.aof。<br>在Redis的配置文件中存在三种不同的 AOF 持久化方式，它们分别是：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">appendfsync always     <span class="comment">#每次有数据修改发生时都会写入AOF文件,这样会严重降低Redis的速度 </span></span><br><span class="line">appendfsync everysec  <span class="comment">#每秒钟同步一次，显示地将多个写命令同步到硬盘 </span></span><br><span class="line">appendfsync no      <span class="comment">#让操作系统决定何时进行同步</span></span><br></pre></td></tr></table></figure><br>为了兼顾数据和写入性能，用户可以考虑 appendfsync everysec选项 ，让Redis每秒同步一次AOF文件，Redis性能 几乎没受到任何影响。而且这样即使出现系统崩溃，用户多只会丢失一秒之内产生的数据。当硬盘忙于执行写入操 作的时候，Redis还会优雅的放慢自己的速度以便适应硬盘的大写入速度</p><p>redis的优点：<br>速度快：因为数据存在内存中，类似于HashMap，HashMap的优势就是查找和操作的时间复杂度都是O(1) 持久化：定期通过异步操作把数据库数据写到硬盘上进行保存<br>支持丰富数据类型：支持string，list，set，sorted   set，hash<br>支持事务：操作都是原子性，所谓的原子性就是对数据的更改要么全部执行，要么全部不执行丰富的特性：可用于缓存，消息，按key设置过期时间，过期后将会自动删除</p><p>redis支持类型详细：</p><ol><li><p>String<br>常用命令: set,get,decr,incr,mget 等。 String数据结构是简单的key-value类型，value其实不仅可以是String，也可以是数字。 常规key-value缓存应用； 常规计数：微博数，粉丝数等。 </p></li><li><p>Hash<br>常用命令： hget,hset,hgetall 等。<br>Hash 是一个 string 类型的 ﬁeld 和 value 的映射表，hash 特别适合用于存储对象，后续操作的时候，你可以直接仅 仅修改这个对象中的某个字段的值。 比如我们可以Hash数据结构来存储用户信息，商品信息等等。比如下面我就用 hash 类型存放了我本人的一些信息：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">key=JavaUser293847</span><br><span class="line">value=&#123;  </span><br><span class="line">“id”: 1,</span><br><span class="line">“name”: “SnailClimb”,  </span><br><span class="line">“age”: 22,  </span><br><span class="line">“location”: “Wuhan, Hubei”</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li><li><p>List<br>常用命令: lpush,rpush,lpop,rpop,lrange等<br>list 就是链表，Redis list 的应用场景非常多，也是Redis重要的数据结构之一，比如微博的关注列表，粉丝列表， 消息列表等功能都可以用Redis的 list 结构来实现。 Redis list 的实现为一个双向链表，即可以支持反向查找和遍历，更方便操作，不过带来了部分额外的内存开销。<br>另外可以通过 lrange 命令，就是从某个元素开始读取多少个元素，可以基于 list 实现分页查询，这个很棒的一个功能，基于 redis 实现简单的高性能分页，可以做类似微博那种下拉不断分页的东西（一页一页的往下走），性能高。 </p></li><li><p>Set<br>常用命令： sadd,spop,smembers,sunion 等 set 对外提供的功能与list类似是一个列表的功能，特殊之处在于 set 是可以自动排重的。<br>当你需要存储一个列表数据，又不希望出现重复数据时，set是一个很好的选择，并且set提供了判断某个成员是否在 一个set集合内的重要接口，这个也是list所不能提供的。可以基于 set 轻易实现交集、并集、差集的操作。 比如：在微博应用中，可以将一个用户所有的关注人存在一个集合中，将其所有粉丝存在一个集合。Redis可以非常 方便的实现如共同关注、共同粉丝、共同喜好等功能。这个过程也就是求交集的过程。</p></li><li><p>Sorted Set<br>常用命令： zadd,zrange,zrem,zcard等 和set相比，sorted set增加了一个权重参数score，使得集合中的元素能够按score进行有序排列。<br>举例： 在直播系统中，实时排行信息包含直播间在线用户列表，各种礼物排行榜，弹幕消息（可以理解为按消息维 度的消息排行榜）等信息，适合使用 Redis 中的 SortedSet 结构进行存储。</p></li></ol><h2 id="缓存雪崩和缓存穿透问题解决方案"><a href="#缓存雪崩和缓存穿透问题解决方案" class="headerlink" title="缓存雪崩和缓存穿透问题解决方案"></a>缓存雪崩和缓存穿透问题解决方案</h2><p>缓存雪崩<br>简介：缓存同一时间大面积的失效，所以，后面的请求都会落到数据库上，造成数据库短时间内承受大量请求而崩 掉。<br>解决办法（中华石杉老师在他的视频中提到过，视频地址在后一个问题中有提到）：<br>事前：尽量保证整个 redis 集群的高可用性，发现机器宕机尽快补上。选择合适的内存淘汰策略。 事中：本地ehcache缓存 + hystrix限流&amp;降级，避免MySQL崩掉 事后：利用 redis 持久化机制保存的数据尽快恢复缓存</p><p>缓存穿透<br>简介：一般是黑客故意去请求缓存中不存在的数据，导致所有的请求都落到数据库上，造成数据库短时间内承受大量 请求而崩掉。<br>解决办法： 有很多种方法可以有效地解决缓存穿透问题，常见的则是采用布隆过滤器，将所有可能存在的数据哈 希到一个足够大的bitmap中，一个一定不存在的数据会被 这个bitmap拦截掉，从而避免了对底层存储系统的查询压 力。另外也有一个更为简单粗暴的方法，如果一个查询返回的数据为空（不管是数据不存在，还是系统故障），我们仍然把这个空结果进行缓存，但它的过期时间会很短，长不超过五分钟。</p><h2 id="Redis序列化"><a href="#Redis序列化" class="headerlink" title="Redis序列化"></a>Redis序列化</h2><p>针对数据的“序列化/反序列化”，springboot提供了多种可选择策略(RedisSerializer) :<br>JdkSerializationRedisSerializer：这个序列化方法就是Jdk提供的了。首先要求我们要被序列化的类继承自Serializeable<br>接口，然后通过，然后通过Jdk对象序列化的方法保存。（注：这个序列化保存的对象，即使是个String类型的，在redis<br>控制台，也是看不出来的，因为它保存了一些对象的类型什么的额外信息）。是目前最常用的序列化策略。</p><p>StringRedisSerializer：就是通过String.getBytes()来实现的。而且在Redis中，所有存储的值都是字符串类型的。所以这种方法保存后，通过Redis-cli控制台，是可以清楚的查看到我们保存了什么key,value是什么。是最轻量级和高效的策<br>略。</p><p>JacksonJsonRedisSerializer：jackson-json工具提供了javabean与json之间的转换能力，可以将pojo实例序列化成json 格式存储在redis中，也可以将json格式的数据转换成pojo实例。因为jackson工具在序列化和反序列化时，需要明确指定Class类型，因此策略封装起来稍微复杂。</p><p>spring boot导入redis依赖后，spring boot启动后会像spring 注入两个bean:RedisTemplate、StringRedisTemplate,</p><ol><li>两者的关系是StringRedisTemplate继承RedisTemplate。</li><li>RedisTemplate是一个泛型类，而StringRedisTemplate则不是。</li><li>StringRedisTemplate只能对key=String，value=String的键值对进行操作，RedisTemplate可以对任何类型的key-value键值对 操作。</li><li>他们各自序列化的方式不同，但最终都是得到了一个字节数组，殊途同归，StringRedisTemplate使用的是StringRedisSerializer类；RedisTemplate使用的是JdkSerializationRedisSerializer类。反序列化，则是一个得到String，一个得到Object。</li></ol><p>RedisTemplate在操作数据的时候，存入数据会将数据先序列化成字节数组然后在存入Redis数据库(默认JdkSerializationRedisSerializer:这个序列化方法就是Jdk提供的了,首先要求我们要被序列化的类继承自Serializeable接口，然后通过Jdk对象序列化的方法保存)，这个时候打开Redis查看的时候，你会看到你的数据不是以可读的形式，展现的，而是以字节数组显示，<br><img src="/img/Redis/Redis.png" alt="序列化不可读"><br>（注：这个序列化保存的对象，即使是个String类型的，在redis控制台，也是看不出来的，因为它保存了一些对象的类型什么的额外信息）</p><h2 id="Redis最近应用"><a href="#Redis最近应用" class="headerlink" title="Redis最近应用"></a>Redis最近应用</h2><p>个人开发小型JavaWeb程序利用redis存储token,记录获取验证的电话号码今日申请了几次，通过JWT将对象信息转化为String。<br>改造StringRedisTemplate、自定义RedisTemplate的实现类，使得Object对象转化为json使key-vlue再次转化为String-String进行序列化存储。<br>StringRedisSerializer源码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.springframework.data.redis.serializer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.nio.charset.Charset;</span><br><span class="line"><span class="keyword">import</span> java.nio.charset.StandardCharsets; <span class="keyword">import</span> org.springframework.lang.Nullable; <span class="keyword">import</span> org.springframework.util.Assert;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringRedisSerializer</span> <span class="keyword">implements</span> <span class="title">RedisSerializer</span>&lt;<span class="title">String</span>&gt; </span>&#123; <span class="keyword">private</span> <span class="keyword">final</span> Charset charset;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> StringRedisSerializer US_ASCII; <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> StringRedisSerializer ISO_8859_1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> StringRedisSerializer UTF_8;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">StringRedisSerializer</span><span class="params">()</span> </span>&#123; <span class="keyword">this</span>(StandardCharsets.UTF_8);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">StringRedisSerializer</span><span class="params">(Charset charset)</span> </span>&#123; Assert.notNull(charset, <span class="string">"Charset must not be null!"</span>); <span class="keyword">this</span>.charset = charset;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">deserialize</span><span class="params">(@Nullable <span class="keyword">byte</span>[] bytes)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> bytes == <span class="keyword">null</span> ? <span class="keyword">null</span> : <span class="keyword">new</span> String(bytes, <span class="keyword">this</span>.charset);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">byte</span>[] serialize(<span class="meta">@Nullable</span> String string) &#123;</span><br><span class="line"><span class="keyword">return</span> string == <span class="keyword">null</span> ? <span class="keyword">null</span> : string.getBytes(<span class="keyword">this</span>.charset);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">US_ASCII = <span class="keyword">new</span> StringRedisSerializer(StandardCharsets.US_ASCII); ISO_8859_1 = <span class="keyword">new</span> StringRedisSerializer(StandardCharsets.ISO_8859_1); UTF_8 = <span class="keyword">new</span> StringRedisSerializer(StandardCharsets.UTF_8);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>自定义序列化方式使得可以接收Object对象：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.alibaba.fastjson.JSON;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.serializer.RedisSerializer; <span class="keyword">import</span> org.springframework.util.Assert;</span><br><span class="line"><span class="keyword">import</span> java.nio.charset.Charset;</span><br><span class="line"><span class="keyword">import</span> java.nio.charset.StandardCharsets;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*<span class="doctag">@ClassName</span>: MyStringRedisSerializer</span></span><br><span class="line"><span class="comment">*<span class="doctag">TODO:</span>类文件简单描述</span></span><br><span class="line"><span class="comment">*<span class="doctag">@Version</span>: 0.0.1</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyStringRedisSerializer</span> <span class="keyword">implements</span> <span class="title">RedisSerializer</span>&lt;<span class="title">Object</span>&gt; </span>&#123; </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Charset charset;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">MyStringRedisSerializer</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> <span class="keyword">this</span>(StandardCharsets.UTF_8);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">MyStringRedisSerializer</span><span class="params">(Charset charset)</span> </span>&#123; </span><br><span class="line">Assert.notNull(charset, <span class="string">"Charset must not be null!"</span>);</span><br><span class="line"> <span class="keyword">this</span>.charset = charset;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">deserialize</span><span class="params">(<span class="keyword">byte</span>[] bytes)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> (bytes == <span class="keyword">null</span> ? <span class="keyword">null</span> : <span class="keyword">new</span> String(bytes, charset));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//修改部分</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">byte</span>[] serialize(Object object) &#123; </span><br><span class="line"><span class="keyword">if</span> (object == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(object <span class="keyword">instanceof</span> String)&#123;</span><br><span class="line"><span class="keyword">return</span> object.toString().getBytes(charset);</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">String string = JSON.toJSONString(object);</span><br><span class="line"><span class="keyword">return</span> string.getBytes(charset);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>shiro基础认识</title>
      <link href="/2020/09/05/shiro%E5%9F%BA%E7%A1%80%E8%AE%A4%E8%AF%86/"/>
      <url>/2020/09/05/shiro%E5%9F%BA%E7%A1%80%E8%AE%A4%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<h2 id="shiro-简介"><a href="#shiro-简介" class="headerlink" title="shiro 简介"></a>shiro 简介</h2><p>shiro是apache的一个开源框架，而且呢是一个权限管理的框架，用于实现用户认证、用户授权。spring 中也有一个权限框架 spring security (原名Acegi)，它和 spring 依赖过于紧密，没有 shiro 使用简单。shiro 不依赖于 spring，shiro 不仅可以实现 web应用的权限管理，还可以实现c/s系统，分布式系统权限管理，shiro属于轻量框架，越来越多企业项目开始使用shiro。使用shiro实现系统的权限 管理，有效提高开发效率，从而降低开发成本。</p><h2 id="shiro-基本功能点"><a href="#shiro-基本功能点" class="headerlink" title="shiro 基本功能点"></a>shiro 基本功能点</h2><p><img src="/img/shiro/shiro1.png" alt="shiro结构图"><br>subject：主体，可以是用户也可以是程序，主体要访问系统，系统需要对主体进行认证、授权。security Manager：安全管理器，主体进行认证和授权都是通过securityManager进行。authenticator：认证器，主体进行认证最终通过authenticator进行的。               authorizer：授权器，主体进行授权最终通过authorizer进行的。<br>sessionManager：web应用中一般是用web容器对session进行管理，shiro也提供一套session管理的方式。SessionDao： 通过SessionDao管理session数据，针对个性化的session数据存储需要使用sessionDao。<br>cache Manager：缓存管理器，主要对session和授权数据进行缓存，比如将授权数据通过cacheManager进行缓存管理，和ehcache整合对缓存数据进行管理。      Cryptography：加密，保护数据的安全性，如密码加密存储到数据库，而不是明文存储。                                realm：域，领域，相当于数据源，通过realm存取认证、授权相关数据。</p><h2 id="认证流程"><a href="#认证流程" class="headerlink" title="认证流程"></a>认证流程</h2><p><img src="/img/shiro/shiro2.png" alt="shiro认证流程图"></p><ol><li>构建SecurityManager环境</li><li>主体提交认证</li><li>SecurityManager 处理</li><li>流转到 Authenticator 执行认证通过 Realm 获取相关的用户信息（获取验证数据进行验证）</li></ol><h2 id="授权流程"><a href="#授权流程" class="headerlink" title="授权流程"></a>授权流程</h2><p><img src="/img/shiro/shiro2.png" alt="shiro授权流程图"></p><ol><li>创建构建SecurityManager环境</li><li>主体提交授权认证</li><li>SecurityManager 处理</li><li>流转到 Authorizor 授权器执行授权认证</li><li>通过 Realm 从数据库或配置文件获取角色权限数据返回给授权器，进行授权。</li></ol><h2 id="shiro使用流程"><a href="#shiro使用流程" class="headerlink" title="shiro使用流程"></a>shiro使用流程</h2><p>注：适用于基于redis缓存的token验证，redis存储用户角色与权限，获取用户信息（包含角色、权限、登录过期时间、主键id等等）</p><h3 id="自定义配置安全域"><a href="#自定义配置安全域" class="headerlink" title="自定义配置安全域"></a>自定义配置安全域</h3><ol><li>extends AuthorizingRealm </li><li>验证用户名/密码/验证 token 是否有效 </li><li>从数据库获取用户的角色</li><li>根据角色获取用户权限</li></ol><h3 id="shiro核心配置——config"><a href="#shiro核心配置——config" class="headerlink" title="shiro核心配置——config"></a>shiro核心配置——config</h3><ol><li>读reids缓存</li><li>自定义域</li><li>构建 SecurityManager环境</li><li>配置shiro过滤器，配置拦截哪些请求</li><li>开启shiro aop注解支持<br>实例代码：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShiroConfig</span> </span>&#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*自定义密码 校验</span></span><br><span class="line"><span class="comment">*<span class="doctag">@return</span>com.yingxue.lesson.shiro.CustomHashedCredentialsMatcher</span></span><br><span class="line"><span class="comment">*/</span> </span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> CustomHashedCredentialsMatcher <span class="title">customHashedCredentialsMatcher</span><span class="params">()</span></span>&#123;</span><br><span class="line"> <span class="keyword">return</span> <span class="keyword">new</span> CustomHashedCredentialsMatcher();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*自定义域</span></span><br><span class="line"><span class="comment">*<span class="doctag">@return</span>com.yingxue.lesson.shiro.CustomRealm</span></span><br><span class="line"><span class="comment">*<span class="doctag">@throws</span></span></span><br><span class="line"><span class="comment">*/</span> </span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> CustomRealm <span class="title">customRealm</span><span class="params">()</span></span>&#123;</span><br><span class="line">CustomRealm customRealm=<span class="keyword">new</span> CustomRealm(); </span><br><span class="line">customRealm.setCredentialsMatcher(customHashedCredentialsMatcher()); </span><br><span class="line"><span class="keyword">return</span> customRealm;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*安全管理</span></span><br><span class="line"><span class="comment">*<span class="doctag">@return</span>org.apache.shiro.mgt.SecurityManager</span></span><br><span class="line"><span class="comment">*<span class="doctag">@throws</span></span></span><br><span class="line"><span class="comment">*/</span> </span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> SecurityManager <span class="title">securityManager</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//构建 SecurityManager环境</span></span><br><span class="line">DefaultWebSecurityManager securityManager=<span class="keyword">new</span> DefaultWebSecurityManager();</span><br><span class="line"><span class="comment">//自定义 Realm</span></span><br><span class="line">securityManager.setRealm(customRealm()); </span><br><span class="line"><span class="keyword">return</span> securityManager;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*shiro过滤器，配置拦截哪些请求</span></span><br><span class="line"><span class="comment">*<span class="doctag">@param</span> securityManager</span></span><br><span class="line"><span class="comment">*<span class="doctag">@return</span>org.apache.shiro.spring.web.ShiroFilterFactoryBean</span></span><br><span class="line"><span class="comment">*<span class="doctag">@throws</span></span></span><br><span class="line"><span class="comment">*/</span> </span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ShiroFilterFactoryBean <span class="title">shiroFilterFactoryBean</span><span class="params">(SecurityManager securityManager)</span></span>&#123; </span><br><span class="line">ShiroFilterFactoryBean shiroFilterFactoryBean = <span class="keyword">new</span> ShiroFilterFactoryBean(); shiroFilterFactoryBean.setSecurityManager(securityManager);</span><br><span class="line"><span class="comment">//自定义拦截器限制并发人数,参考博客</span></span><br><span class="line">LinkedHashMap&lt;String, Filter&gt; filtersMap = <span class="keyword">new</span> LinkedHashMap&lt;&gt;();</span><br><span class="line"><span class="comment">//用来校验token</span></span><br><span class="line">filtersMap.put(<span class="string">"token"</span>, <span class="keyword">new</span> CustomAccessControlFilter()); shiroFilterFactoryBean.setFilters(filtersMap);</span><br><span class="line">Map&lt;String, String&gt; filterChainDefinitionMap = <span class="keyword">new</span> LinkedHashMap&lt;&gt;(); filterChainDefinitionMap.put(<span class="string">"/api/user/login"</span>, <span class="string">"anon"</span>);</span><br><span class="line"><span class="comment">//放开swagger-ui地址</span></span><br><span class="line">filterChainDefinitionMap.put(<span class="string">"/swagger/**"</span>, <span class="string">"anon"</span>);</span><br><span class="line">filterChainDefinitionMap.put(<span class="string">"/v2/api-docs"</span>, <span class="string">"anon"</span>); </span><br><span class="line">filterChainDefinitionMap.put(<span class="string">"/swagger-ui.html"</span>, <span class="string">"anon"</span>); </span><br><span class="line">filterChainDefinitionMap.put(<span class="string">"/swagger-resources/**"</span>, <span class="string">"anon"</span>); </span><br><span class="line">filterChainDefinitionMap.put(<span class="string">"/webjars/**"</span>, <span class="string">"anon"</span>); </span><br><span class="line">filterChainDefinitionMap.put(<span class="string">"/favicon.ico"</span>, <span class="string">"anon"</span>); </span><br><span class="line">filterChainDefinitionMap.put(<span class="string">"/captcha.jpg"</span>, <span class="string">"anon"</span>); </span><br><span class="line">filterChainDefinitionMap.put(<span class="string">"/csrf"</span>,<span class="string">"anon"</span>); </span><br><span class="line">filterChainDefinitionMap.put(<span class="string">"/**"</span>,<span class="string">"token,authc"</span>); </span><br><span class="line">shiroFilterFactoryBean.setFilterChainDefinitionMap(filterChainDefinitionMap); </span><br><span class="line"><span class="keyword">return</span> shiroFilterFactoryBean;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*开启shiro aop注解支持.</span></span><br><span class="line"><span class="comment">*使用代理方式;所以需要开启代码支持;</span></span><br><span class="line"><span class="comment">*<span class="doctag">@param</span> securityManager</span></span><br><span class="line"><span class="comment">*<span class="doctag">@return</span>org.apache.shiro.spring.security.interceptor.AuthorizationAttributeSourceAdvisor</span></span><br><span class="line"><span class="comment">*<span class="doctag">@throws</span></span></span><br><span class="line"><span class="comment">*/</span> </span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> AuthorizationAttributeSourceAdvisor <span class="title">authorizationAttributeSourceAdvisor</span><span class="params">(SecurityManager securityManager)</span> </span>&#123;</span><br><span class="line">AuthorizationAttributeSourceAdvisor authorizationAttributeSourceAdvisor = <span class="keyword">new</span> AuthorizationAttributeSourceAdvisor();</span><br><span class="line">authorizationAttributeSourceAdvisor.setSecurityManager(securityManager);</span><br><span class="line"><span class="keyword">return</span> authorizationAttributeSourceAdvisor;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Bean</span> </span><br><span class="line"><span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> DefaultAdvisorAutoProxyCreator <span class="title">defaultAdvisorAutoProxyCreator</span><span class="params">()</span> </span>&#123; </span><br><span class="line">DefaultAdvisorAutoProxyCreator defaultAdvisorAutoProxyCreator = newDefaultAdvisorAutoProxyCreator(); </span><br><span class="line">defaultAdvisorAutoProxyCreator.setProxyTargetClass(<span class="keyword">true</span>); </span><br><span class="line"><span class="keyword">return</span> defaultAdvisorAutoProxyCreator;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="shiro注解控制请求调用与前端权限控制可见性"><a href="#shiro注解控制请求调用与前端权限控制可见性" class="headerlink" title="shiro注解控制请求调用与前端权限控制可见性"></a>shiro注解控制请求调用与前端权限控制可见性</h3><p>后端controller层shiro注解使用：<br>实例代码：<br>拥有sys:user:list权限的角色才能调用这个请求<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostMapping</span>(<span class="string">"/users"</span>)</span><br><span class="line"><span class="meta">@ApiOperation</span>(value = <span class="string">"分页查询用户接口"</span>)</span><br><span class="line"><span class="meta">@RequiresPermissions</span>(<span class="string">"sys:user:list"</span>)</span><br><span class="line"><span class="keyword">public</span> DataResult&lt;PageVO&lt;SysUser&gt;&gt; pageInfo(<span class="meta">@RequestBody</span> UserPageReqVO vo)&#123;</span><br><span class="line">    DataResult result=DataResult.success();</span><br><span class="line">    result.setData(userService.pageInfo(vo));</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>前端控制不同角色按钮元素可见性：<br>拥有sys:log:delete权限的角色才能看到使用这个按钮<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=<span class="string">"text/html"</span> id=<span class="string">"toolbar"</span>&gt;</span><br><span class="line">    &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"layui-btn-group"</span>&gt;</span><br><span class="line">        &lt;button type=<span class="string">"button"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"layui-btn"</span> lay-event=<span class="string">"batchDelLog"</span> shiro:hasPermission=<span class="string">"sys:log:delete"</span>&gt;</span><br><span class="line">            &lt;i class="layui-icon"&gt;&amp;#xe608;&lt;/i&gt; 批量删除</span><br><span class="line">        &lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> shiro </category>
          
      </categories>
      
      
        <tags>
            
            <tag> shiro </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java后端使用mysqldump备份数据库</title>
      <link href="/2020/08/24/java%E5%90%8E%E7%AB%AF%E4%BD%BF%E7%94%A8mysqldump%E5%A4%87%E4%BB%BD%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
      <url>/2020/08/24/java%E5%90%8E%E7%AB%AF%E4%BD%BF%E7%94%A8mysqldump%E5%A4%87%E4%BB%BD%E6%95%B0%E6%8D%AE%E5%BA%93/</url>
      
        <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>在接老师开发商业性质的项目的时候，接受了一个前端操作向后端发送请求进行数据库备份文件生成于下载的任务，花费了自己蛮多心血特此记录一下。</p><h2 id="任务要求"><a href="#任务要求" class="headerlink" title="任务要求"></a>任务要求</h2><p>在指定页面以form表单（采用layui框架）显示出相关企业单位的备份信息(备份时间、备份文件名，文件名显示备份完成时间、备份相关内容、备份次数)，同时提供操作栏进行备份下载于删除操作<br><img src="/img/sql/backup.PNG" alt=""></p><h2 id="核心完成方法"><a href="#核心完成方法" class="headerlink" title="核心完成方法"></a>核心完成方法</h2><p>java拼接mysqldump运行指令，并执行，由于数据库冗余较少涉及多次命令拼接与执行耗费较多时间（mysqldump指令在我的查找各种博客和官方文档暂未看到像sql查询语句的in、not in、or关键词字段进行条件判断只得在—where上下功夫）<br>注意：mysqldump数据库备份可导致锁表，对一个正在运行的数据库进行备份请慎重！！ 如果一定要 在服务运行期间备份，请添加 —skip-opt<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqldump --skip-opt -h hostip -u root --password=password DatabaseName &gt;xxxx.sql</span><br></pre></td></tr></table></figure></p><p>废话少说下面是示例代码：<br>path： 备份文件的生成路径地址<br>dateString:转换为yyyyMMddHHmm格式的date字符串<br>ent_id： 主键id(String)<br>userTableName: 所有需要备份的表名字符串(“,”分隔的字符串)<br>user： 备份相关数据库的用户名<br>password： 备份相关数据库的密码<br>hostIP： 数据库IP地址<br>exportDatabaseName： 备份的数据库<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">public void exportSql(String path, String dateString, String ent_id,String userTableName,String user, String password, String hostIP, String exportDatabaseName) &#123;</span><br><span class="line">       String folderName_1 = <span class="string">"ZYK_"</span> + ent_id + <span class="string">"_BackupENT_"</span> + dateString + <span class="string">".sql"</span>;</span><br><span class="line">       File saveFile = new File(path);</span><br><span class="line">       // 如果目录不存在</span><br><span class="line">       <span class="keyword">if</span> (!saveFile.exists()) &#123;</span><br><span class="line">           // 创建文件夹</span><br><span class="line">           saveFile.mkdirs();</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span>(!path.endsWith(File.separator))&#123;</span><br><span class="line">           path = path + File.separator;</span><br><span class="line">       &#125;</span><br><span class="line">       //备份有ent_id字段列的表</span><br><span class="line">       PrintWriter printWriter = null;</span><br><span class="line">       BufferedReader bufferedReader = null;</span><br><span class="line">       try &#123;</span><br><span class="line">           printWriter = new PrintWriter(new OutputStreamWriter(new FileOutputStream(path + folderName_1), <span class="string">"utf8"</span>));</span><br><span class="line">           Process process = Runtime.getRuntime().<span class="built_in">exec</span>(<span class="string">" mysqldump -h"</span> + hostIP + <span class="string">" -u"</span> + user + <span class="string">" -p"</span> + password + <span class="string">" --set-charset=UTF8 "</span> + exportDatabaseName +<span class="string">" --tables "</span>+entTableName+<span class="string">" "</span>+<span class="string">"--where=\"ent_id='"</span>+ ent_id + <span class="string">"'\""</span>);</span><br><span class="line">           InputStreamReader inputStreamReader = new InputStreamReader(process.getInputStream(), <span class="string">"utf8"</span>);</span><br><span class="line">           bufferedReader = new BufferedReader(inputStreamReader);</span><br><span class="line">           String line;</span><br><span class="line">           <span class="keyword">while</span> ((line = bufferedReader.readLine()) != null) &#123;</span><br><span class="line">               printWriter.println(line);</span><br><span class="line">           &#125;</span><br><span class="line">           printWriter.flush();</span><br><span class="line">           <span class="keyword">if</span> (process.waitFor() != 0) &#123;</span><br><span class="line">               throw new CustomException(<span class="string">"线程未正常中止"</span>);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; catch (Exception e) &#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">           throw new CustomException(<span class="string">"备份sql操作失败"</span>);</span><br><span class="line">       &#125; finally &#123;</span><br><span class="line">           try &#123;</span><br><span class="line">               <span class="keyword">if</span> (bufferedReader != null) &#123;</span><br><span class="line">                   bufferedReader.close();</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">if</span> (printWriter != null) &#123;</span><br><span class="line">                   printWriter.close();</span><br><span class="line">               &#125;</span><br><span class="line">           &#125; catch (IOException e) &#123;</span><br><span class="line">               e.printStackTrace();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> mysqldump </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysqldump </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库批量修改语句生成查询语句</title>
      <link href="/2020/08/15/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%89%B9%E9%87%8F%E4%BF%AE%E6%94%B9%E8%AF%AD%E5%8F%A5%E7%94%9F%E6%88%90%E6%9F%A5%E8%AF%A2%E8%AF%AD%E5%8F%A5/"/>
      <url>/2020/08/15/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%89%B9%E9%87%8F%E4%BF%AE%E6%94%B9%E8%AF%AD%E5%8F%A5%E7%94%9F%E6%88%90%E6%9F%A5%E8%AF%A2%E8%AF%AD%E5%8F%A5/</url>
      
        <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>在接老师开发商业性质的项目的时候，接受了一个批量修改数据库的任务，花费了自己蛮多心血特此记录一下。</p><h2 id="任务要求"><a href="#任务要求" class="headerlink" title="任务要求"></a>任务要求</h2><p>任务详情：<br>数据库的表结构不统一，字段列名缺失以及长度不匹配。<br>在现有的数据库中，每张表都有 CREATER，CREATER_ID，CREATE_DATE，UPDATER，UPDATER_ID，UPDATE_DATE等字段，编写一个工具，用于：</p><ol><li>确保一致性：每张表内的这些字段名字，类型，长度都相同</li><li>统一被修改：批量修改这些字段的名字，类型，长度<br><img src="/img/sql/sql工具.PNG" alt=""></li></ol><h2 id="解决思路-amp-方案"><a href="#解决思路-amp-方案" class="headerlink" title="解决思路&amp;方案"></a>解决思路&amp;方案</h2><p>刚开始时想复杂了，脚本学习较少，时间紧迫，于是选择从sql查询语句入手，一直往IF EXISTS钻牛角尖，但批量多表操作的拼接折磨了我很久，后续将问题简单化为将对应数据库没有字段的表添加字段列，再将所有表对应字段列的属性以及长度更新校验更正为任务要求的。</p><p>拼接代码：<br>注意：除CREATER其它字段sql全部省略,下为核心拼接代码<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">START TRANSACTION;</span><br><span class="line">SELECT DISTINCT CONCAT(<span class="string">'ALTER TABLE '</span>,table_name,<span class="string">' ADD COLUMN CREATER VARCHAR(32);'</span>) FROM information_schema.tables WHERE table_schema = DATABASE() AND TABLE_NAME NOT IN (SELECT TABLE_NAME FROM information_schema.columns WHERE table_schema = DATABASE() AND column_name LIKE <span class="string">'CREATER'</span>);</span><br><span class="line"></span><br><span class="line">SELECT CONCAT(<span class="string">'ALTER TABLE '</span>,table_name,<span class="string">' MODIFY  COLUMN CREATER VARCHAR(32);'</span>) from information_schema.`TABLES`WHERE table_schema=<span class="string">'agency_test'</span>;</span><br><span class="line">COMMIT;</span><br></pre></td></tr></table></figure></p><h2 id="sql注意事项"><a href="#sql注意事项" class="headerlink" title="sql注意事项"></a>sql注意事项</h2><p>SQL语句进行列名字段查询时，注意取反编写，不可直接写 column_name not like ‘字段名’，column_name like ‘字段名’逻辑为会选取发现每个表的列名与like的字段进行对比，只要有和对应字段名相同的列名及选出该表，not like会导致只要表中有与like的字段不匹配的表便会选出该表，只要表含多个列名基本便会选出导致与需求不服。</p><h2 id="操作方法"><a href="#操作方法" class="headerlink" title="操作方法"></a>操作方法</h2><ol><li><p>在要修改的数据库新建查询</p></li><li><p>在查询里黏贴sql查询代码生成脚本的内容并运行</p></li><li><p>保存该查询结果为.txt文件（或sql文件）</p></li><li><p>在该文件内容开头另起一行添加  START TRANSACTION;  内容结尾另一起行添加  COMMIT;</p></li><li><p>将该内容黏贴至新的查询（或运行sql文件注意指定运行sql的数据库）</p></li><li><p>注意：sql查询代码生成脚本未指定生成查询的关联数据库，请在需要使用的数据库使用该查询，若想指定对应数据库请将中所有table_schema=DATABASE()修改为table_schema=’指定数据库’</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> SQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库外键与级联的使用考量</title>
      <link href="/2020/08/13/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A4%96%E9%94%AE%E4%B8%8E%E7%BA%A7%E8%81%94%E7%9A%84%E4%BD%BF%E7%94%A8%E8%80%83%E9%87%8F/"/>
      <url>/2020/08/13/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A4%96%E9%94%AE%E4%B8%8E%E7%BA%A7%E8%81%94%E7%9A%84%E4%BD%BF%E7%94%A8%E8%80%83%E9%87%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>在接触了一些企业级项目后发现，项目对应的数据库设计中很少再设计外键和级联（触发器、级联更新与删除）与大学期间的数据库设计课程以及以往的个人小项目的数据库设计相反，当需要用外键做关联的时候，也是仅对字段进行冗余存储。</p><h2 id="开发规范"><a href="#开发规范" class="headerlink" title="开发规范"></a>开发规范</h2><p>在《阿里巴巴java开发手册》中对数据库设置的规范强调————“【强制】不得使用外键与级联，一切外键概念必须在应用层解决。”</p><h2 id="数据库去外键设计"><a href="#数据库去外键设计" class="headerlink" title="数据库去外键设计"></a>数据库去外键设计</h2><p>解决方案：设计关联表。<br>举例：sys_user用户表与sys_role用户角色表需要对应关联时，再建立一个用户与角色的关联表sys_user_role表，该关联表存储sys_user表与sys_role表的主键id等。<br>设计图例：<br><img src="/img/foreignKey.PNG" alt=" run Dashboard"> </p><h2 id="思考与对比"><a href="#思考与对比" class="headerlink" title="思考与对比"></a>思考与对比</h2><p>去外键以及级联的设计，无疑是将数据的关联设置从数据库中剥离出来，在对数据库数据进行修改时，修改成本降低 （修改时不再考虑外键对应表的处理）统一在后端代码中进行关联设置。有外键的数据设计系统在分布式、高并发集群环境下，容易产生更新风暴，以及外键会影响数据库的插入速度。</p><p>个人开发（小型应用）、数据库读写资源充足（数据库并发低），集中式数据库系统，则应该使用外键保障数据的完整性，减少开发端的负担，有利于数据库开发与程序开发的分离。</p><p>团队开发（大型应用）。数据库的读写成为瓶颈（数据库并发高），分布式数据库系统（分割式存储数据），（如阿里巴巴）则应该在项目业务端实现，团队合作开发模块化突出，通过在业务端设置外键可以减小项目开发时有外键带来的各种不便。同时外键的分布式的数据库存储，数据库中表的分割也使得在数据库端实现外键比较复杂，而在业务端通过代码实现则更灵活。</p>]]></content>
      
      
      <categories>
          
          <category> sql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> sql </tag>
            
            <tag> foreign key </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot使用@Async实现异步调用</title>
      <link href="/2020/08/08/SpringBoot%E4%BD%BF%E7%94%A8-Async%E5%AE%9E%E7%8E%B0%E5%BC%82%E6%AD%A5%E8%B0%83%E7%94%A8/"/>
      <url>/2020/08/08/SpringBoot%E4%BD%BF%E7%94%A8-Async%E5%AE%9E%E7%8E%B0%E5%BC%82%E6%AD%A5%E8%B0%83%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>在写项目时，有个需求为前端使用用户下载数据库备份压缩文件，其中涉及多表多条件dump备份</p><h2 id="部分代码"><a href="#部分代码" class="headerlink" title="部分代码"></a>部分代码</h2><p>类似方法有4个，未异步调用耗时较长影响用户体验。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">entIdSqlDumpOne</span><span class="params">(String path, String dateString, String ent_id,String entTableName,String user, String password, String hostIP, String exportDatabaseName)</span></span>&#123;</span><br><span class="line">    String folderName_1 = <span class="string">"ZYK_"</span> + ent_id + <span class="string">"_BackupENT_"</span> + dateString + <span class="string">".sql"</span>;</span><br><span class="line">    PrintWriter printWriter = <span class="keyword">null</span>;</span><br><span class="line">    BufferedReader bufferedReader = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//Lock lock = new ReentrantLock();</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//lock.lock();</span></span><br><span class="line">        printWriter = <span class="keyword">new</span> PrintWriter(<span class="keyword">new</span> OutputStreamWriter(<span class="keyword">new</span> FileOutputStream(path + folderName_1), <span class="string">"utf8"</span>));</span><br><span class="line">        Process process = Runtime.getRuntime().exec(<span class="string">" mysqldump -h"</span> + hostIP + <span class="string">" -u"</span> + user + <span class="string">" -p"</span> + password + <span class="string">" --set-charset=UTF8 "</span> + exportDatabaseName +<span class="string">" --tables "</span>+entTableName+<span class="string">" "</span>+<span class="string">"--where=\"ent_id='"</span>+ ent_id + <span class="string">"'\""</span>);</span><br><span class="line">        InputStreamReader inputStreamReader = <span class="keyword">new</span> InputStreamReader(process.getInputStream(), <span class="string">"utf8"</span>);</span><br><span class="line">        bufferedReader = <span class="keyword">new</span> BufferedReader(inputStreamReader);</span><br><span class="line">        String line;</span><br><span class="line">        <span class="keyword">while</span> ((line = bufferedReader.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            printWriter.println(line);</span><br><span class="line">        &#125;</span><br><span class="line">        printWriter.flush();</span><br><span class="line">        <span class="keyword">if</span> (process.waitFor() != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> CustomException(<span class="string">"线程未正常中止"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> CustomException(<span class="string">"备份sql操作失败"</span>);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (bufferedReader != <span class="keyword">null</span>) &#123;</span><br><span class="line">                bufferedReader.close();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (printWriter != <span class="keyword">null</span>) &#123;</span><br><span class="line">                printWriter.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="设置异步调用"><a href="#设置异步调用" class="headerlink" title="设置异步调用"></a>设置异步调用</h2><h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><ol><li><p>springboot application类中配置@EnableAsync</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span> </span><br><span class="line"><span class="meta">@EnableAsync</span> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringbootAsyncApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;        </span><br><span class="line"> SpringApplication.run(SpringbootAsyncApplication<span class="class">.<span class="keyword">class</span>, <span class="title">args</span>)</span>;    </span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在需要异步调用的方法头加@Async注解</p></li><li><p>异步调用备份方法</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testTask</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line"><span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">        Future&lt;String&gt; task1 = myTask.entIdSqlDumpOne();</span><br><span class="line">        Future&lt;String&gt; task2 = myTask.entIdSqlDumpTwo();</span><br><span class="line">        Future&lt;String&gt; task3 = myTask.entIdSqlDumpThree();</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(task1.isDone() &amp;&amp; task2.isDone() &amp;&amp; task3.isDone()) &#123;</span><br><span class="line">                <span class="comment">// 三个任务都调用完成，退出循环等待，无法调度完成抛出异常</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">           &#125;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">       &#125;</span><br><span class="line"><span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 异步调用 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 异步调用 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前后端分离整体项目docker部署</title>
      <link href="/2020/07/25/%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB%E6%95%B4%E4%BD%93%E9%A1%B9%E7%9B%AEdocker%E9%83%A8%E7%BD%B2/"/>
      <url>/2020/07/25/%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB%E6%95%B4%E4%BD%93%E9%A1%B9%E7%9B%AEdocker%E9%83%A8%E7%BD%B2/</url>
      
        <content type="html"><![CDATA[<h2 id="背景介绍"><a href="#背景介绍" class="headerlink" title="背景介绍"></a>背景介绍</h2><p>前后端分离项目涉及vue、nginx与含dockerFile的jar包部署，使用docker一次性部署vue、nginx、jar、mysql。</p><h2 id="操作流程"><a href="#操作流程" class="headerlink" title="操作流程"></a>操作流程</h2><h3 id="安装-amp-启动docker"><a href="#安装-amp-启动docker" class="headerlink" title="安装&amp;启动docker"></a>安装&amp;启动docker</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">yum install docker</span><br><span class="line"></span><br><span class="line">systemctl start docker</span><br></pre></td></tr></table></figure><h3 id="安装nginx"><a href="#安装nginx" class="headerlink" title="安装nginx"></a>安装nginx</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//查看镜像</span><br><span class="line">docker images</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#使用nginx镜像来创建nginx容器实例并运行</span></span><br><span class="line">docker run --name nginx-test -p 80:80 -d nginx</span><br></pre></td></tr></table></figure><p>run 创建容器实例</p><p>— name 容器命名</p><p>-v 映射目录</p><p>-d 设置容器后台运行</p><p>-p 本机端口映射 将容器的80端口映射到本机的80端口</p><h4 id="将nginx关键目录映射到本机"><a href="#将nginx关键目录映射到本机" class="headerlink" title="将nginx关键目录映射到本机"></a>将nginx关键目录映射到本机</h4><p>在本机创建nginx的一些文件存储目录<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p /root/nginx/www /root/nginx/logs /root/nginx/conf</span><br></pre></td></tr></table></figure></p><p>查看nginx-test容器id(containerId)<br>根据id将nginx-test容器配置文件copy到本地<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker ps -a</span><br><span class="line"></span><br><span class="line">docker cp <span class="string">"containerId"</span>:/etc/nginx/nginx.conf /root/nginx/conf</span><br></pre></td></tr></table></figure></p><p>创建新nginx容器nginx-web,并将www,logs,conf目录映射到本地<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p 80:80 --name nginx-web -v &#x2F;root&#x2F;nginx&#x2F;www:&#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html -v &#x2F;root&#x2F;nginx&#x2F;conf&#x2F;nginx.conf:&#x2F;etc&#x2F;nginx&#x2F;nginx.conf -v &#x2F;root&#x2F;nginx&#x2F;logs:&#x2F;var&#x2F;log&#x2F;nginx nginx</span><br></pre></td></tr></table></figure><br>www: nginx存储网站网页的目录</p><p>logs: nginx日志目录</p><p>conf: nginx配置文件目录</p><p>启动nginx<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker start nginx-web</span><br></pre></td></tr></table></figure></p><h4 id="设置反向代理"><a href="#设置反向代理" class="headerlink" title="设置反向代理"></a>设置反向代理</h4><p>进入到/root/conf/nginx.conf vim指令修改即可<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">server&#123;</span><br><span class="line">   listen 80;</span><br><span class="line">   charset utf-8;</span><br><span class="line">   server_name ip地址(xxx.xxx.xxx.xxx);</span><br><span class="line"> </span><br><span class="line">   location / &#123;</span><br><span class="line">      proxy_pass http://ip地址:8080;</span><br><span class="line">      proxy_redirect default;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="部署vue项目"><a href="#部署vue项目" class="headerlink" title="部署vue项目"></a>部署vue项目</h3><p>cd vue项目 ls查看是否有dist与dockerfile 2个文件</p><p>dockerfile内容：<br>作用：指定镜像、将dist文件放到nginx的项目地址路径<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">FROM nginx:latest</span><br><span class="line">MAINTAINER xx</span><br><span class="line">COPY dist/ /usr/share/nginx/html/</span><br></pre></td></tr></table></figure></p><p>dist文件生成：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm run build</span><br></pre></td></tr></table></figure></p><p>当前目录部署镜像<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -t vueproject .</span><br></pre></td></tr></table></figure></p><h3 id="部署mysql"><a href="#部署mysql" class="headerlink" title="部署mysql"></a>部署mysql</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 下载镜像</span></span><br><span class="line">docker pull mysql</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看镜像</span></span><br><span class="line">docker images|grep mysql</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动容器镜像，建议在/usr/local/workspace/mysql  下执行以下docker  run  命令</span></span><br><span class="line">docker run -p 13306:3306 --name my-mysql -v <span class="variable">$PWD</span>/conf:/etc/mysql -v <span class="variable">$PWD</span>/data:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=123456 -d mysql:5.7.26</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 建议写死路径,-v挂载路径使即使容器停止运行数据依旧存在</span></span><br><span class="line">docker run -p 13306:3306 --name my-mysql -v /usr/<span class="built_in">local</span>/workspace/mysql/conf:/etc/mysql -v /usr/<span class="built_in">local</span>/workspace/mysql/data:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=root -d mysql</span><br></pre></td></tr></table></figure><h3 id="部署java-web项目"><a href="#部署java-web项目" class="headerlink" title="部署java web项目"></a>部署java web项目</h3><p>编写dockerfile文件<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">FROM openjdk:11-jre-alpine</span><br><span class="line">ADD statistics_examine.jar app.jar</span><br><span class="line">ENTRYPOINT [<span class="string">"java"</span>,<span class="string">"-jar"</span>,<span class="string">"app.jar"</span>]</span><br></pre></td></tr></table></figure></p><p>构建镜像&amp;运行容器<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker build -t spring-hello .</span><br><span class="line"></span><br><span class="line">docker run --name hello-backend -d -p 8000:8080 spring-hello</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>大三实训记录——thymeleaf传值给外联js文件</title>
      <link href="/2020/06/25/%E5%A4%A7%E4%B8%89%E5%AE%9E%E8%AE%AD%E8%AE%B0%E5%BD%95%E2%80%94%E2%80%94thymeleaf%E4%BC%A0%E5%80%BC%E7%BB%99%E5%A4%96%E8%81%94js%E6%96%87%E4%BB%B6/"/>
      <url>/2020/06/25/%E5%A4%A7%E4%B8%89%E5%AE%9E%E8%AE%AD%E8%AE%B0%E5%BD%95%E2%80%94%E2%80%94thymeleaf%E4%BC%A0%E5%80%BC%E7%BB%99%E5%A4%96%E8%81%94js%E6%96%87%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<h2 id="实训"><a href="#实训" class="headerlink" title="实训"></a>实训</h2><p>最近大三下半学期刚刚结束，打算用实训记录类标题记录一下自己实训开发中遇到的一些问题。这次实训由京东互联网科技实践中心的老师授课并且给与我们开发小组达到毕设水平的评价，不知后续参加工作后看大学中开发的项目会有一些什么样的感受。项目后续上传到github上，个人负责建筑平台用户操作系统开发，管理员与评审专家由其他组员开发。</p><h2 id="实训问题——thymeleaf传值给外联js文件"><a href="#实训问题——thymeleaf传值给外联js文件" class="headerlink" title="实训问题——thymeleaf传值给外联js文件"></a>实训问题——thymeleaf传值给外联js文件</h2><p>这次实训中后端业务逻辑、架构、数据库操作没有太大阻力，由于个人前端技术较差，主要问题集中于前端模板与后端的交互。这篇文介绍外联js传值问题。<br>当使用前端模板时想使用如下图的动态显示数据问题时需要解决如何后端向js文件传值，这次实训项目未前后端分离采用thymeleaf模板引擎。<br><img src="/img/design20/countJs.PNG" alt="前端js动态显示数据"> </p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>解决思路：后端传值给html页面，html页面设立全局变量赋值接收，js调用含有该变量的function()方法。<br>项目实例见下方代码：<br>html页面<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;script th:inline=<span class="string">"javascript"</span> <span class="built_in">type</span>=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line">           //&lt;![CDATA[</span><br><span class="line">          var countUser = [[<span class="variable">$&#123;userNumber&#125;</span>]];</span><br><span class="line">          var countExpert = [[<span class="variable">$&#123;expertNumber&#125;</span>]];</span><br><span class="line">          var countProject = [[<span class="variable">$&#123;projectNumber&#125;</span>]];</span><br><span class="line">          var countPrize = [[<span class="variable">$&#123;prizeNumber&#125;</span>]];</span><br><span class="line">          //通过参数传递</span><br><span class="line">          countUp(countUser);</span><br><span class="line">          countUp2(countExpert);</span><br><span class="line">          countUp3(countProject);</span><br><span class="line">          countUp4(countPrize);</span><br><span class="line"></span><br><span class="line">           //]]&gt;</span><br><span class="line">      &lt;/script&gt;</span><br><span class="line">      &lt;script src=<span class="string">"/js/count.js"</span> <span class="built_in">type</span>=<span class="string">"text/javascript"</span> /&gt;&lt;/script&gt;&lt;/section&gt;</span><br></pre></td></tr></table></figure><br>js页面<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> countUp(count)</span><br><span class="line">&#123;</span><br><span class="line">    var div_by = 100,</span><br><span class="line">        speed = Math.round(count / div_by),</span><br><span class="line">        <span class="variable">$display</span> = $(<span class="string">'.count'</span>),</span><br><span class="line">        run_count = 1,</span><br><span class="line">        int_speed = 24;</span><br><span class="line"></span><br><span class="line">    var int = setInterval(<span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">        <span class="keyword">if</span>(run_count &lt; div_by)&#123;</span><br><span class="line">            <span class="variable">$display</span>.text(speed * run_count);</span><br><span class="line">            run_count++;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(parseInt(<span class="variable">$display</span>.text()) &lt; count) &#123;</span><br><span class="line">            var curr_count = parseInt(<span class="variable">$display</span>.text()) + 1;</span><br><span class="line">            <span class="variable">$display</span>.text(curr_count);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            clearInterval(int);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, int_speed);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">countUp(countUser);</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> thymeleaf </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js </tag>
            
            <tag> thymeleaf </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>idea配置run Dashboard</title>
      <link href="/2020/06/20/idea%E9%85%8D%E7%BD%AErun%20Dashboard/"/>
      <url>/2020/06/20/idea%E9%85%8D%E7%BD%AErun%20Dashboard/</url>
      
        <content type="html"><![CDATA[<h2 id="run-Dashboard功能"><a href="#run-Dashboard功能" class="headerlink" title="run Dashboard功能"></a>run Dashboard功能</h2><p>如下图所示run Dashboard面板可以管理多个服务、modules，对微服务项目以及多modules项目运行和管理十分方便，但idea在运行中不是默认就有run Dashboard的面板<br><img src="/img/design20/Dashboard.PNG" alt=" run Dashboard"> </p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>1.点击多个模块服务启动时的idea右下角弹窗<br><img src="/img/design20/Dashboard-1.PNG" alt=" run Dashboard"><br>2.edit configurations配置，步骤如下图：<br><img src="/img/design20/Dashboard-4.PNG" alt=" run Dashboard"><br><img src="/img/design20/Dashboard-2.PNG" alt=" run Dashboard"><br><img src="/img/design20/Dashboard-3.PNG" alt=" run Dashboard"> </p>]]></content>
      
      
      <categories>
          
          <category> idea </category>
          
      </categories>
      
      
        <tags>
            
            <tag> idea </tag>
            
            <tag> run Dashboard </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>大三实训记录——springboot2.0后版本配置虚拟路径以访问本地图片</title>
      <link href="/2020/06/20/%E5%A4%A7%E4%B8%89%E5%AE%9E%E8%AE%AD%E8%AE%B0%E5%BD%95%E2%80%94%E2%80%94springboot2-0%E5%90%8E%E7%89%88%E6%9C%AC%E9%85%8D%E7%BD%AE%E8%99%9A%E6%8B%9F%E8%B7%AF%E5%BE%84%E4%BB%A5%E8%AE%BF%E9%97%AE%E6%9C%AC%E5%9C%B0%E5%9B%BE%E7%89%87/"/>
      <url>/2020/06/20/%E5%A4%A7%E4%B8%89%E5%AE%9E%E8%AE%AD%E8%AE%B0%E5%BD%95%E2%80%94%E2%80%94springboot2-0%E5%90%8E%E7%89%88%E6%9C%AC%E9%85%8D%E7%BD%AE%E8%99%9A%E6%8B%9F%E8%B7%AF%E5%BE%84%E4%BB%A5%E8%AE%BF%E9%97%AE%E6%9C%AC%E5%9C%B0%E5%9B%BE%E7%89%87/</url>
      
        <content type="html"><![CDATA[<h2 id="实训"><a href="#实训" class="headerlink" title="实训"></a>实训</h2><p>最近大三下半学期刚刚结束，打算用实训记录类标题记录一下自己实训开发中遇到的一些问题。这次实训由京东互联网科技实践中心的老师授课并且给与我们开发小组达到毕设水平的评价，不知后续参加工作后看大学中开发的项目会有一些什么样的感受。项目后续上传到github上，个人负责建筑奖项参评平台用户操作系统开发，管理员与评审专家系统由其他组员开发。</p><h2 id="实训问题——thymeleaf传值给外联js文件"><a href="#实训问题——thymeleaf传值给外联js文件" class="headerlink" title="实训问题——thymeleaf传值给外联js文件"></a>实训问题——thymeleaf传值给外联js文件</h2><p>这次实训中后端业务逻辑、架构、数据库操作没有太大阻力，由于个人前端技术较差，主要问题集中于前端模板与后端的交互。这篇文介绍虚拟路径映射问题，在项目需求分析中为满足用户操作平台中用户账号上传、更换头像并实时显示的问题，springboot开发须配置使用虚拟路径映射完成功能。<br><img src="/img/design20/images.PNG" alt="虚拟路径映射"> </p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>解决思路：@Configuration定义配置类，继承WebMvcConfigurationSupport类配置虚拟路径。<br>项目实例见下方代码：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class UploadConfiguration extends WebMvcConfigurationSupport  &#123;</span><br><span class="line">    @Override</span><br><span class="line">    protected void addResourceHandlers(ResourceHandlerRegistry registry) &#123;</span><br><span class="line">        registry.addResourceHandler(<span class="string">"/upload/**"</span>)//这个是虚拟路径图片路径</span><br><span class="line">                .addResourceLocations(<span class="string">"file:E:/upload/img/"</span>);//这个是图片真实路径</span><br><span class="line">        super.addResourceHandlers(registry);</span><br><span class="line">        registry.addResourceHandler(<span class="string">"/**"</span>).addResourceLocations(<span class="string">"classpath:/static/"</span>);//项目内的图片去static下找</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 虚拟路径 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> springboot </tag>
            
            <tag> 虚拟路径 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Druid的sql数据监控没有数据</title>
      <link href="/2020/04/30/Druid%E7%9A%84sql%E6%95%B0%E6%8D%AE%E7%9B%91%E6%8E%A7%E6%B2%A1%E6%9C%89%E6%95%B0%E6%8D%AE/"/>
      <url>/2020/04/30/Druid%E7%9A%84sql%E6%95%B0%E6%8D%AE%E7%9B%91%E6%8E%A7%E6%B2%A1%E6%9C%89%E6%95%B0%E6%8D%AE/</url>
      
        <content type="html"><![CDATA[<h2 id="Druid无sql数据监控"><a href="#Druid无sql数据监控" class="headerlink" title="Druid无sql数据监控"></a>Druid无sql数据监控</h2><p>在使用springboot集成Druid数据源时遇到了一直监控不到sql数据问题<br>问题情形如下：<br><img src="/img/Druid/druid1.PNG" alt=""><br><img src="/img/Druid/druid2.PNG" alt=""><br><img src="/img/Druid/druid3.PNG" alt=""><br>可以发现filter类名下为空，查看配置问题</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>可能原因：<br>(1)config下的filter方法没添加@Bean<br>(2)filters没配置</p><p>(1)的解决方案不做赘述。<br>(2)的解决方案：<br>打开resources目录下配置文件添加配置<br>.yml格式：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  datasource:</span><br><span class="line">    username: xxxx</span><br><span class="line">    password: xxxx</span><br><span class="line">    url: jdbc:mysql://localhost:3306/mybatis?serverTimezone=UTC&amp;useUnicode=<span class="literal">true</span>&amp;characterEncoding=utf-8</span><br><span class="line">    driver-class-name: com.mysql.cj.jdbc.Driver</span><br><span class="line">    <span class="built_in">type</span>: com.alibaba.druid.pool.DruidDataSource</span><br><span class="line">    filters: <span class="built_in">stat</span></span><br></pre></td></tr></table></figure><br>.properties:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">spring.datasource.druid.driver-class-name=com.mysql.cj.jdbc.Driver</span><br><span class="line">spring.datasource.druid.url=jdbc:mysql://localhost:3306/mybatis?serverTimezone=UTC&amp;useUnicode=<span class="literal">true</span>&amp;characterEncoding=utf-8</span><br><span class="line">spring.datasource.druid.username=xxxx</span><br><span class="line">spring.datasource.druid.password=xxxx</span><br><span class="line">spring.datasource.druid.filters=<span class="built_in">stat</span></span><br></pre></td></tr></table></figure><br>解决后截图：<br><img src="/img/Druid/druid4.PNG" alt=""><br><img src="/img/Druid/druid5.PNG" alt="">    </p>]]></content>
      
      
      <categories>
          
          <category> Druid </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Druid </tag>
            
            <tag> alibaba.druid </tag>
            
            <tag> springboot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IDEA旗舰版学生党如何获得免费的个人许可证</title>
      <link href="/2020/04/21/IDEA%E6%97%97%E8%88%B0%E7%89%88%E5%AD%A6%E7%94%9F%E5%85%9A%E5%A6%82%E4%BD%95%E8%8E%B7%E5%BE%97%E5%85%8D%E8%B4%B9%E7%9A%84%E4%B8%AA%E4%BA%BA%E8%AE%B8%E5%8F%AF%E8%AF%81-1/"/>
      <url>/2020/04/21/IDEA%E6%97%97%E8%88%B0%E7%89%88%E5%AD%A6%E7%94%9F%E5%85%9A%E5%A6%82%E4%BD%95%E8%8E%B7%E5%BE%97%E5%85%8D%E8%B4%B9%E7%9A%84%E4%B8%AA%E4%BA%BA%E8%AE%B8%E5%8F%AF%E8%AF%81-1/</url>
      
        <content type="html"><![CDATA[<h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>版本：<code>Ultimate</code> | <code>Community Edition</code><br>        旗舰版    社区版本<br>为什么我要使用旗舰版的IDEA？请看官方比较：<a href="https://www.jetbrains.com/idea/features/editions_comparison_matrix.html" target="_blank" rel="noopener">https://www.jetbrains.com/idea/features/editions_comparison_matrix.html</a><br>旗舰版还支持HTML，CSS，PHP，SQL，Python等语言，并且支持更多的服务端框架和前端框架例如：Spring、Spring Cloud、Java EE、Micronaut, Quarkus, Helidon、Grails、Node.js、Django等，还有服务器部署例如：Tomcat、TomEE、JBoss, WildFly、GlassFish、Resin等，而社区版只支持Docker。相对于社区版本，旗舰版还有更多的分析工具，因此我选择旗舰版IDEA，如果学生教师想要使用旗舰版的IDEA又不想官方购买怎么办？下面我教大家获取免费的个人许可证。</p><h2 id="1-到学信网申请在线认证报告"><a href="#1-到学信网申请在线认证报告" class="headerlink" title=".1.到学信网申请在线认证报告"></a>.1.到学信网申请在线认证报告</h2><p><a href="https://www.chsi.com.cn/" target="_blank" rel="noopener">https://www.chsi.com.cn/</a> 进入后用自己身份证登录，点击<code>学籍查询</code>，进入后点击<code>在线验证报告</code>下方的<code>申请</code>，点击教育部学籍<code>在线验证报告</code>下的<code>查看</code>：然后申请就好，申请完后点击<code>查看</code>，即可看到本人的学籍信息页面，接着点击<code>PDF下载</code>，然后复制当前网址放在记事本以备后面所需。<br><img src="/img/idea/idea_1.jpg" alt=""><br><img src="/img/idea/idea_2.jpg" alt=""><br><img src="/img/idea/idea_3.jpg" alt=""><br><img src="/img/idea/idea_4.jpg" alt=""><br><img src="/img/idea/idea_5.jpg" alt=""></p><h2 id="2-到JetBrains官网进行学生认证"><a href="#2-到JetBrains官网进行学生认证" class="headerlink" title=".2.到JetBrains官网进行学生认证"></a>.2.到JetBrains官网进行学生认证</h2><p><a href="https://www.jetbrains.com/shop/eform/students" target="_blank" rel="noopener">https://www.jetbrains.com/shop/eform/students</a><br>进入后如下图对照填写：<br>官方文件即为刚下载的pdf文件。证明你与你的学术机构有隶属的正式文件链接就写刚复制的，就是学信网认证后的那个页面地址。填写完后点击申请，时间为人工审核4-7天并以填写的邮件地址给你回复。</p><p><img src="/img/idea/idea_6.jpg" alt=""><br><img src="/img/idea/idea_7.jpg" alt=""></p><h2 id="3-成功收到审核成功的通知"><a href="#3-成功收到审核成功的通知" class="headerlink" title=".3.成功收到审核成功的通知"></a>.3.成功收到审核成功的通知</h2><p>jetbrains官方审核成功后会给你的来信如下图，你需要点击<code>link your free license</code>，然后下方<code>Create JetBrains Account</code>创建一个账号密码，输入你的邮箱，点击<code>Sign Up</code>注册jetbrains官方账号，进去后填写密码及可绑定该许可证。<br>至此就免费的获得了个人许可证，下载IDEA开始你的代码之旅吧。<br><img src="/img/idea/idea_8.jpg" alt=""><br><img src="/img/idea/idea_9.jpg" alt=""><br><img src="/img/idea/idea_10.jpg" alt=""></p><p>本文为转载<br>IDEA旗舰版学生党如何获得免费的个人许可证由<a href="https://yoyling.com/author/1/" target="_blank" rel="noopener">YOYLING.</a>创作,点击作者名称进入作者主页。</p>]]></content>
      
      
      <categories>
          
          <category> IDEA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IDEA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jdk11新特性</title>
      <link href="/2020/04/21/jdk11%E6%96%B0%E7%89%B9%E6%80%A7/"/>
      <url>/2020/04/21/jdk11%E6%96%B0%E7%89%B9%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<p>这日子过着过着jdk14都发布了，刚起步用jdk11的我瑟瑟发抖，打算记录一下。<br><img src="/img/jdk14.PNG" alt=""></p><h2 id="Java11-vs-Java8"><a href="#Java11-vs-Java8" class="headerlink" title="Java11 vs Java8"></a>Java11 vs Java8</h2><p><img src="/img/jdk11/jdk11_1.jpg" alt=""><br>Java 11相对于Java 8确实有一部分进化，除了有很多内部的升级（比如开销和时延更低的<br>GC、TLS1.3加持等等）之外，对于初学使用者来说也有一些语言使用层面的进化。<br>正好最近我在自己的个人小项目上尝试升级使用了一下 Java11（公司项目咱也不敢动、也不<br>敢问，只好动自己的个人项目），因此本文从实际代码编写角度来大致体验一下我个人使用<br>Java11之后相对 Java8所感觉到的一些比较深刻的进化，官方文档里说得也非常清楚了：<br><a href="https://docs.oracle.com/en/java/javase/11/" target="_blank" rel="noopener">https://docs.oracle.com/en/java/javase/11/</a><br>我这次实验装的 Java11版本是 11.0.6：<br><img src="/img/jdk11/jdk11_2.jpg" alt=""><br>下文将要实验验证的一些新特性其实也并非 147 Java11才引入，很多其实在 Java9和 Java10时<br>就已经引入，只不过到了 Java11这个稳定版才沉淀下来。</p><h2 id="变量类型推断"><a href="#变量类型推断" class="headerlink" title="变量类型推断"></a>变量类型推断</h2><p>新版Java引入了一个全新的类型关键字 var，用 var来定义的变量不用写具体类型，编译器能<br>根据 =右边的实际赋值来自动推断出变量的类型：<br>1、普通局部变量<br><img src="/img/jdk11/jdk11_3.jpg" alt=""><br>怎么样？是不是有一种在使用类似JavaScript这种弱类型语言的错觉？</p><p>2、for循环中使用<br><img src="/img/jdk11/jdk11_4.jpg" alt=""></p><p>这地方就能看出用 var定义局部变量的优势了，假如这个例子中集合里的元素类型更为复杂，<br>是类似 List<List<String>&gt;这种嵌套类型的话， var定义就非常简洁明了！</p><p>3、当然，有些情况是不能使用的<br>var类型变量一旦赋值后，重新赋不同类型的值是不行的，比如：<br><img src="/img/jdk11/jdk11_5.jpg" alt=""></p><p>定义 var类型变量没有初始化是不行的，比如：<br><img src="/img/jdk11/jdk11_6.jpg" alt=""><br>另外，像类的 成员变量类型、 方法入参类型、 返回值类型等是不能使用 var的，比如：<br><img src="/img/jdk11/jdk11_7.jpg" alt=""></p><h2 id="官方HTTP-Client加持"><a href="#官方HTTP-Client加持" class="headerlink" title="官方HTTP Client加持"></a>官方HTTP Client加持</h2><p>是的！<br>现在 JDK官方就自带 HTTPClient了，位于 java.net.http包下，支持发送同步、异步的 HTTP请<br>求，这样一来，以前咱们常用的HTTP请求客户端诸如： OKHttp、 HttpClient这种现在都可以<br>退下了！<br>发送同步请求：<br><img src="/img/jdk11/jdk11_8.jpg" alt=""><br>发送异步请求：<br><img src="/img/jdk11/jdk11_9.jpg" alt=""><br>当然你也可以自定义请求头，比如携带 JWT Token权限信息去请求等：<br><img src="/img/jdk11/jdk11_10.jpg" alt=""></p><h2 id="String处理增强"><a href="#String处理增强" class="headerlink" title="String处理增强"></a>String处理增强</h2><p>新版字符串 String类型增加了诸如： isBlank()、 strip()、 repeat()等方便的字符串处理方<br>法<br><img src="/img/jdk11/jdk11_11.jpg" alt=""></p><h2 id="集合增强"><a href="#集合增强" class="headerlink" title="集合增强"></a>集合增强</h2><p>主要是增加了诸如 of()和 copyOf()等方法用于更加方便的创建和复制集合类型<br><img src="/img/jdk11/jdk11_12.jpg" alt=""></p><h2 id="函数式编程增强"><a href="#函数式编程增强" class="headerlink" title="函数式编程增强"></a>函数式编程增强</h2><p>我印象最深的是对 Stream流增加了诸如 takeWhile()和 dropWhile()的截止结算方法：<br><img src="/img/jdk11/jdk11_13.jpg" alt=""></p><h2 id="文件读写增强"><a href="#文件读写增强" class="headerlink" title="文件读写增强"></a>文件读写增强</h2><h3 id="1、Files类增强"><a href="#1、Files类增强" class="headerlink" title="1、Files类增强"></a>1、Files类增强</h3><p>我们以前心心念的直接能把文件内容读取到 String以及 String回写到文件的功能终于支持了,<br>可以通过 Files类的静态方法 writeString()和 readString()完成：<br><img src="/img/jdk11/jdk11_14.jpg" alt=""></p><h3 id="2、InputStream增强"><a href="#2、InputStream增强" class="headerlink" title="2、InputStream增强"></a>2、InputStream增强</h3><p>InputStream则增加了一个 transferTo()方法，直接将数据丢到 OutputStream去：<br><img src="/img/jdk11/jdk11_15.jpg" alt=""></p><h2 id="支持源文件直接运行-666！"><a href="#支持源文件直接运行-666！" class="headerlink" title="支持源文件直接运行(666！)"></a>支持源文件直接运行(666！)</h2><p>比如写一个最简单的 Hello World程序：<br><img src="/img/jdk11/jdk11_16.jpg" alt=""><br>并保存为 hello.java文件，这时候可以直接用 java指令去运行这个Java源文件，直接省去以<br>前 javac编译源文件的过程：<br><img src="/img/jdk11/jdk11_17.jpg" alt=""><br><img src="/img/jdk11/jdk11_18.jpg" alt=""><br>怎么样？是不是和python源文件的运行有点像？这个信息量就有点大了，大家可以自行脑补<br>一下</p><h2 id="小-结"><a href="#小-结" class="headerlink" title="小 结"></a>小 结</h2><p>Java 11确有很多改进，但还是那句话，对于初学者来说Java 8足够啦，没必要刻意求新，稳<br>才是最重要的！</p><p>转载的原文地址：<a href="https://www.bilibili.com/read/cv5037646" target="_blank" rel="noopener">https://www.bilibili.com/read/cv5037646</a></p>]]></content>
      
      
      <categories>
          
          <category> jdk </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jdk </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jdk12新特性</title>
      <link href="/2020/04/21/jdk12%E6%96%B0%E7%89%B9%E6%80%A7/"/>
      <url>/2020/04/21/jdk12%E6%96%B0%E7%89%B9%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<p>这日子过着过着jdk14都发布了，刚起步用jdk11的我瑟瑟发抖，打算记录一下。<br><img src="/img/jdk14.PNG" alt="官网"></p><h2 id="低暂停延时的垃圾收集器-实验版"><a href="#低暂停延时的垃圾收集器-实验版" class="headerlink" title="低暂停延时的垃圾收集器 (实验版)"></a>低暂停延时的垃圾收集器 (实验版)</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A Low-Pause-Time Garbage Collector (Experimental)</span><br></pre></td></tr></table></figure><p>添加一个名为 Shenandoah的新垃圾收集 (GC)算法，该算法通过与正在运行的 Java线程并发执行回收工作来减少 GC暂停时间。Shenandoah的暂停时间与堆大小无关，这意味着无论堆大小是 200MB 还是 200GB，都将拥有相同的暂停时间。</p><h2 id="微基准测试套件"><a href="#微基准测试套件" class="headerlink" title="微基准测试套件"></a>微基准测试套件</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Microbenchmark Suite</span><br></pre></td></tr></table></figure><p>在 JDK源代码中添加了一组基本的微基准测试套件，使得开发人员无论运行现有的微基准测试或者创建新的微基准测试都变得十分便利。</p><h2 id="Switch-表达式-预览版"><a href="#Switch-表达式-预览版" class="headerlink" title="Switch 表达式 (预览版)"></a>Switch 表达式 (预览版)</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Switch Expressions (Preview)</span><br></pre></td></tr></table></figure><p>这是一个预览版语言特性。通过对 switch语法进行了扩展，使其不仅可以作为语句（statement），还可以作为表达式（expression），并且两种形式都可以使用“传统的”或“简化的”语法用于作用于不同的范围或者控制执行流。这些更改将会简化日常编码，并且为在 switch中使用模式匹配 (JEP 305) 做好了准备。</p><h2 id="JVM-常量API"><a href="#JVM-常量API" class="headerlink" title="JVM 常量API"></a>JVM 常量API</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">JVM Constants API</span><br></pre></td></tr></table></figure><p>引入一个API来建模关键类文件（key class-file）和运行时构件（run-time artifacts）的标称描述，特别是对那些可从常量池加载的常量。</p><h2 id="仅保留-AArch64-实现"><a href="#仅保留-AArch64-实现" class="headerlink" title="仅保留 AArch64 实现"></a>仅保留 AArch64 实现</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">One AArch64 Port, Not Two</span><br></pre></td></tr></table></figure><p>删除与 arm64实现相关的所有源代码，同时保留 32-bit ARM和 64-bit aarch64实现。删除这些实现是为了让所有代码贡献者集中精力于一个实现上，从而消除维护两个实现所需付出的重复工作。</p><h2 id="默认类数据共享归档文件"><a href="#默认类数据共享归档文件" class="headerlink" title="默认类数据共享归档文件"></a>默认类数据共享归档文件</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Default CDS Archives</span><br></pre></td></tr></table></figure><p>增强 JDK构建过程，在 64位平台上使用默认的类列表生成类数据共享(class data-sharing，CDS)存档。</p><h2 id="可中断的-G1-Mixed-GC"><a href="#可中断的-G1-Mixed-GC" class="headerlink" title="可中断的 G1 Mixed GC"></a>可中断的 G1 Mixed GC</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Abortable Mixed Collections for G1</span><br></pre></td></tr></table></figure><p>如果 Mixed GC 的 G1 存在超出暂停目标的可能性，则使其可被中止。</p><h2 id="G1未使用分配内存即时返回"><a href="#G1未使用分配内存即时返回" class="headerlink" title="G1未使用分配内存即时返回"></a>G1未使用分配内存即时返回</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Promptly Return Unused Committed Memory from G1</span><br></pre></td></tr></table></figure><p>增强 G1垃圾收集器，以便在空闲时自动将 Java 堆内存返回给操作系统。</p>]]></content>
      
      
      <categories>
          
          <category> jdk </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jdk </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IDEA 2020、Java14升级体验</title>
      <link href="/2020/04/21/IDEA%202020%E5%8D%87%E7%BA%A7%E4%BD%93%E9%AA%8CJava14/"/>
      <url>/2020/04/21/IDEA%202020%E5%8D%87%E7%BA%A7%E4%BD%93%E9%AA%8CJava14/</url>
      
        <content type="html"><![CDATA[<h2 id="IntelliJ-IDEA2020"><a href="#IntelliJ-IDEA2020" class="headerlink" title="IntelliJ IDEA2020"></a>IntelliJ IDEA2020</h2><p>就在前几天，Java软件开发神器 IDEA 2020.1 新版发布了：<br><img src="/img/IDEA2020/IDEA2020_1.jpg" alt=""><br>我第一时间在机子上更新并体验了几天，感觉还是有点香的！怎么硕呢，体验完新特性之后，不由的感叹一句：IDEA现在真的是越来越智能，越来越懂开发者了。</p><h2 id="UI-界面升级"><a href="#UI-界面升级" class="headerlink" title="UI/界面升级"></a>UI/界面升级</h2><h3 id="1、界面支持中文了"><a href="#1、界面支持中文了" class="headerlink" title="1、界面支持中文了"></a>1、界面支持中文了</h3><p>汉化后的效果就是这个样子：<br><img src="/img/IDEA2020/IDEA2020_2.jpg" alt=""><br>各花入各眼，好坏就不做评判了，可以根据自己的喜好来调节。</p><p>必须要说的是，这个中文汉化不是软件原生支持，而是需要下载安装一个名为<code>Chinese (Simplified) Language Pack</code>的插件，好在这个插件就是<code>JetBrains</code>官方提供的<br><img src="/img/IDEA2020/IDEA2020_3.jpg" alt=""></p><h3 id="2、导航栏进化"><a href="#2、导航栏进化" class="headerlink" title="2、导航栏进化"></a>2、导航栏进化</h3><p>现在代码层级导航栏这里，可以直接定位到文件中的某个具体方法或者字段了，这个的确很高效<br><img src="/img/IDEA2020/IDEA2020_4.jpg" alt=""></p><h3 id="3、支持编辑器内的Javadocs渲染"><a href="#3、支持编辑器内的Javadocs渲染" class="headerlink" title="3、支持编辑器内的Javadocs渲染"></a>3、支持编辑器内的<code>Javadocs</code>渲染</h3><p><img src="/img/IDEA2020/IDEA2020_5.jpg" alt=""><br>渲染后的<code>Javadoc</code>就非常直观易读了，而且还可以调整字号<br><img src="/img/IDEA2020/IDEA2020_6.jpg" alt=""></p><h3 id="4、新增主题和字体"><a href="#4、新增主题和字体" class="headerlink" title="4、新增主题和字体"></a>4、新增主题和字体</h3><p>首先默认支持了JetBrains自家的新JetBrains<br><img src="/img/IDEA2020/IDEA2020_7.jpg" alt=""><br>然后则是采用了统一的<code>IntelliJ Light</code>主题，而且该主题已经在不同的操作系统中完全统一了<br><img src="/img/IDEA2020/IDEA2020_8.jpg" alt=""><br><img src="/img/IDEA2020/IDEA2020_9.jpg" alt=""><br>喜不喜欢看大家个人习惯了</p><h3 id="5、船新的LightEdit模式"><a href="#5、船新的LightEdit模式" class="headerlink" title="5、船新的LightEdit模式"></a>5、船新的LightEdit模式</h3><p><code>LightEdit</code>，顾名思义，轻量级的代码编辑。</p><p>是的，这次更新的IDEA支持打开单个代码文件进行编辑，而无需打开整个项目。文件可以在单独的编辑窗口打开，而且该窗口可以和其他（项目）窗口共存。就像这样：<br><img src="/img/IDEA2020/IDEA2020_10.jpg" alt=""><br>更强大的是，直接支持快捷打开这个单文件所在的完整项目：<br><img src="/img/IDEA2020/IDEA2020_11.jpg" alt=""><br>甚至还可以通过命令行来打开单文件，这相当可以了：<br><img src="/img/IDEA2020/IDEA2020_12.jpg" alt=""></p><h3 id="6、支持“禅”模式"><a href="#6、支持“禅”模式" class="headerlink" title="6、支持“禅”模式"></a>6、支持“禅”模式</h3><p>现在的这个代码展示模式有够丰富了，支持四种了：<br><img src="/img/IDEA2020/IDEA2020_13.jpg" alt=""><br>当然，禅模式是最彻底的，一开这个模式，整个世界都清净了…<br><img src="/img/IDEA2020/IDEA2020_14.jpg" alt=""></p><h3 id="7、终端支持分栏了"><a href="#7、终端支持分栏了" class="headerlink" title="7、终端支持分栏了"></a>7、终端支持分栏了</h3><p>现在可以随意地将IDEA自带的终端进行横竖分栏，非常方便<br><img src="/img/IDEA2020/IDEA2020_15.jpg" alt=""></p><h2 id="支持直接IDEA里安装JDK和Git"><a href="#支持直接IDEA里安装JDK和Git" class="headerlink" title="支持直接IDEA里安装JDK和Git"></a>支持直接IDEA里安装JDK和Git</h2><p>很多小伙伴交流说自己JDK环境好像装的有问题，实验各种出问题。为了这个事，强迫症都快犯了，很烦。</p><p>从IntelliJ IDEA 2020.1开始，我们可以直接在创建项目时，直接从IDEA上下载并设置JDK环境，很方便了。</p><p>我特地实验了一下，在IDEA里面下载安装了个Open JDK 14，没毛病，好用，切换也很方便。<br><img src="/img/IDEA2020/IDEA2020_16.jpg" alt=""><br><img src="/img/IDEA2020/IDEA2020_17.jpg" alt=""><br>除此之外，IDEA还直接支持Git的安装，i了i了<br><img src="/img/IDEA2020/IDEA2020_18.jpg" alt=""></p><h2 id="支持Java-14新特性"><a href="#支持Java-14新特性" class="headerlink" title="支持Java 14新特性"></a>支持Java 14新特性</h2><p>前段时间Java 14发布，加入了一些新特性，这次IDEA 2020.1迅速跟进，支持了Java 14的一些新特性，举两个典型的例子。</p><h3 id="1、instanceof用法增强"><a href="#1、instanceof用法增强" class="headerlink" title="1、instanceof用法增强"></a>1、<code>instanceof</code>用法增强</h3><p>老的Java版本中，对于instanceof语法，我们一般都是这样用的：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">private void <span class="built_in">test</span>( Object obj ) &#123;</span><br><span class="line">    <span class="keyword">if</span>( obj instanceof String  ) &#123;</span><br><span class="line">        String str = (String) obj;  // 需手动强制转换！</span><br><span class="line">        System.out.println( str.isEmpty() );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>而Java 14对<code>instanceof</code>用法做了增强，我们借助全新的IDEA 2020，可以快捷的将上面的代码自动重构成如下所示：<br><img src="/img/IDEA2020/IDEA2020_19.jpg" alt=""><br>所以最终变成了这个亚子：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">private void <span class="built_in">test</span>( Object obj ) &#123;</span><br><span class="line">    <span class="keyword">if</span>( obj instanceof String str ) &#123; // 校验通过，直接后面定义变量，无需强转！</span><br><span class="line">        System.out.println( str.isEmpty() );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="2、record新语法支持"><a href="#2、record新语法支持" class="headerlink" title="2、record新语法支持"></a>2、record新语法支持</h3><p>Java 14新增了record新语法，record的词面意思就是 “记录”，主要用于形式化的固定记录，这在以前主要就是通过 不可变类来实现的，举个例子吧。</p><p>比如我们定义一个不可变的日志记录类LogRecord，里面包含日志ID（id），日志时间（date），日志详情（detail），按照老的做法，只能使用class进行定义：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">public final class LogRecord &#123; // 不可变类</span><br><span class="line"></span><br><span class="line">    private final int id;</span><br><span class="line">    private final LocalDate date;</span><br><span class="line">    private final String detail;</span><br><span class="line"></span><br><span class="line">    public LogRecord(int id, LocalDate date, String detail) &#123;</span><br><span class="line">        this.id = id;</span><br><span class="line">        this.date = date;</span><br><span class="line">        this.detail = detail;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public int <span class="function"><span class="title">getId</span></span>() &#123;</span><br><span class="line">        <span class="built_in">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public LocalDate <span class="function"><span class="title">getDate</span></span>() &#123;</span><br><span class="line">        <span class="built_in">return</span> date;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String <span class="function"><span class="title">getDetail</span></span>() &#123;</span><br><span class="line">        <span class="built_in">return</span> detail;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String <span class="function"><span class="title">toString</span></span>() &#123;</span><br><span class="line">        <span class="built_in">return</span> <span class="string">"LogRecord&#123;"</span> +</span><br><span class="line">                <span class="string">"id="</span> + id +</span><br><span class="line">                <span class="string">", date="</span> + date +</span><br><span class="line">                <span class="string">", detail='"</span> + detail + <span class="string">'\'</span><span class="string">' +</span></span><br><span class="line"><span class="string">                '</span>&#125;<span class="string">';</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    @Override</span></span><br><span class="line"><span class="string">    public boolean equals(Object o) &#123;</span></span><br><span class="line"><span class="string">        if (this == o) return true;</span></span><br><span class="line"><span class="string">        if (o == null || getClass() != o.getClass()) return false;</span></span><br><span class="line"><span class="string">        LogRecord logRecord = (LogRecord) o;</span></span><br><span class="line"><span class="string">        return id == logRecord.id &amp;&amp;</span></span><br><span class="line"><span class="string">                Objects.equals(date, logRecord.date) &amp;&amp;</span></span><br><span class="line"><span class="string">                Objects.equals(detail, logRecord.detail);</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    @Override</span></span><br><span class="line"><span class="string">    public int hashCode() &#123;</span></span><br><span class="line"><span class="string">        return Objects.hash(id, date, detail);</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><br>Java 14认为上面这种final类型class的定义的套路是完全固定的，写了很多固定套路的代码，包括：构造函数、Getter方法、toString()方法、hashCode() 和 equals()方法等等，十分无聊。</p><p>为此Java 14推出了全新的record语法，只需一行代码即可搞定，十分方便：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">record LogRecord( int id, LocalDate date, String detail ) &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>这次IDEA 2020中就已经完全支持recod语法了，并且还可以自动显式地为record生成各种方法：<br><img src="/img/IDEA2020/IDEA2020_20.jpg" alt=""></p><h2 id="支持更加智能的检查和重构"><a href="#支持更加智能的检查和重构" class="headerlink" title="支持更加智能的检查和重构"></a>支持更加智能的检查和重构</h2><h3 id="1、支持就地更改方法签名"><a href="#1、支持就地更改方法签名" class="headerlink" title="1、支持就地更改方法签名"></a>1、支持就地更改方法签名</h3><p>什么意思呢？举个例子。</p><p>当你想直接修改某个已有方法的参数时，不管三七二十一，上来可以直接修改方法签名，然后点击更新，接下来的所有步骤IDEA可以帮你完成。<br><img src="/img/IDEA2020/IDEA2020_21.jpg" alt=""><br><img src="/img/IDEA2020/IDEA2020_22.jpg" alt=""><br><img src="/img/IDEA2020/IDEA2020_23.jpg" alt=""><br><img src="/img/IDEA2020/IDEA2020_24.jpg" alt=""></p><p>2、智能分析日期字符串格式</p><p>比如这个例子中，我格式化一个日期时，无意将年月日<code>yyyy/MM/dd</code>字符串写成了<code>yyyy/mm/dd</code>，中间的<code>MM</code>大小写忘了，IDEA自动给我们分析出来了：<br><img src="/img/IDEA2020/IDEA2020_25.jpg" alt=""></p><p>3、智能语法和拼写检查器</p><p>这个功能得配合<code>Grazie</code>这个插件一起使用，该插件是一个全面的语法、拼写、以及样式检查工具。</p><p>比如，这地方我小手一抖，写错了英语语法，它立马帮我们提示出来了<br><img src="/img/IDEA2020/IDEA2020_26.jpg" alt=""></p><h2 id="增强调试功能"><a href="#增强调试功能" class="headerlink" title="增强调试功能"></a>增强调试功能</h2><h3 id="1、数据流分析辅助，可以直接预测下面的运行结果"><a href="#1、数据流分析辅助，可以直接预测下面的运行结果" class="headerlink" title="1、数据流分析辅助，可以直接预测下面的运行结果"></a>1、数据流分析辅助，可以直接预测下面的运行结果</h3><p>IDEA 2020.1直接将数据流分析添加到JVM调试器。当程序在断点处停止时，IDEA可以根据程序的当前状态运行数据流分析，来预测下一步将要发生什么。<br><img src="/img/IDEA2020/IDEA2020_27.jpg" alt=""></p><h3 id="2、调试时，支持固定对象字段"><a href="#2、调试时，支持固定对象字段" class="headerlink" title="2、调试时，支持固定对象字段"></a>2、调试时，支持固定对象字段</h3><p>当一个对象字段过多，以致于调试时很难找到需要的字段时，我们可以直接将其置顶，便于查看。<br><img src="/img/IDEA2020/IDEA2020_28.jpg" alt=""></p><h3 id="3、以文件形式存储运行配置"><a href="#3、以文件形式存储运行配置" class="headerlink" title="3、以文件形式存储运行配置"></a>3、以文件形式存储运行配置</h3><p>新版IDEA支持直接将当前的调试/运行的配置存档，并在以后选择重新加载<br><img src="/img/IDEA2020/IDEA2020_29.jpg" alt=""></p><h2 id="更加先进的版本控制"><a href="#更加先进的版本控制" class="headerlink" title="更加先进的版本控制"></a>更加先进的版本控制</h2><p>第一个大的改进就是重新设计了代码提交的窗口，而不再是以前老的那种模态化弹窗式窗口了。这样一来，提交代码时的代码比对，编辑会更加舒适。<br><img src="/img/IDEA2020/IDEA2020_30.jpg" alt=""></p><p>第二个改进就是支持搜索、刷新本地以及远端的代码分支：<br><img src="/img/IDEA2020/IDEA2020_31.jpg" alt=""><br>另外，这个历史日志留痕也是蛮好看的：<br><img src="/img/IDEA2020/IDEA2020_32.jpg" alt=""></p><h2 id="Maven和Gradle导入更新"><a href="#Maven和Gradle导入更新" class="headerlink" title="Maven和Gradle导入更新"></a>Maven和Gradle导入更新</h2><p>此处就以Maven工具为例，编辑器右上角出现的是一个浮动通知。修改构建文件后，可以使用这个迷你的通知图标来加载更改<br><img src="/img/IDEA2020/IDEA2020_33.jpg" alt=""></p><h2 id="数据库处理增强"><a href="#数据库处理增强" class="headerlink" title="数据库处理增强"></a>数据库处理增强</h2><p>新版IDEA内置的数据库管理，现在可以支持将数据导出到Excel（.xlsx）文件，并且直接在编辑器中以文本形式查看<br><img src="/img/IDEA2020/IDEA2020_34.jpg" alt=""></p><h2 id="增强的HTTP-Client"><a href="#增强的HTTP-Client" class="headerlink" title="增强的HTTP Client"></a>增强的HTTP Client</h2><p>升级之后的<code>HTTP Client</code>更加智能，典型的比如：支持自动匹配和补全<br><img src="/img/IDEA2020/IDEA2020_35.jpg" alt=""><br>而且还可以在<code>Contoller</code>代码的左侧，通过快捷的方式来自动生成HTTP请求文件<br><img src="/img/IDEA2020/IDEA2020_36.jpg" alt=""><br>而且对于Spring项目，还可以在底部的<code>Endpoints</code>窗口里来快捷生成HTTP请求文件。<br><img src="/img/IDEA2020/IDEA2020_37.jpg" alt=""></p><h2 id="其他改进"><a href="#其他改进" class="headerlink" title="其他改进"></a>其他改进</h2><p>1、对各种框架的支持改进，比如：<code>Spring WebFlux/Selenium/JMS/Micronaut/RxJava</code>等等</p><p>2、对<code>Docker/Kubernetes</code>的支持改进</p><p>3、对<code>Scala 3</code>的支持</p><p>4、对<code>Android Volley</code>的支持</p><p>5、对<code>JavaScript</code>的改进和支持</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>体验一番之后发现，新版的IDEA 2020.1肉眼可见的改进还是非常多的，挺香。</p><p>不过还有一个实际的问题就是：我一升级之后发现一大票的插件都不能用了，所以周边支持的兼容性还得再等等。</p><p>本文为授权转载<br>IDEA2020新版本体验文章及视频来自个人非常喜欢的、富有经验的b站up主：<a href="https://space.bilibili.com/384068749" target="_blank" rel="noopener">程序羊</a>，<a href="https://www.codesheep.cn/" target="_blank" rel="noopener">羊哥个人博客地址</a>。<br>原文地址：<a href="https://mp.weixin.qq.com/s/Ua4TYlcNntLr-x9WQirHyg" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/Ua4TYlcNntLr-x9WQirHyg</a> 视频地址：<a href="https://www.bilibili.com/video/BV1MT4y1V76k" target="_blank" rel="noopener">https://www.bilibili.com/video/BV1MT4y1V76k</a><br>注意：部分组件周边可能还不兼容。</p>]]></content>
      
      
      <categories>
          
          <category> IDEA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IDEA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>centos安装nginx并配置SSL证书</title>
      <link href="/2020/04/05/centos%E5%AE%89%E8%A3%85nginx%E5%B9%B6%E9%85%8D%E7%BD%AESSL%E8%AF%81%E4%B9%A6/"/>
      <url>/2020/04/05/centos%E5%AE%89%E8%A3%85nginx%E5%B9%B6%E9%85%8D%E7%BD%AESSL%E8%AF%81%E4%B9%A6/</url>
      
        <content type="html"><![CDATA[<h2 id="安装nginx的命令"><a href="#安装nginx的命令" class="headerlink" title="安装nginx的命令"></a>安装nginx的命令</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install epel-release</span><br><span class="line">sudo yum install nginx</span><br></pre></td></tr></table></figure><h2 id="让nginx随系统启动而启动"><a href="#让nginx随系统启动而启动" class="headerlink" title="让nginx随系统启动而启动"></a>让nginx随系统启动而启动</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl <span class="built_in">enable</span> nginx</span><br></pre></td></tr></table></figure><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">启动：nginx</span><br><span class="line">停止：nginx -s stop</span><br><span class="line">重载配置：nginx -s reload</span><br></pre></td></tr></table></figure><h2 id="配置SSL证书"><a href="#配置SSL证书" class="headerlink" title="配置SSL证书"></a>配置SSL证书</h2><p>配置路径：/etc/nginx/<br>日志路径：/var/log/nginx<br>打开配置文件<br>在HTTP节点下配置两个server节点，其他不变<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">server </span><br><span class="line">&#123;</span><br><span class="line">listen 443;</span><br><span class="line">server_name your-domain.com www.your-domain.com;</span><br><span class="line">ssl on;</span><br><span class="line">ssl_certificate  /root/ssl/your-domain.crt;</span><br><span class="line">ssl_certificate_key /root/ssl/your-domain.key;</span><br><span class="line">ssl_session_timeout 5m;</span><br><span class="line">ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4;</span><br><span class="line">ssl_protocols TLSv1 TLSv1.1 TLSv1.2;</span><br><span class="line">ssl_prefer_server_ciphers on;</span><br><span class="line">location / &#123;</span><br><span class="line">proxy_buffer_size  128k;</span><br><span class="line">proxy_buffers   32 32k;</span><br><span class="line">proxy_busy_buffers_size 128k;</span><br><span class="line">proxy_pass http://127.0.0.1:912;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">server</span><br><span class="line">&#123;</span><br><span class="line">listen 80;</span><br><span class="line">server_name your-domain.com www.your-domain.com;</span><br><span class="line">   rewrite ^(.*)$ https://<span class="variable">$host</span><span class="variable">$1</span> permanent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>配置注意：</p><ul><li>your-domain.com替换成你自己的域名</li><li>your-domain.crt和your-domain.key是你的证书文件，换成你自己的证书文件路径(从购买域名地址下载)</li><li>域名解析，增加两个A记录，主机名一个是www的，一个是@，记录值是你服务器的IP地址,详细步骤可以看我的博文-hexo博客</li><li>配置完成之后要重新加载nginx：nginx -s reload</li></ul>]]></content>
      
      
      <categories>
          
          <category> centos </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nginx </tag>
            
            <tag> centos </tag>
            
            <tag> SSL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>六边形架构认识</title>
      <link href="/2020/03/01/%E5%85%AD%E8%BE%B9%E5%BD%A2%E6%9E%B6%E6%9E%84/"/>
      <url>/2020/03/01/%E5%85%AD%E8%BE%B9%E5%BD%A2%E6%9E%B6%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<h2 id="六边形架构简介"><a href="#六边形架构简介" class="headerlink" title="六边形架构简介"></a>六边形架构简介</h2><p>六边形架构由Alistair Cockburn于2005年提出，相较于传统三层架构方式的缺点————不支持多客户端、不支持多数据库、领域层依赖持久层，六边形架构实现了业务逻辑以一种松耦合的形式与多个外部系统通过“适配器-端口”的形式进行集成。某种意义上六边形架构也是一种分层架构，将架构分为了内部和外部但没有了层的概念。六边形架构也称为端口与适配器，在领域驱动设计（DDD）和微服务架构中都出现了六边形架构的身影。</p><h2 id="六边形架构结构"><a href="#六边形架构结构" class="headerlink" title="六边形架构结构"></a>六边形架构结构</h2><p>六边形架构的六边并不重要，六边只是为了留足空间放置端口和适配器以及用六边形接入多个外部系统视觉上最简洁美观。六边形架构创造者AlistairCockburn最初以六边形来表示这种架构后沿用至今。六边形架构的主要特点是多个适配器和端口形成的划分为内部、外部的架构模式。业务逻辑层可以接入所有满足端口需求的表示层(应用前端、页面)与持久层(数据库)。这种情形可以类比理解java中接口与接口的实现类，所有有满足接口所有方法的类都可以实现接口。<br><img src="/img/六边形架构.png" alt="六边形架构alt"><br>上图六边形架构结构图，其中黑箭头为调用关系，白箭头为实现关系。右侧Message为相关消息机制，多用于微服务架构中多个微服务(六边形架构)之间通信，本文不做太多讨论。<br>由上图可以发现六边形架构的内部(业务逻辑)与外部(APP,WEB,数据库等)完全隔离，只通过adapter适配器进行交互实现了业务逻辑层与持久层的完全解耦，更一步实现“高内聚低耦合”</p><h2 id="各部分解读"><a href="#各部分解读" class="headerlink" title="各部分解读"></a>各部分解读</h2><ul><li><p>输入端口：<br>用于系统提供服务时暴露API接口，接受外部（前端UI界面、其它微服务）的输入。系统作为服务提供者是对外的接入层可以看成是输入端口。</p></li><li><p>输出端口：<br>为系统获取外部服务提供支持，如获取持久化状态、对结果进行持久化(要求对数据库增删改查操作的接口)。</p></li><li><p>业务逻辑：<br>系统服务的实体类，微服务设计中根据用例、服务复杂程度将大项目(服务)划分为多个小团队可处理的小服务重要参照。</p></li></ul><h2 id="软件开发设计"><a href="#软件开发设计" class="headerlink" title="软件开发设计"></a>软件开发设计</h2><p>规范化六边形架构可以如下图所示<br>其中adapter包下为入站、出站适配器，application包下为入站、出站端口其中BookApplicationService为入站端口BookUaseCase接口的实现类，domin包下为业务逻辑层book为实体类。adapter包下JpaBookRepository接口为出站端口BookRepository接口的继承并具备接口的默认实现方法(jdk8特性)。<br><img src="/img/六边形架构开发实例.PNG" alt="六边形架构开发实例"></p>]]></content>
      
      
      <categories>
          
          <category> 架构模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 架构模式 </tag>
            
            <tag> 六边形架构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker容器运行前后端分离简单实例</title>
      <link href="/2020/02/25/docker%E5%AE%B9%E5%99%A8%E8%BF%90%E8%A1%8C%E7%AE%80%E5%8D%95%E5%89%8D%E5%90%8E%E7%AB%AF%E7%BB%93%E5%90%88%E5%AE%9E%E4%BE%8B/"/>
      <url>/2020/02/25/docker%E5%AE%B9%E5%99%A8%E8%BF%90%E8%A1%8C%E7%AE%80%E5%8D%95%E5%89%8D%E5%90%8E%E7%AB%AF%E7%BB%93%E5%90%88%E5%AE%9E%E4%BE%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h2><h3 id="Docker简介"><a href="#Docker简介" class="headerlink" title="Docker简介"></a>Docker简介</h3><p>Docker是一种运行于Linux和Windows上的软件，用于创建、管理和编排容器。Docker是在GitHub上开发的Moby开源项目的一部分。<a href="https://docs.docker.com/" target="_blank" rel="noopener">Docker官方文档</a> <a href="http://www.docker.org.cn/page/resources.html" target="_blank" rel="noopener">Docker中文社区</a>(ps:别忘配置加速器Docker图标》Settings》Docker Engine)</p><h2 id="后端代码"><a href="#后端代码" class="headerlink" title="后端代码"></a>后端代码</h2><p>springboot项目，非常简单的演示后端，注解代码实现获取/hello/路径后的string类型数据。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">package iteach.docker.service.spring.docker;</span><br><span class="line"></span><br><span class="line">import org.springframework.boot.SpringApplication;</span><br><span class="line">import org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line">import org.springframework.web.bind.annotation.CrossOrigin;</span><br><span class="line">import org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line">import org.springframework.web.bind.annotation.PathVariable;</span><br><span class="line">import org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line">@RestController</span><br><span class="line">@SpringBootApplication</span><br><span class="line">public class SpringHelloApplication &#123;</span><br><span class="line"></span><br><span class="line">    @CrossOrigin</span><br><span class="line">    @GetMapping(<span class="string">"/hello/&#123;name&#125;"</span>)</span><br><span class="line">    public String hello(@PathVariable String name) &#123;</span><br><span class="line">        <span class="built_in">return</span> String.format(<span class="string">"Hello,%s!"</span>, name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        SpringApplication.run(SpringHelloApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="Docker与后端应用"><a href="#Docker与后端应用" class="headerlink" title="Docker与后端应用"></a>Docker与后端应用</h2><h3 id="Docker创建后端镜像"><a href="#Docker创建后端镜像" class="headerlink" title="Docker创建后端镜像"></a>Docker创建后端镜像</h3><p>1、将后端项目打成jar包，可以在命令行工具（这里使用的是powershell）进入到jar包生成路径运行java -jar .\jar包名.jar\检验jar包是否能运行<br>2、新建一个文件夹，文件夹下放置jar包和新建一个名为Dockerfile的文件不可改名。<br>3、Dockerfile内容,可以将jdk改为jre这样安装的镜像更小更快<br><img src="/img/backend.png" alt="运行结果"><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">FROM openjdk:11</span><br><span class="line">ADD spring-hello.jar app.jar</span><br><span class="line">ENTRYPOINT [<span class="string">"java"</span>,<span class="string">"-jar"</span>,<span class="string">"app.jar"</span>]</span><br></pre></td></tr></table></figure><br>4、命令行工具在该目录下输入(文章最后总结解释各个指令作用)<br>拉取镜像(在放置Dockerfile文件处执行)<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -t spring-hello .</span><br></pre></td></tr></table></figure></p><h3 id="Docker创建容器并运行"><a href="#Docker创建容器并运行" class="headerlink" title="Docker创建容器并运行"></a>Docker创建容器并运行</h3><p>命令行工具输入，创建容器运行<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --name hello-backend -d -p 8000:8080 spring-hello</span><br></pre></td></tr></table></figure><br>获取运行结果<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Invoke-RestMethod http://localhost:8000/hello/xz</span><br></pre></td></tr></table></figure><br><img src="/img/backend2.png" alt="运行结果">  </p><h2 id="前端代码"><a href="#前端代码" class="headerlink" title="前端代码"></a>前端代码</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">&lt;div id=<span class="string">"app"</span>&gt;</span><br><span class="line">&lt;div id=<span class="string">"sender"</span>&gt;</span><br><span class="line">&lt;input <span class="built_in">type</span>=<span class="string">"text"</span> v-model=<span class="string">"name"</span> /&gt;</span><br><span class="line">&lt;button @click=<span class="string">"send"</span>&gt;发送&lt;/button&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;div id=<span class="string">"greeting"</span>&gt;</span><br><span class="line">&lt;p style=<span class="string">"margin-bottom: 0;"</span>&gt;Vue: &#123;&#123; name &#125;&#125;&lt;/p&gt;</span><br><span class="line">&lt;p style=<span class="string">"margin-top: 0;"</span>&gt;Spring: &#123;&#123; greeting &#125;&#125;&lt;/p&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line"><span class="built_in">export</span> default &#123; name: <span class="string">"App"</span>,</span><br><span class="line"><span class="function"><span class="title">data</span></span>() &#123; <span class="built_in">return</span> &#123;</span><br><span class="line">name: <span class="string">""</span>, greeting: <span class="string">""</span></span><br><span class="line">&#125;;</span><br><span class="line">&#125;,</span><br><span class="line">methods: &#123;</span><br><span class="line"><span class="function"><span class="title">send</span></span>() &#123; // Axios Promise </span><br><span class="line">fetch(`http://localhost:8000/hello/<span class="variable">$&#123;this.name&#125;</span>`)</span><br><span class="line">.<span class="keyword">then</span>(response =&gt; &#123; <span class="built_in">return</span> response.text();</span><br><span class="line">&#125;)</span><br><span class="line">.<span class="keyword">then</span>(text =&gt; (this.greeting = text))</span><br><span class="line">.catch(error =&gt; console.log(error));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h2 id="Docker与前端应用"><a href="#Docker与前端应用" class="headerlink" title="Docker与前端应用"></a>Docker与前端应用</h2><p>注意：这里演示使用的是Vue框架，文件名为hello-vue,使用服务器为nginx.</p><h3 id="Docker创建前端镜像"><a href="#Docker创建前端镜像" class="headerlink" title="Docker创建前端镜像"></a>Docker创建前端镜像</h3><p>新建Dockerfile文件，文件内容：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">FROM nginx</span><br><span class="line"><span class="comment"># 更多请参考https://hub.docker.com/_/nginx/</span></span><br><span class="line">COPY ./hello /usr/share/nginx/html</span><br></pre></td></tr></table></figure></p><h3 id="Docker创建容器并运行-1"><a href="#Docker创建容器并运行-1" class="headerlink" title="Docker创建容器并运行"></a>Docker创建容器并运行</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker build -t hello-vue . </span><br><span class="line">docker run --name hello-frontend -d -p 80:80 hello-vue</span><br></pre></td></tr></table></figure><p>运行结果：<br><img src="/img/result1.png" alt="运行结果"></p><h2 id="Docker-compose一次运行两个容器"><a href="#Docker-compose一次运行两个容器" class="headerlink" title="Docker-compose一次运行两个容器"></a>Docker-compose一次运行两个容器</h2><p>避免干扰测试建议停止并删除之前运行的容器，指令行在文章末尾<br>1、命令行工具输入code docker-compose.yml 创建docker-compose文件<br>2、docker-compose.yml编译内容<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">version: <span class="string">'3'</span></span><br><span class="line">services:</span><br><span class="line">  frontend:</span><br><span class="line">    image: hello-vue</span><br><span class="line">    ports:</span><br><span class="line">    - 80:80 </span><br><span class="line">    depends_on:</span><br><span class="line">    - backend</span><br><span class="line">  backend:</span><br><span class="line">    image: spring-hello</span><br><span class="line">    ports:</span><br><span class="line">    - 8000:8080</span><br></pre></td></tr></table></figure><br>3、命令行工具输入运行<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose.exe up</span><br></pre></td></tr></table></figure><br><img src="/img/image.png" alt="镜像"><br><img src="/img/container.png" alt="容器"><br>4、运行结果<br><img src="/img/result2.png" alt="运行结果"></p><h2 id="Docker基础指令"><a href="#Docker基础指令" class="headerlink" title="Docker基础指令"></a>Docker基础指令</h2><p>下面是这篇文章运用的docker指令集合方便观看<br>Docker构建镜像(spring-hello为镜像名，-t为容器重新分配一个伪输入终端)<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -t spring-hello .</span><br></pre></td></tr></table></figure><br>Docker运行容器(hello-backend为容器名，-d表示后台运行容器并返回容器ID，-p表示端口号，spring-hello为已搭建的镜像名)<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --name hello-backend -d -p 8000:8080 spring-hello</span><br></pre></td></tr></table></figure><br>显示已安装镜像<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker images</span><br></pre></td></tr></table></figure><br>显示所有容器与显示正在运行容器<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker ps -a</span><br><span class="line">docker ps</span><br></pre></td></tr></table></figure><br>停止容器、删除容器、删除镜像<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker stop 容器名</span><br><span class="line">docker rm 容器名</span><br><span class="line">docker rmi 镜像名</span><br></pre></td></tr></table></figure><br>获取网页内容<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Invoke-RestMethod http://localhost:8000/hello/xz</span><br></pre></td></tr></table></figure><br>创建docker-compose文件与运行该文件<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">code docker-compose.yml</span><br><span class="line">docker-compose.exe up</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo博客配置及个人网站部署</title>
      <link href="/2019/12/25/hexo%E5%8D%9A%E5%AE%A2/"/>
      <url>/2019/12/25/hexo%E5%8D%9A%E5%AE%A2/</url>
      
        <content type="html"><![CDATA[<h2 id="一、Hexo"><a href="#一、Hexo" class="headerlink" title="一、Hexo"></a>一、Hexo</h2><h3 id="Hexo简介"><a href="#Hexo简介" class="headerlink" title="Hexo简介"></a>Hexo简介</h3><p><a href="https://hexo.io/zh-cn/docs/" target="_blank" rel="noopener">Hexo官方文档</a>本文简化列举Hexo框架搭建基础步骤<br>Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。</p><h3 id="Hexo安装"><a href="#Hexo安装" class="headerlink" title="Hexo安装"></a>Hexo安装</h3><p>安装前确保电脑安装了<a href="http://nodejs.org/" target="_blank" rel="noopener">Node.js</a> (Node.js 版本需不低于 8.10，建议使用 Node.js 10.0 及以上版本)和<a href="http://git-scm.com/" target="_blank" rel="noopener">Git</a></p><ul><li>必备的应用程序安装完后，鼠标右键点击Git Bash Here进行git命令行操作。<br><img src="/img/Gitbash.PNG" alt="Git Bash alt"></li><li>输入安装指令  </li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install -g hexo-cli</span><br></pre></td></tr></table></figure><h3 id="建站"><a href="#建站" class="headerlink" title="建站"></a>建站</h3><p>输入以下指令建站，folder为自定义文件名<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ hexo init &lt;folder&gt;</span><br><span class="line">$ <span class="built_in">cd</span> &lt;folder&gt;</span><br><span class="line">$ npm install</span><br></pre></td></tr></table></figure></p><h3 id="文件介绍"><a href="#文件介绍" class="headerlink" title="文件介绍"></a>文件介绍</h3><p>建站完成后生成以下文件<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">├── _config.yml</span><br><span class="line">├── package.json</span><br><span class="line">├── scaffolds</span><br><span class="line">├── <span class="built_in">source</span></span><br><span class="line">└── themes</span><br></pre></td></tr></table></figure></p><h3 id="各个文件作用"><a href="#各个文件作用" class="headerlink" title="各个文件作用"></a>各个文件作用</h3><ul><li>_config.yml<br>网站的配置信息，基于markdown语言，在此配置大部分的参数。</li><li>package.json<br>应用程序的信息。EJS, Stylus 和 Markdown renderer 已默认安装，可以自由移除。</li><li>scaffolds<br>模版 文件夹。当您新建文章时，Hexo 会根据 scaffold 来建立文件。<br>Hexo的模板是指在新建的markdown文件中默认填充的内容。例如，如果您修改 scaffold/post.md 中的 Front-matter 内容，那么每次新建一篇文章时都会包含这个修改。</li><li>source<br>资源文件夹是存放用户资源的地方。除 <em>posts 文件夹之外，开头命名为 </em> (下划线)的文件 / 文件夹和隐藏的文件将会被忽略。Markdown 和 HTML 文件会被解析并放到 public 文件夹，而其他文件会被拷贝过去。</li><li>themes<br>主题 文件夹。Hexo 会根据主题来生成静态页面。  </li></ul><h3 id="网站配置与基础指令"><a href="#网站配置与基础指令" class="headerlink" title="网站配置与基础指令"></a>网站配置与基础指令</h3><ul><li>config文件中记录网站参数 相关参数介绍<a href="https://hexo.io/zh-cn/docs/configuration" target="_blank" rel="noopener">Hexo官方文档</a></li><li>基础指令：<br><strong>new</strong><br>新建一篇文章。如果没有设置 layout 的话，默认使用 _config.yml 中的 default_layout 参数代替。如果标题包含空格的话，请使用引号括起来<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new [layout] &lt;title&gt;</span><br></pre></td></tr></table></figure>-<br><strong>generate</strong><br>生成静态文件。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure></li></ul><p><strong>server</strong><br>启动服务器。可简写为hexo s,默认情况下，访问网址为： <a href="http://localhost:4000/。" target="_blank" rel="noopener">http://localhost:4000/。</a><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure></p><p><strong>clean</strong><br>清除缓存文件 (db.json) 和已生成的静态文件 (public)。<br>在某些情况（尤其是更换主题后），如果发现您对站点的更改无论如何也不生效，您可能需要运行该命令。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo clean</span><br></pre></td></tr></table></figure></p><h2 id="写作"><a href="#写作" class="headerlink" title="写作"></a>写作</h2><p>文件夹进入指令new新建的.md文件，使用文本编辑器编译，个人推荐Sublime Text 3。进入后基于markdown语法进行写作。Hexo官方文档也有写作方法。完成博客编写后可在命令行输入<br>hexo s进入<a href="http://localhost:4000/页面查看编写结果。" target="_blank" rel="noopener">http://localhost:4000/页面查看编写结果。</a>    </p><h3 id="hexo主题选择"><a href="#hexo主题选择" class="headerlink" title="hexo主题选择"></a>hexo主题选择</h3><p><a href="https://hexo.io/themes/" target="_blank" rel="noopener">Hexo主题选择界面</a>找到心仪的主题后，查找该主题的文档按要求进行操作,亦可留言作者求助。  </p><h2 id="部署到个人网站"><a href="#部署到个人网站" class="headerlink" title="部署到个人网站"></a>部署到个人网站</h2><p>这里建议并演示Github仓库Gitpage功能搭建。</p><h3 id="github仓库管理"><a href="#github仓库管理" class="headerlink" title="github仓库管理"></a>github仓库管理</h3><p>1、新建仓库，于个人主页面如图位置创建新的远程仓库<br><img src="/img/newrepository.PNG" alt="New Repository alt"></p><p>2、仓库命名，按下图要求命名(github.io前与左侧owner名一致，github.io不可改)<br><img src="/img/rename.PNG" alt="Repository Name alt"></p><p>3、填写完后点击页面最下面的create按钮，于下图位置点击复制按钮<br><img src="/img/copy.PNG" alt="https/ssh alt"></p><p>4、黏贴复制的内容，修改_config.yml文件下图位置的配置(不同主题可能有些许小不同但命名基本相同),修改url、root、type、branch、github这几处。<br><img src="/img/deploy.PNG" alt="deploy alt"><br><img src="/img/url.PNG" alt="url alt"></p><p>5、进入本地博客文件夹git bash,安装 hexo-deployer-git 输入npm install hexo-deployer-git —save安装完成后依次输入hexo g(生成静态文件)、hexo d(部署到服务器)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ npm install hexo-deployer-git --save</span><br><span class="line"></span><br><span class="line">一般流程：</span><br><span class="line">hexo g 生成静态资源</span><br><span class="line">hexo d 部署</span><br><span class="line">hexo clean 清除静态缓存</span><br><span class="line">hexo s启动服务</span><br></pre></td></tr></table></figure><p>完成上述操作后可在地址 ownername.github.io 查看页面效果</p><h3 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h3><p>若想部署到自己的域名则按下列操作<br>1、ping获取github上部署的博客页面ip地址<br><img src="/img/ping.PNG" alt="ping alt"></p><p>2、github仓库设置(save前为自己的域名地址,不要留https://)<br>在你的博客仓库找到如图所示位置进行设置<br><img src="/img/Settings.PNG" alt="Setting alt"><br><img src="/img/save.PNG" alt="Save alt"></p><p>3、服务器控制台解析,按下图配置即可，ip地址为第一步ping的地址<br><img src="/img/解析.PNG" alt="解析 alt"><br>完成后去自己的域名看看把~</p>]]></content>
      
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo-Theme-Snail</title>
      <link href="/2019/11/01/Hexo-Theme-Snail/"/>
      <url>/2019/11/01/Hexo-Theme-Snail/</url>
      
        <content type="html"><![CDATA[<h1 id="hexo-theme-snail"><a href="#hexo-theme-snail" class="headerlink" title="hexo-theme-snail"></a>hexo-theme-snail</h1><p><a href="https://github.com/dusign/hexo-theme-snail" target="_blank" rel="noopener">View Hexo-Theme-Snail Sources On Github &#10174; </a></p><p><a href="https://www.dusign.net" target="_blank" rel="noopener">View Live Super Snail Blog &#10174;</a></p><p><img src="snail.png" alt="hexo-theme-snail"></p><p>Hexo-theme-snail is a succinct hexo theme. It has two colors, light and star, that can be set according to your own preferences in the settings, and also has the functions of sharing and commenting. More features are under development.</p><h2 id="Features"><a href="#Features" class="headerlink" title="Features"></a>Features</h2><ul><li>light color theme and star theme</li><li>diversified comment system</li><li>notice tips</li><li>share to other platforms (under development)</li><li>picture sharing (under development)</li></ul><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Install-Hexo"><a href="#Install-Hexo" class="headerlink" title="Install Hexo"></a>Install Hexo</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install hexo-cli -g</span><br></pre></td></tr></table></figure><h3 id="Setup-your-blog"><a href="#Setup-your-blog" class="headerlink" title="Setup your blog"></a>Setup your blog</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo init blog</span><br></pre></td></tr></table></figure><h3 id="Installation-Theme"><a href="#Installation-Theme" class="headerlink" title="Installation Theme"></a>Installation Theme</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> blog</span><br><span class="line">$ rm -rf <span class="built_in">source</span></span><br><span class="line">$ rm _config.yml package.json README.md LICENSE</span><br><span class="line">$ git <span class="built_in">clone</span> https://github.com/dusign/hexo-theme-snail.git</span><br><span class="line">$ mv ./hexo-theme-snail/snail ./themes</span><br><span class="line">$ mv ./hexo-theme-snail/* ./</span><br><span class="line">$ npm install</span><br></pre></td></tr></table></figure><h3 id="Set-Theme"><a href="#Set-Theme" class="headerlink" title="Set Theme"></a>Set Theme</h3><p>Modify the value of <code>theme:</code> in <code>_config.yml</code><br><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Extensions</span></span><br><span class="line"><span class="comment">## Plugins: https://hexo.io/plugins/</span></span><br><span class="line"><span class="comment">## Themes: https://hexo.io/themes/</span></span><br><span class="line"><span class="attr">theme:</span> <span class="string">snail</span></span><br></pre></td></tr></table></figure></p><h3 id="Start-the-Server"><a href="#Start-the-Server" class="headerlink" title="Start the Server"></a>Start the Server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><h2 id="Configuration"><a href="#Configuration" class="headerlink" title="Configuration"></a>Configuration</h2><h3 id="Site"><a href="#Site" class="headerlink" title="Site"></a>Site</h3><p>Replace the following information with your own.<br><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Site</span></span><br><span class="line"><span class="attr">title:</span> </span><br><span class="line"><span class="attr">subtitle:</span> <span class="string">At</span> <span class="string">the</span> <span class="string">bottom</span> <span class="string">of</span> <span class="string">the</span> <span class="string">well,</span> <span class="string">it</span> <span class="string">is</span> <span class="string">destined</span> <span class="string">to</span> <span class="string">see</span> <span class="string">only</span> <span class="string">the</span> <span class="string">sky</span> <span class="string">at</span> <span class="string">the</span> <span class="string">wellhead.</span> </span><br><span class="line">          <span class="string">However,</span> <span class="string">the</span> <span class="string">starting</span> <span class="string">point</span> <span class="string">only</span> <span class="string">affects</span> <span class="string">the</span> <span class="string">process</span> <span class="string">of</span> <span class="string">reaching</span> <span class="string">your</span> <span class="string">peak</span> <span class="string">and</span> <span class="string">does</span> <span class="string">not</span> <span class="string">determine</span> <span class="string">the</span> <span class="string">height</span> <span class="string">you</span> <span class="string">reach.</span></span><br><span class="line"><span class="attr">author:</span> <span class="string">Dusign</span></span><br><span class="line"><span class="attr">language:</span> <span class="string">en</span></span><br><span class="line"><span class="attr">timezone:</span></span><br></pre></td></tr></table></figure></p><h3 id="Site-Settings"><a href="#Site-Settings" class="headerlink" title="Site Settings"></a>Site Settings</h3><p>Put customized pictures in <code>img</code> directory.<br><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Site settings</span></span><br><span class="line"><span class="attr">SEOTitle:</span> <span class="string">Hexo-theme-snail</span></span><br><span class="line"><span class="attr">email:</span> <span class="string">hexo-theme-snail@mail.com</span></span><br><span class="line"><span class="attr">description:</span> <span class="string">"A hexo theme"</span></span><br><span class="line"><span class="attr">keyword:</span> <span class="string">"dusign, hexo-theme-snail"</span></span><br><span class="line"><span class="attr">header-img:</span> <span class="string">img/header_img/home-bg-1-dark.jpg</span></span><br><span class="line"><span class="attr">signature:</span> <span class="literal">true</span> <span class="comment">#show signature</span></span><br><span class="line"><span class="attr">signature-img:</span> <span class="string">img/signature/Just-do-it-white.png</span></span><br></pre></td></tr></table></figure></p><h3 id="SNS-Settings"><a href="#SNS-Settings" class="headerlink" title="SNS Settings"></a>SNS Settings</h3><p>If you don’t want to display it, you can delete it directly.<br><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># SNS settings</span></span><br><span class="line"><span class="attr">github_username:</span>    <span class="string">dusign</span></span><br><span class="line"><span class="attr">twitter_username:</span>   <span class="string">dusignr</span></span><br><span class="line"><span class="attr">facebook_username:</span>  <span class="string">Gang</span> <span class="string">Du</span></span><br><span class="line"><span class="attr">zhihu_username:</span> <span class="string">dusignr</span></span><br></pre></td></tr></table></figure></p><h3 id="Sidebar-Settings"><a href="#Sidebar-Settings" class="headerlink" title="Sidebar Settings"></a>Sidebar Settings</h3><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Sidebar Settings</span></span><br><span class="line"><span class="attr">sidebar:</span> <span class="literal">true</span>                      <span class="comment"># whether or not using Sidebar.</span></span><br><span class="line"><span class="attr">sidebar-about-description:</span> <span class="string">"Welcome to visit, I'm Dusign!"</span></span><br><span class="line"><span class="attr">sidebar-avatar:</span> <span class="string">img/ironman-draw.png</span>      <span class="comment"># use absolute URL, seeing it's used in both `/` and `/about/`</span></span><br><span class="line"><span class="attr">widgets:</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">featured-tags</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">short-about</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">recent-posts</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">friends-blog</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">archive</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">category</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># widget behavior</span></span><br><span class="line"><span class="comment">## Archive</span></span><br><span class="line"><span class="attr">archive_type:</span> <span class="string">'monthly'</span></span><br><span class="line"><span class="attr">show_count:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">## Featured Tags</span></span><br><span class="line"><span class="attr">featured-tags:</span> <span class="literal">true</span>                     <span class="comment"># whether or not using Feature-Tags</span></span><br><span class="line"><span class="attr">featured-condition-size:</span> <span class="number">1</span>              <span class="comment"># A tag will be featured if the size of it is more than this condition value</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">## Friends</span></span><br><span class="line"><span class="attr">friends:</span> <span class="string">[</span></span><br><span class="line">    <span class="string">&#123;</span></span><br><span class="line">        <span class="attr">title:</span> <span class="string">"Dusign's Blog"</span><span class="string">,</span></span><br><span class="line">        <span class="attr">href:</span> <span class="string">"https://blog.csdn.net/d_Nail"</span></span><br><span class="line">    <span class="string">&#125;,&#123;</span></span><br><span class="line">        <span class="attr">title:</span> <span class="string">"Dusign's Web"</span><span class="string">,</span></span><br><span class="line">        <span class="attr">href:</span> <span class="string">"#"</span></span><br><span class="line">    <span class="string">&#125;,&#123;</span></span><br><span class="line">        <span class="attr">title:</span> <span class="string">"Dusign's Github"</span><span class="string">,</span></span><br><span class="line">        <span class="attr">href:</span> <span class="string">"https://github.com/dusign"</span></span><br><span class="line">    <span class="string">&#125;,&#123;</span></span><br><span class="line">        <span class="attr">title:</span> <span class="string">"Other"</span><span class="string">,</span></span><br><span class="line">        <span class="attr">href:</span> <span class="string">"#"</span></span><br><span class="line">    <span class="string">&#125;</span></span><br><span class="line"><span class="string">]</span></span><br></pre></td></tr></table></figure><h3 id="Theme"><a href="#Theme" class="headerlink" title="Theme"></a>Theme</h3><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Extensions</span></span><br><span class="line"><span class="comment">## Plugins: https://hexo.io/plugins/</span></span><br><span class="line"><span class="comment">## Themes: https://hexo.io/themes/</span></span><br><span class="line"><span class="attr">theme:</span> <span class="string">snail</span></span><br></pre></td></tr></table></figure><h3 id="Deployment"><a href="#Deployment" class="headerlink" title="Deployment"></a>Deployment</h3><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Deployment</span></span><br><span class="line"><span class="comment">## Docs: https://hexo.io/docs/deployment.html</span></span><br><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">  <span class="attr">repo:</span></span><br><span class="line">      <span class="attr">github:</span> <span class="string">github.repository.address</span></span><br><span class="line">      <span class="attr">coding:</span> <span class="string">coding.repository.address</span></span><br><span class="line">  <span class="attr">branch:</span> <span class="string">master</span></span><br></pre></td></tr></table></figure><h3 id="Comment"><a href="#Comment" class="headerlink" title="Comment"></a>Comment</h3><p>See httpymls://github.com/imsun/gitment for detailed configuration method.<br><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Comment</span></span><br><span class="line"><span class="comment">## This comment system is gitment</span></span><br><span class="line"><span class="comment">## gitment url: https://github.com/imsun/gitment</span></span><br><span class="line"><span class="attr">comment:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">owner:</span></span><br><span class="line">  <span class="attr">repo:</span></span><br><span class="line">  <span class="attr">client_id:</span></span><br><span class="line">  <span class="attr">client_secret:</span></span><br></pre></td></tr></table></figure></p><h3 id="Tip"><a href="#Tip" class="headerlink" title="Tip"></a>Tip</h3><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Tip</span></span><br><span class="line"><span class="attr">tip:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">content:</span> <span class="string">欢迎访问</span> <span class="string">&lt;a</span> <span class="string">href="https://www.dusign.net"</span> <span class="string">target="dusign"&gt;dusign&lt;/a&gt;</span> <span class="string">的博客，博客系统一键分享的功能还在完善中，请大家耐心等待。</span></span><br><span class="line">          <span class="string">若有问题或者有好的建议欢迎留言，笔者看到之后会及时回复。</span></span><br><span class="line">          <span class="string">评论点赞需要github账号登录，如果没有账号的话请点击</span> </span><br><span class="line">          <span class="string">&lt;a</span> <span class="string">href="https://github.com"</span> <span class="string">target="view_window"</span> <span class="string">&gt;</span> <span class="string">github</span> <span class="string">&lt;/a&gt;</span> <span class="string">注册，</span> <span class="string">谢谢</span> <span class="string">!</span></span><br></pre></td></tr></table></figure><h3 id="Color-Sheme"><a href="#Color-Sheme" class="headerlink" title="Color Sheme"></a>Color Sheme</h3><p>Set the <code>enable</code> value of the desired color sheme to <code>true</code>. If the value of <code>bg_effects.star.enable</code> is <code>true</code>, please modify the value of <code>highlight_theme</code> in <code>./themes/snail/_config.yml</code> to <code>night</code>.<br><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Color Sheme</span></span><br><span class="line"><span class="comment">## If there is no effect after modification, please empty the cache and try again.</span></span><br><span class="line"><span class="comment">## ⚠️ The following special effects will take up a lot of cpu resorces, please open it carefully.</span></span><br><span class="line"><span class="attr">bg_effects:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">line:</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">false</span></span><br><span class="line">    <span class="attr">color:</span> <span class="number">129</span><span class="string">,200,61</span></span><br><span class="line">    <span class="attr">pointColor:</span> <span class="number">129</span><span class="string">,200,61</span></span><br><span class="line">    <span class="attr">opacity:</span> <span class="number">0.7</span></span><br><span class="line">    <span class="attr">zIndex:</span> <span class="number">-9</span></span><br><span class="line">    <span class="attr">count:</span> <span class="number">99</span></span><br><span class="line">  <span class="attr">mouse_click:</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">content:</span> <span class="string">'"🌱","just do it","🌾","🍀","don'</span><span class="string">'t give up","🍂","🌻","try it again","🍃","never say die","🌵","🌿","🌴"'</span></span><br><span class="line">    <span class="attr">color:</span> <span class="string">'"rgb(121,93,179)"</span></span><br><span class="line"><span class="string">          ,"rgb(76,180,231)"</span></span><br><span class="line"><span class="string">          ,"rgb(184,90,154)"</span></span><br><span class="line"><span class="string">          ,"rgb(157,211,250)"</span></span><br><span class="line"><span class="string">          ,"rgb(255,0,0)"</span></span><br><span class="line"><span class="string">          ,"rgb(242,153,29)"</span></span><br><span class="line"><span class="string">          ,"rgb(23,204,16)"</span></span><br><span class="line"><span class="string">          ,"rgb(222,0,0)"</span></span><br><span class="line"><span class="string">          ,"rgb(22,36,92)"</span></span><br><span class="line"><span class="string">          ,"rgb(127,24,116)"</span></span><br><span class="line"><span class="string">          ,"rgb(119,195,79)"</span></span><br><span class="line"><span class="string">          ,"rgb(4,77,34)"</span></span><br><span class="line"><span class="string">          ,"rgb(122,2,60)"'</span></span><br><span class="line">  <span class="attr">star:</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure></p><h2 id="Releases"><a href="#Releases" class="headerlink" title="Releases"></a>Releases</h2><p>V1.0</p><ul><li>fix the bugs</li><li>add comment system</li><li>add notice tips</li><li>add star sheme</li></ul><h2 id="License"><a href="#License" class="headerlink" title="License"></a>License</h2><p>Apache License 2.0 Copyright(c) 2018-2020 <a href="https://github.com/dusign" target="_blank" rel="noopener">Dusign</a>   </p><p><a href="https://github.com/dusign/hexo-theme-snail" target="_blank" rel="noopener">hexo-theme-snail</a> is derived from <a href="https://github.com/Huxpro/huxpro.github.io" target="_blank" rel="noopener">Huxpro</a> Apache License 2.0. Copyright (c) 2015-2020 Huxpro</p>]]></content>
      
      
      <categories>
          
          <category> hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo-theme-snail </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>springboot注解代码Annotation整合</title>
      <link href="/2019/10/01/Annotation/"/>
      <url>/2019/10/01/Annotation/</url>
      
        <content type="html"><![CDATA[<p>常见注解代码集合，方便以后查阅，后续持续更新。</p><h2 id="Annotation简介"><a href="#Annotation简介" class="headerlink" title="Annotation简介"></a>Annotation简介</h2><ul><li><p>从Java1.5开始，Java增加了元数据（MetaData）的支持，也就是Annotation（注释）；</p></li><li><p>Annotation能被用来为程序元素（类、方法、成员变量等）设置元数据；</p></li><li><p>Annotation不能影响程序代码的执行，无论添加、删除Annotation，代码始终如一的执行；</p></li><li><p>如果希望让程序中的Annotataion能在 运行时其一定作用，只有通过某种配套的工具对Annotation中的信息进行访问和处理，这些工具统称APT（Annotion Processing Tool）； </p></li></ul><h2 id="Annotation基本注解"><a href="#Annotation基本注解" class="headerlink" title="Annotation基本注解"></a>Annotation基本注解</h2><ul><li><p>@Override：限定重写父类方法,验证@Override下面的方法名是否是你父类中所有的，如果没有则报错，避免方法名错误。</p></li><li><p>@Deprecated：标记已过时,用于标识某个程序元素（类、方法等）已过时，当其他程序使用已过时的类、方法时，编译器将会给出警告。该方法不可再调用。</p></li><li><p>@SuppressWarnings：抑制编译器警告,指示被Annotation标识的程序元素（以及在该程序元素中的所有字元素）取消显示指定的编译器警告；一直作用于该程序元素的所有子元素；</p></li></ul><h2 id="lombok基本注解"><a href="#lombok基本注解" class="headerlink" title="lombok基本注解"></a>lombok基本注解</h2><ul><li><p>@Data:使用这个注解，就不用再去手写Getter,Setter,equals,canEqual,hasCode,toString等方法了，注解后在编译时会自动加进去。</p></li><li><p>@AllArgsConstructor:使用后添加一个构造函数，该构造函数含有所有已声明字段属性参数。</p></li><li><p>@NoArgsConstructor:使用后创建一个无参构造函数。</p></li><li><p>@Builder:解决某个类有很多构造函数的情况，省去写很多构造函数的麻烦。用一个内部类去实例化一个对象，避免一个类出现过多构造函数。</p></li><li><p>@NonNull：注解在属性上，如果注解了，就必须不能为Null。</p></li><li><p>@toString:生成toString方法，默认情况下，会输出类名、所有属性，属性会按照顺序输出，以逗号分割。</p></li></ul><h2 id="注解-annotations-列表"><a href="#注解-annotations-列表" class="headerlink" title="注解(annotations)列表"></a>注解(annotations)列表</h2><ul><li><p>@SpringBootApplication：包含了@ComponentScan、@Configuration和@EnableAutoConfiguration注解。其中@ComponentScan让spring Boot扫描到Configuration类并把它加入到程序上下文。</p></li><li><p>@Configuration 等同于spring的XML配置文件；使用Java代码可以检查类型安全。</p></li><li><p>@EnableAutoConfiguration 自动配置。</p></li><li><p>@ComponentScan 组件扫描，可自动发现和装配一些Bean。</p></li><li><p>@Component可配合CommandLineRunner使用，在程序启动后执行一些基础任务。</p></li><li><p>@RestController注解是@Controller和@ResponseBody的合集,表示这是个控制器bean,并且是将函数的返回值直 接填入HTTP响应体中,是REST风格的控制器。</p></li><li><p>@Autowired自动导入。</p></li><li><p>@PathVariable获取参数。</p></li><li><p>@JsonBackReference解决嵌套外链问题。</p></li><li><p>@RepositoryRestResourcepublic配合spring-boot-starter-data-rest使用。</p></li></ul><h2 id="注解-annotations-详解-SpringBootApplication："><a href="#注解-annotations-详解-SpringBootApplication：" class="headerlink" title="注解(annotations)详解@SpringBootApplication："></a>注解(annotations)详解@SpringBootApplication：</h2><ul><li><p>@SpringBootApplication：申明让spring boot自动给程序进行必要的配置，这个配置等同于：@Configuration ，@EnableAutoConfiguration 和 @ComponentScan 三个配置。</p></li><li><p>@ResponseBody：表示该方法的返回结果直接写入HTTP response body中，一般在异步获取数据时使用，用于构建RESTful的api。在使用@RequestMapping后，返回值通常解析为跳转路径，加上@esponsebody后返回结果不会被解析为跳转路径，而是直接写入HTTP response body中。比如异步获取json数据，加上@Responsebody后，会直接返回json数据。该注解一般会配合@RequestMapping一起使用。</p></li><li><p>@Controller：用于定义控制器类对Controller实现类进行标注，在spring项目中由控制器负责将用户发来的URL请求转发到对应的服务接口（service层），一般这个注解在类中，通常方法需要配合注解@RequestMapping。</p></li><li><p>@RestController：用于标注控制层组件(如struts中的action)，@ResponseBody和@Controller的合集。</p></li><li><p>@RequestMapping：提供路由信息，负责URL到Controller中的具体函数的映射<br>@GetMapping：是@RequestMapping(method = RequestMethod.GET)的缩写。该注解将HTTP Get 映射到 特定的处理方法上。大白话即：根据HTTP地址映射调用Controller对应方法<br>@PostMapping:向服务器提交信息,即客户端信息返回给服务器端。<br>@PutMapping：作用与@PostMapping类似，用@PutMapping倾向于更新信息。<br>@DeleteMapping： 删除URL映射</p></li><li><p>@EnableAutoConfiguration：SpringBoot自动配置（auto-configuration）：尝试根据你添加的jar依赖自动配置你的Spring应用。例如，如果你的classpath下存在HSQLDB，并且你没有手动配置任何数据库连接beans，那么我们将自动配置一个内存型（in-memory）数据库”。你可以将@EnableAutoConfiguration或者@SpringBootApplication注解添加到一个@Configuration类上来选择自动配置。如果发现应用了你不想要的特定自动配置类，你可以使用@EnableAutoConfiguration注解的排除属性来禁用它们。</p></li><li><p>@ComponentScan：其实很简单，@ComponentScan主要就是定义扫描的路径从中找出标识了需要装配的类自动装配到spring的bean容器中,你一定都有用过@Controller，@Service，@Repository注解，查看其源码你会发现，他们中有一个共同的注解@Component，没错@ComponentScan注解默认就会装配标识了@Controller，@Service，@Repository，@Component注解的类到spring容器中。当然，这个的前提就是你需要在所扫描包下的类上引入注解。</p></li><li><p>@Configuration：相当于传统的xml配置文件，如果有些第三方库需要用到xml文件，建议仍然通过@Configuration类作为项目的配置主类——可以使用@ImportResource注解加载xml配置文件。</p></li><li><p>@Import：用来导入其他配置类。</p></li><li><p>@ImportResource：用来加载xml配置文件。</p></li><li><p>@Autowired：自动导入依赖的bean,byType方式。把配置好的Bean拿来用，完成属性、方法的组装，它可以对类成员变量、方法及构造函数进行标注，完成自动装配的工作。当加上（required=false）时，就算找不到bean也不报错。</p></li><li><p>@Service：一般用于修饰service层的组件用于对Service实现类进行标注,（注入dao）用于标注服务层，主要用来进行业务的逻辑处理.</p></li><li><p>@Repository：使用@Repository注解可以确保DAO或者repositories提供异常转译实现dao访问，这个注解修饰的DAO或者repositories类会被ComponetScan发现并配置，同时也不需要为它们提供XML配置项,用于对DAO实现类进行标注。</p></li><li><p>@Bean：用@Bean标注方法等价于XML中配置的bean,相当于XML中的,放在方法的上面，而不是类，意思是产生一个bean,并交给spring管理。</p></li><li><p>@Value：注入Spring boot application.properties配置的属性的值。示例代码：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@Value(value = “<span class="comment">#&#123;message&#125;”)</span></span><br><span class="line">private String message;</span><br></pre></td></tr></table></figure></li><li><p>@Inject：等价于默认的@Autowired，只是没有required属性；</p></li><li><p>@Component：泛指组件，当组件不好归类的时候，我们可以使用这个注解进行标注。带此注解的类看为组件，就是说当我们的类不属于各种归类的时候（不属于@Controller、@Services等的时候），我们就可以使用@Component来标注这个类。</p></li><li><p>@Qualifier：当有多个同一类型的Bean时，可以用@Qualifier(“name”)来指定。与@Autowired配合使用。@Qualifier限定描述符除了能根据名字进行注入，但能进行更细粒度的控制如何选择候选者，具体使用方式如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@Autowired</span><br><span class="line">@Qualifier(value = “demoInfoService”)</span><br><span class="line">private DemoInfoService demoInfoService;</span><br></pre></td></tr></table></figure></li><li>@Resource(name=”name”,type=”type”)：没有括号内内容的话，默认byName。与@Autowired干类似的事。<br>-<br>@Resource有两个常用属性name、type，所以分4种情况：<br>1、指定name和type：通过name找到唯一的bean，找不到抛出异常；如果type和字段类型不一致，也会抛出异常<br>2、指定name：通过name找到唯一的bean，找不到抛出异常<br>3、指定type：通过tpye找到唯一的bean，如果不唯一，则抛出异常：NoUniqueBeanDefinitionException<br>4、都不指定：通过字段名作为key去查找，找到则赋值；找不到则再通过字段类型去查找，如果不唯一，则抛出异常：NoUniqueBeanDefinitionException</li></ul><p>@Autowired<br>1、@Autowired只有一个属性required，默认值为true，为true时，找不到就抛异常，为false时，找不到就赋值为null。<br>2、@Autowired按类型查找，如果该类型的bean不唯一，则抛出异常；可通过组合注解解决@Autowired()@Qualifier(“baseDao”)</p><p>不同点：<br>Resource是JDK提供的，而Autowired是Spring提供的<br>Resource不允许找不到bean的情况，而Autowired允许（@Autowired(required = false)）<br>指定name的方式不一样，@Resource(name = “baseDao”),@Autowired()@Qualifier(“baseDao”)<br>Resource默认通过name查找，而Autowired默认通过type查找</p><h2 id="JPA注解"><a href="#JPA注解" class="headerlink" title="JPA注解"></a>JPA注解</h2><ul><li><p>@Entity：@Table(name=”“)：表明这是一个实体类。一般用于jpa这两个注解一般一块使用，但是如果表名和实体类名相同的话，@Table可以省略</p></li><li><p>@Table 当实体类与其映射的数据库表名不同名时需要使用，声明此对象映射到数据库的数据表，通过它可以为实体指定表(talbe)。</p></li><li><p>@MappedSuperClass:用在确定是父类的entity上。父类的属性子类可以继承。</p></li><li><p>@NoRepositoryBean:一般用作父类的repository，有这个注解，spring不会去实例化该repository。</p></li><li><p>@Column：用来标识实体类中属性与数据表中字段的对应关系。如果字段名与列名相同，则可以省略。</p></li><li><p>@Id：表示该属性为主键。</p></li><li><p>@GeneratedValue(strategy = GenerationType.SEQUENCE,generator = “repair_seq”)：表示主键生成策略是sequence（可以为Auto、IDENTITY、native等，Auto表示可在多个数据库间切换），指定sequence的名字是repair_seq。</p></li><li><p>@SequenceGeneretor(name = “repair_seq”, sequenceName = “seq_repair”, allocationSize = 1)：name为sequence的名称，以便使用，sequenceName为数据库的sequence名称，两个名称可以一致。</p></li><li><p>@Transient：表示该属性并非一个到数据库表的字段的映射,ORM框架将忽略该属性。如果一个属性并非数据库表的字段映射,就务必将其标示为@Transient,否则,ORM框架默认其注解为@Basic。@Basic(fetch=FetchType.LAZY)：标记可以指定实体属性的加载方式</p></li><li><p>@JsonIgnore：作用是json序列化时将Java bean中的一些属性忽略掉,序列化和反序列化都受影响。</p></li><li><p>@JoinColumn（name=”loginId”）:一对一：本表中指向另一个表的外键。一对多：另一个表指向本表的外键。</p></li><li><p>@OneToOne、@OneToMany、@ManyToOne：对应hibernate配置文件中的一对一，一对多，多对一。</p></li></ul><h2 id="springMVC相关注解"><a href="#springMVC相关注解" class="headerlink" title="springMVC相关注解"></a>springMVC相关注解</h2><ul><li><p>@RequestMapping：@RequestMapping(“/path”)表示该控制器处理所有“/path”的UR L请求。RequestMapping是一个用来处理请求地址映射的注解，可用于类或方法上。<br>用于类上，表示类中的所有响应请求的方法都是以该地址作为父路径。该注解有六个属性：<br>params:指定request中必须包含某些参数值是，才让该方法处理。<br>headers:指定request中必须包含某些指定的header值，才能让该方法处理请求。<br>value:指定请求的实际地址，指定的地址可以是URI Template 模式<br>method:指定请求的method类型， GET、POST、PUT、DELETE等<br>consumes:指定处理请求的提交内容类型（Content-Type），如application/json,text/html;<br>produces:指定返回的内容类型，仅当request请求头中的(Accept)类型中包含该指定类型才返回</p></li><li><p>@RequestParam：用在方法的参数前面。将请求参数绑定到你控制器的方法参数上（是springmvc中接收普通参数的注解）<br>接收请求地址末尾为？(value的参数名)的请求</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">语法：@RequestParam(value=”参数名”,required=”<span class="literal">true</span>/<span class="literal">false</span>”,defaultValue=””)</span><br><span class="line"> </span><br><span class="line">value：参数名</span><br><span class="line"> </span><br><span class="line">required：是否包含该参数，默认为<span class="literal">true</span>，表示该请求路径中必须包含该参数，如果不包含就报错。</span><br><span class="line"></span><br><span class="line">defaultValue：默认参数值，如果设置了该值，required=<span class="literal">true</span>将失效，自动为<span class="literal">false</span>,如果没有传该参数，就使用默认值</span><br><span class="line">@RequestMapping(<span class="string">"/list"</span>)</span><br><span class="line">public String <span class="built_in">test</span>(@RequestParam(value = <span class="string">"userId"</span>, defaultValue = <span class="string">"0"</span>, required = <span class="literal">false</span>) int userId) &#123;</span><br><span class="line">　　<span class="built_in">return</span> <span class="string">"list"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li>@PathVariable:路径变量。参数与大括号里的名字一样要相同.<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">RequestMapping(“user/get/mac/&#123;macAddress&#125;”)</span><br><span class="line">  2 public String getByMacAddress(@PathVariable String macAddress)&#123;</span><br><span class="line">  3    //<span class="keyword">do</span> something; </span><br><span class="line">  4 &#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="全局异常处理"><a href="#全局异常处理" class="headerlink" title="全局异常处理"></a>全局异常处理</h2><ul><li><p>@ControllerAdvice：包含@Component。可以被扫描到。统一处理异常。</p></li><li><p>@ExceptionHandler（Exception.class）：用在方法上面表示遇到这个异常就执行以下方法。</p></li></ul><h2 id="项目中具体配置解析和使用环境"><a href="#项目中具体配置解析和使用环境" class="headerlink" title="项目中具体配置解析和使用环境"></a>项目中具体配置解析和使用环境</h2><ul><li>@MappedSuperclass：<br>1.@MappedSuperclass 注解使用在父类上面，是用来标识父类的</li></ul><p>2.@MappedSuperclass 标识的类表示其不能映射到数据库表，因为其不是一个完整的实体类，但是它所拥有的属性能够映射在其子类对用的数据库表中</p><p>3.@MappedSuperclass 标识的类不能再有@Entity或@Table注解</p><ul><li>@Column：<br>1.当实体的属性与其映射的数据库表的列不同名时需要使用@Column标注说明，该属性通常置于实体的属性声明语句之前，还可与 @Id 标注一起使用。</li></ul><p>2.@Column 标注的常用属性是name，用于设置映射数据库表的列名。此外，该标注还包含其它多个属性，如：unique、nullable、length、precision等。具体如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">name属性：name属性定义了被标注字段在数据库表中所对应字段的名称</span><br><span class="line">unique属性：unique属性表示该字段是否为唯一标识，默认为<span class="literal">false</span>，如果表中有一个字段需要唯一标识，则既可以使用该标记，也可以使用@Table注解中的@UniqueConstraint</span><br><span class="line">nullable属性：nullable属性表示该字段是否可以为null值，默认为<span class="literal">true</span></span><br><span class="line">insertable属性：insertable属性表示在使用”INSERT”语句插入数据时，是否需要插入该字段的值</span><br><span class="line">updateable属性：updateable属性表示在使用”UPDATE”语句插入数据时，是否需要更新该字段的值</span><br><span class="line">insertable和updateable属性：一般多用于只读的属性，例如主键和外键等，这些字段通常是自动生成的</span><br><span class="line">columnDefinition属性：columnDefinition属性表示创建表时，该字段创建的SQL语句，一般用于通过Entity生成表定义时使用，如果数据库中表已经建好，该属性没有必要使用</span><br><span class="line">table属性：table属性定义了包含当前字段的表名</span><br><span class="line">length属性：length属性表示字段的长度，当字段的类型为varchar时，该属性才有效，默认为255个字符</span><br><span class="line">precision属性和scale属性：precision属性和scale属性一起表示精度，当字段类型为double时，precision表示数值的总长度，scale表示小数点所占的位数</span><br><span class="line">    具体如下：</span><br><span class="line">   1.double类型将在数据库中映射为double类型，precision和scale属性无效</span><br><span class="line">   2.double类型若在columnDefinition属性中指定数字类型为decimal并指定精度，则最终以columnDefinition为准</span><br><span class="line">   3.BigDecimal类型在数据库中映射为decimal类型，precision和scale属性有效</span><br><span class="line">   4.precision和scale属性只在BigDecimal类型中有效</span><br></pre></td></tr></table></figure><br>3.@Column 标注的columnDefinition属性: 表示该字段在数据库中的实际类型.通常 ORM 框架可以根据属性类型自动判断数据库中字段的类型,但是对于Date类型仍无法确定数据库中字段类型究竟是DATE,TIME还是TIMESTAMP.此外,String的默认映射类型为VARCHAR,如果要将 String 类型映射到特定数据库的 BLOB 或TEXT字段类型.</p><p>4.@Column标注也可置于属性的getter方法之前</p><ul><li>@PreUpdate和@PrePersist:<br>@PreUpdate<br>1.用于为相应的生命周期事件指定回调方法。<br>2.该注释可以应用于实体类，映射超类或回调监听器类的方法。<br>3.用于setter 如果要每次更新实体时更新实体的属性，可以使用@PreUpdate注释。<br>4.使用该注释，您不必在每次更新用户实体时显式更新相应的属性。<br>5.preUpdate不允许您更改您的实体。 您只能使用传递给事件的计算的更改集来修改原始字段值。<br>@Prepersist<br>1.查看@PrePersist注释，帮助您在持久化之前自动填充实体属性。<br>2.可以用来在使用jpa的时记录一些业务无关的字段，比如最后更新时间等等。生命周期方法注解（delete没有生命周期事件）<br>3.@PrePersist save之前被调用，它可以返回一个DBObject代替一个空的 @PostPersist save到datastore之后被调用<br>4.@PostLoad 在Entity被映射之后被调用 @EntityListeners 指定外部生命周期事件实现类<br>实体Bean生命周期的回调事件:<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">方法的标注： @PrePersist @PostPersist @PreRemove @PostRemove @PreUpdate @PostUpdate @PostLoad 。</span><br><span class="line">它们标注在某个方法之前，没有任何参数。这些标注下的方法在实体的状态改变前后时进行调用，相当于拦截器;</span><br><span class="line">pre 表示在状态切换前触发，post 则表示在切换后触发。 </span><br><span class="line">@PostLoad 事件在下列情况触发： </span><br><span class="line">1. 执行 EntityManager.find()或 getreference()方法载入一个实体后； </span><br><span class="line">2. 执行 JPA QL 查询过后； </span><br><span class="line">3. EntityManager.refresh( )方法被调用后。 </span><br><span class="line">@PrePersist 和 @PostPersist事件在实体对象插入到数据库的过程中发生;</span><br><span class="line">@PrePersist 事件在调用 EntityManager.persist()方法后立刻发生，级联保存也会发生此事件，此时的数据还没有真实插入进数据库。</span><br><span class="line">@PostPersist 事件在数据已经插入进数据库后发生。</span><br><span class="line">@PreUpdate 和 @PostUpdate 事件的触发由更新实体引起, @PreUpdate 事件在实体的状态同步到数据库之前触发，此时的数据还没有真实更新到数据库。</span><br><span class="line">@PostUpdate 事件在实体的状态同步到数据库后触发，同步在事务提交时发生。 </span><br><span class="line">@PreRemove 和 @PostRemove 事件的触发由删除实体引起，@ PreRemove 事件在实体从数据库删除之前触发，即调用了 EntityManager.remove()方法或者级联删除</span><br><span class="line"></span><br><span class="line">当你在执行各种持久化方法的时候，实体的状态会随之改变，状态的改变会引发不同的生命周期事件。这些事件可以使用不同的注释符来指示发生时的回调函数。</span><br><span class="line">@javax.persistence.PostLoad：加载后。</span><br><span class="line">@javax.persistence.PrePersist：持久化前。</span><br><span class="line">@javax.persistence.PostPersist：持久化后。</span><br><span class="line">@javax.persistence.PreUpdate：更新前。</span><br><span class="line">@javax.persistence.PostUpdate：更新后。</span><br><span class="line">@javax.persistence.PreRemove：删除前。</span><br><span class="line">@javax.persistence.PostRemove：删除后。</span><br></pre></td></tr></table></figure><img src="/img/Bean.jpg" alt="实体Bean生命周期"><br>1）数据库查询</li></ul><p>@PostLoad事件在下列情况下触发：</p><p>执行EntityManager.find()或getreference()方法载入一个实体后。</p><p>执行JPQL查询后。</p><p>EntityManager.refresh()方法被调用后。</p><p>2）数据库插入</p><p>@PrePersist和@PostPersist事件在实体对象插入到数据库的过程中发生：</p><p>@PrePersist事件在调用persist()方法后立刻发生，此时的数据还没有真正插入进数据库。</p><p>@PostPersist事件在数据已经插入进数据库后发生。</p><p>3）数据库更新</p><p>@PreUpdate和@PostUpdate事件的触发由更新实体引起：</p><p>@PreUpdate事件在实体的状态同步到数据库之前触发，此时的数据还没有真正更新到数据库。</p><p>@PostUpdate事件在实体的状态同步到数据库之后触发，同步在事务提交时发生。</p><p>4）数据库删除</p><p>@PreRemove和@PostRemove事件的触发由删除实体引起：</p><p>@PreRemove事件在实体从数据库删除之前触发，即在调用remove()方法删除时发生，此时的数据还没有真正从数据库中删除。</p><p>@PostRemove事件在实体从数据库中删除后触发。</p><h2 id="使用-Configuration注解来代替Spring的bean配置"><a href="#使用-Configuration注解来代替Spring的bean配置" class="headerlink" title="使用@Configuration注解来代替Spring的bean配置"></a>使用@Configuration注解来代替Spring的bean配置</h2><ul><li><p>Spring配置文件（application-config.xml）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;beans&gt;</span><br><span class="line">        &lt;bean id=<span class="string">"orderService"</span> class=<span class="string">"com.acme.OrderService"</span>/&gt;</span><br><span class="line">                &lt;constructor-arg ref=<span class="string">"orderRepository"</span>/&gt;</span><br><span class="line">        &lt;/bean&gt;</span><br><span class="line">        &lt;bean id=<span class="string">"orderRepository"</span> class=<span class="string">"com.acme.OrderRepository"</span>/&gt;</span><br><span class="line">                &lt;constructor-arg ref=<span class="string">"dataSource"</span>/&gt;</span><br><span class="line">        &lt;/bean&gt;</span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure></li><li><p>Spring Java @Configuratio通过java代码来装配bean的方案：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class ApplicationConfig &#123;</span><br><span class="line"></span><br><span class="line">        public @Bean OrderService <span class="function"><span class="title">orderService</span></span>() &#123;</span><br><span class="line">                <span class="built_in">return</span> new OrderService(orderRepository());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public @Bean OrderRepository <span class="function"><span class="title">orderRepository</span></span>() &#123;</span><br><span class="line">                <span class="built_in">return</span> new OrderRepository(dataSource());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用bean</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">JavaConfigApplicationContext ctx = new JavaConfigApplicationContext(ApplicationConfig.class);</span><br><span class="line">OrderService orderService = ctx.getBean(OrderService.class);</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> Annotation </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Annotation </tag>
            
            <tag> 注解代码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用Git上传、更新、删除GitHub仓库文件</title>
      <link href="/2019/08/19/%E4%BD%BF%E7%94%A8Git%E4%B8%8A%E4%BC%A0%E3%80%81%E6%9B%B4%E6%96%B0%E3%80%81%E5%88%A0%E9%99%A4%20GitHub%20%E4%BB%93%E5%BA%93%E6%96%87%E4%BB%B6/"/>
      <url>/2019/08/19/%E4%BD%BF%E7%94%A8Git%E4%B8%8A%E4%BC%A0%E3%80%81%E6%9B%B4%E6%96%B0%E3%80%81%E5%88%A0%E9%99%A4%20GitHub%20%E4%BB%93%E5%BA%93%E6%96%87%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<p>本文为转载CSDN博主<a href="https://mvnrepository.com/artifact/com.fasterxml.jackson.core/jackson-databind" target="_blank" rel="noopener">ZY-JIMMY</a>的文章,感谢博主转载允许</p><h2 id="创建GitHub代码仓库"><a href="#创建GitHub代码仓库" class="headerlink" title="创建GitHub代码仓库"></a>创建GitHub代码仓库</h2><p>首先在GitHub上创建自己的仓库，进入GitHub官网并登陆，点击 <code>New repository</code> 如下图<br><img src="/img/GitHub1.png" alt=""><br>然后输入自己的仓库名称及仓库说明，输入完毕后点击 <code>Create repository</code></p><blockquote><p>Repository name: 仓库名称<br>Description(可选): 仓库描述介绍<br>Public, Private : 仓库权限（公开共享，私有或指定合作者）<br>Initialize this repository with a README: 添加一个README.md<br>gitignore: 不需要进行版本管理的仓库类型，对应生成文件.gitignore<br>license: 证书类型，对应生成文件LICENSE<br><img src="/img/GitHub2.png" alt=""><br>如下图所示，建立好了一个代码仓库，可将项目的文件、文件夹通过 Git 上传至此<br><img src="/img/GitHub3.png" alt=""></p></blockquote><h2 id="获取Git"><a href="#获取Git" class="headerlink" title="获取Git"></a>获取Git</h2><p>在Git官网下载最新版本的Git软件安装到本地：<a href="https://www.git-scm.com/download/" target="_blank" rel="noopener">https://www.git-scm.com/download/</a></p><h2 id="上传本地项目文件到GitHub新建仓库"><a href="#上传本地项目文件到GitHub新建仓库" class="headerlink" title="上传本地项目文件到GitHub新建仓库"></a>上传本地项目文件到GitHub新建仓库</h2><p>点击<code>Clone or dowload</code>会出现一个地址，copy这个地址备用。<br><img src="/img/GitHub4.png" alt=""><br>接下来回到本地操作，首先右键你的项目，如果你之前安装git成功的话，右键会出现两个新选项，分别为<em>Git Gui Here</em>,<em>Git Bash Here</em>,这里我们选择<code>Git Bash Here</code>，进入如下界面，Bank即为我的项目名。<br><img src="/img/GitHub5.png" alt=""><br>接下来输入如下命令（<code>关键步骤</code>），把github上面的仓库克隆到本地<br><code>git clone 仓库地址</code><br><img src="/img/GitHub6.png" alt=""><br>进入本地项目文件夹，其中会多出一个和github上面的仓库名相同的文件夹，我们把本地项目文件夹下的所有文件（除了新多出的那个文件夹）都复制到那个新多出的文件夹下<br><img src="/img/GitHub7.png" alt=""><br>输入命令<code>cd 仓库名称</code>，进入本地仓库文件夹<br><img src="/img/GitHub8.png" alt=""><br>接下来依次输入以下代码即可完成其他剩余操作：<br>git add .        （后面的 . 是把该文件夹下面的文件都添加进来）</p><p>git commit  -m  “提交信息”  （“提交信息”是自定义的，如“first commit”）</p><p>git pull origin master    （先使用pull，进行合并然后再进行push，即先使用pull将远程文件同步下来。）</p><p>git push -u origin master   （此操作目的是把本地仓库push到github上面，此步骤需要你输入帐号和密码）<br><img src="/img/GitHub9.png" alt=""><br><img src="/img/GitHub10.png" alt=""><br><img src="/img/GitHub11.png" alt=""><br>完成以上步骤后，查看代码仓库会发现项目已经上传成功<br><img src="/img/GitHub12.png" alt=""><br>上传本地项目文件到GitHub已有代码仓库<br>上传文件夹：参考<a href="https://blog.csdn.net/geerniya/article/details/79552247、" target="_blank" rel="noopener">https://blog.csdn.net/geerniya/article/details/79552247、</a>  <a href="https://blog.csdn.net/weixin_42350212/article/details/80560272" target="_blank" rel="noopener">https://blog.csdn.net/weixin_42350212/article/details/80560272</a></p><p>备注：<br>hexo g 生成静态资源<br>hexo d 部署<br>hexo clean 清除静态缓存<br>hexo s启动服务</p><p>执行git命令时出现fatal: ‘origin’ does not appear to be a git repository错误<br>git remote add origin git@github.com:raineddown/raineddown.github.io.git<br> 将关联远程仓库为origin</p><p> [rejected] master -&gt; master (non-fast-forward)<br>git pull origin master —allow-unrelated-histories //把远程仓库和本地同步，消除差异</p><p>修改分支：<br>git checkout -b xxxx</p><p>git push 失败解决方法：<a href="https://blog.csdn.net/Ltime/article/details/70224456" target="_blank" rel="noopener">https://blog.csdn.net/Ltime/article/details/70224456</a><br><img src="/img/GitHub13.png" alt=""><br><img src="/img/GitHub14.png" alt=""><br><img src="/img/GitHub15.png" alt=""></p><p>上传文件<br><img src="/img/GitHub16.png" alt=""><br><img src="/img/GitHub17.png" alt=""></p><h2 id="使用Git更新GitHub仓库文件"><a href="#使用Git更新GitHub仓库文件" class="headerlink" title="使用Git更新GitHub仓库文件"></a>使用Git更新GitHub仓库文件</h2><p>参考：<a href="https://blog.csdn.net/asuna_yu/article/details/80174011" target="_blank" rel="noopener">https://blog.csdn.net/asuna_yu/article/details/80174011</a><br><img src="/img/GitHub18.png" alt=""><br><img src="/img/GitHub19.png" alt=""></p><h2 id="使用Git删除Github仓库文件夹"><a href="#使用Git删除Github仓库文件夹" class="headerlink" title="使用Git删除Github仓库文件夹"></a>使用Git删除Github仓库文件夹</h2><p>参考：<a href="https://blog.csdn.net/luocheng7430/article/details/81222231" target="_blank" rel="noopener">https://blog.csdn.net/luocheng7430/article/details/81222231</a><br>     <a href="https://www.cnblogs.com/crazyStar/articles/7354894.html" target="_blank" rel="noopener">https://www.cnblogs.com/crazyStar/articles/7354894.html</a><br><img src="/img/GitHub20.png" alt=""><br><img src="/img/GitHub21.png" alt=""><br><img src="/img/GitHub22.png" alt=""><br><img src="/img/GitHub23.png" alt=""><br><img src="/img/GitHub24.png" alt=""></p><p>Git 各种命令：<a href="https://www.cnblogs.com/smiler/p/5074124.html" target="_blank" rel="noopener">https://www.cnblogs.com/smiler/p/5074124.html</a> </p>]]></content>
      
      
      <categories>
          
          <category> GitHub </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
            <tag> GitHub </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JSON基础</title>
      <link href="/2019/08/19/JSON/"/>
      <url>/2019/08/19/JSON/</url>
      
        <content type="html"><![CDATA[<h2 id="JSON简介"><a href="#JSON简介" class="headerlink" title="JSON简介"></a>JSON简介</h2><p>JSON(JavaScript Object Notation, JS 对象简谱) 是一种轻量级的数据交换格式。它基于 ECMAScript (欧洲计算机协会制定的js规范)的一个子集，采用完全独立于编程语言的文本格式来存储和表示数据。简洁和清晰的层次结构使得 JSON 成为理想的数据交换语言。 易于人阅读和编写，同时也易于机器解析和生成，并有效地提升网络传输效率，是JavaScript对象的字符串表示法，它使用文本表示一个 JS 对象的信息。降维说人话就是一种便于理解、编译、传输用于描述实例的字符串。</p><h2 id="Json要求和语法格式"><a href="#Json要求和语法格式" class="headerlink" title="Json要求和语法格式"></a>Json要求和语法格式</h2><ul><li>对象表示为键值对，数据由逗号分隔</li><li>花括号保存对象</li><li>方括号保存数组</li></ul><p>JSON 键值对是用来保存 JavaScript 对象的一种方式，键/值对组合中的键名写在前面并用双引号 “” 包裹，使用冒号 : 分隔，然后紧接着值：<br>例如：name为键、Hello world为数据值即从后端获取的对象/值<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="string">"name"</span>:<span class="string">"Hello world"</span>&#125; </span><br><span class="line">//下为JSON数组格式//</span><br><span class="line">&#123;<span class="string">"name"</span>:[<span class="string">"luoyonghao"</span>,<span class="string">"jiayueting"</span>,<span class="string">"sunyuchen"</span>]&#125;</span><br></pre></td></tr></table></figure></p><h2 id="JSON解析工具"><a href="#JSON解析工具" class="headerlink" title="JSON解析工具"></a>JSON解析工具</h2><h3 id="Jackson"><a href="#Jackson" class="headerlink" title="Jackson"></a>Jackson</h3><p>Jackson框架是基于Java平台的一套数据处理工具<br>依赖：<br><a href="https://mvnrepository.com/artifact/com.fasterxml.jackson.core/jackson-databind" target="_blank" rel="noopener">官方依赖</a><br>pom.xml配置<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- https://mvnrepository.com/artifact/com.fasterxml.jackson.core/jackson-databind --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.10.2&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><br>将对象转化为JSON字符串<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//创建一个jackson的对象映射器，用来解析数据</span><br><span class="line">ObjectMapper mapper = new ObjectMapper();</span><br><span class="line">//将对象解析成为json格式</span><br><span class="line">String str = mapper.writeValueAsString(解析对象名);</span><br></pre></td></tr></table></figure><br>前端js相关<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//将js对象转换成json字符串</span><br><span class="line"> var str = JSON.stringify(js对象);</span><br><span class="line"> console.log(str);</span><br><span class="line"> </span><br><span class="line"> //将json字符串转换为js对象</span><br><span class="line"> var js对象 = JSON.parse(str);</span><br><span class="line"> console.log(js对象.age,js对象.name,js对象.sex);</span><br></pre></td></tr></table></figure></p><h3 id="fastjson"><a href="#fastjson" class="headerlink" title="fastjson"></a>fastjson</h3><p>fastJson是阿里巴巴出品的一个json序列化工具<br>依赖配置<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">   &lt;groupId&gt;com.alibaba&lt;/groupId&gt;</span><br><span class="line">   &lt;artifactId&gt;fastjson&lt;/artifactId&gt;</span><br><span class="line">   &lt;version&gt;1.2.60&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><br>将对象转化为JSON字符串<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String objJson = JSON.toJSONString(Object object);</span><br></pre></td></tr></table></figure><br>将Json串转换成java对象<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//对象是单个元素</span><br><span class="line">String objJson = JSON.parseObject(json对象，CLAZZ);</span><br><span class="line">//对象包含多个元素</span><br><span class="line">String objJson = JSON.parseArray(json对象，CLAZZ)；</span><br><span class="line">//CLAZZ为String.class为Map.class等等</span><br></pre></td></tr></table></figure></p><h2 id="JSON相关注解代码"><a href="#JSON相关注解代码" class="headerlink" title="JSON相关注解代码"></a>JSON相关注解代码</h2><h3 id="RestController"><a href="#RestController" class="headerlink" title="@RestController"></a>@RestController</h3><p>等价于@Controller + @ResponseBody<br>在类上直接使用 @RestController ，这样子，里面所有的方法都只会返回 json 字符串</p><h3 id="GetMapping"><a href="#GetMapping" class="headerlink" title="@GetMapping"></a>@GetMapping</h3><p>获取get请求<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@RestController</span><br><span class="line">public class UserController &#123;</span><br><span class="line"></span><br><span class="line">   @GetMapping(value = <span class="string">"/json"</span>)</span><br><span class="line">   public String json() throws JsonProcessingException &#123;</span><br><span class="line">       ObjectMapper mapper = new ObjectMapper();</span><br><span class="line">       User user = new User(<span class="string">"zhangsan"</span>, 17, <span class="string">"男"</span>);</span><br><span class="line">       //将对象解析成为json格式</span><br><span class="line">       String str = mapper.writeValueAsString(user);</span><br><span class="line">       //@ResponseBody,json格式返回</span><br><span class="line">       <span class="built_in">return</span> str;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="处理默认时间对象类型"><a href="#处理默认时间对象类型" class="headerlink" title="处理默认时间对象类型"></a>处理默认时间对象类型</h2><p>Jackson默认Date date默认使用timestamps（时间戳：1970年01月01日00时00分00秒起至现在的总毫秒数）形式 。<br>自定义时间显示类型<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">@RequestMapping(<span class="string">"/json"</span>)</span><br><span class="line">public String json() throws JsonProcessingException &#123;</span><br><span class="line"></span><br><span class="line">   ObjectMapper mapper = new ObjectMapper();</span><br><span class="line"></span><br><span class="line">   //不使用时间戳的方式</span><br><span class="line">   mapper.configure(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS, <span class="literal">false</span>);</span><br><span class="line">   //自定义日期格式对象</span><br><span class="line">   SimpleDateFormat sdf = new SimpleDateFormat(<span class="string">"yyyy-MM-dd HH:mm:ss"</span>);</span><br><span class="line">   //指定日期格式</span><br><span class="line">   mapper.setDateFormat(sdf);</span><br><span class="line"></span><br><span class="line">   Date date = new Date();</span><br><span class="line">   String str = mapper.writeValueAsString(date);</span><br><span class="line"></span><br><span class="line">   <span class="built_in">return</span> str;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>面向对象封装、以及方法重载便于以后使用<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class JsonUtils &#123;</span><br><span class="line"></span><br><span class="line">    public static String getJson(Object object) throws JsonProcessingException &#123;</span><br><span class="line">        <span class="built_in">return</span> getJson(object,<span class="string">"yyyy-MM-dd HH:mm:ss"</span>);//默认时间显示形式</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //第一个参数为时间对象，第二个参数为时间显示形式</span><br><span class="line">    public static String getJson(Object object, String dateFormat) throws JsonProcessingException &#123;</span><br><span class="line">        ObjectMapper mapper = new ObjectMapper();</span><br><span class="line">        mapper.configure(SerializationFeature.WRITE_DATE_KEYS_AS_TIMESTAMPS,<span class="literal">false</span>);</span><br><span class="line">        SimpleDateFormat simpleDateFormat = new SimpleDateFormat(dateFormat);</span><br><span class="line">        mapper.setDateFormat(simpleDateFormat);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">return</span> mapper.writeValueAsString(object);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>后续使用<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@RequestMapping(<span class="string">"/json"</span>)</span><br><span class="line">public String json5() throws JsonProcessingException &#123;</span><br><span class="line">   Date date = new Date();</span><br><span class="line">   String json = JsonUtils.getJson(date);</span><br><span class="line">   <span class="built_in">return</span> json;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> JSON </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JSON </tag>
            
            <tag> JSON时间对象 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MVC、MVP、MVVM架构模式与多层架构</title>
      <link href="/2019/07/21/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/"/>
      <url>/2019/07/21/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/</url>
      
        <content type="html"><![CDATA[<h2 id="架构模式"><a href="#架构模式" class="headerlink" title="架构模式"></a>架构模式</h2><h3 id="概要："><a href="#概要：" class="headerlink" title="概要："></a>概要：</h3><p>MVC、MVP、MVVM是传统较为主流的三种架构模式，使用架构模式的目的是为了解决界面呈现和逻辑代码分离问题，其中MVP和MVVM都是在MVC的基础上发展而来的，引发发展的主要原因在于各个模块间的耦合度、模块测试引发的问题。  </p><h3 id="MVC-："><a href="#MVC-：" class="headerlink" title="MVC ："></a>MVC ：</h3><p>MVC(全名：Model View Controller),正如名字一样MVC是使用Model、View、Controller三个模块设计创建 Web 应用程序的模式。<br>三个模块介绍及功能：<br>模型(Model):提供可视化元素的呈现、处理部分逻辑，包含数据和行为，可以认为是领域模型(domain)或JavaBean组件。通俗的讲就是用于网络请求、数据库、业务逻辑处理等操作并对应应用状态和业务功能的封装以及提供View模块显示的数据。如果对java熟悉的话Model模块最直观的部分就是JavaBean中的实体类和DAO类方法了。<br>视图（View）:数据的展示、提供用户数据显示及操作的可视化界面。（比如jsp页面）<br>控制器（Controller）:接受用户的输入指令并调用模型模块和视图模块去完成用户的需求。可以将控制器理解为模型模块和视图模块之间的桥梁，通过控制器管理两个模块的交互，是设计这类构架模式的基础分层目的的模块，一定程度上降低了耦合度、提高了代码重复利用率。<br><img src="/img/MVC.PNG" alt="MVC架构模式alt">  </p><h3 id="MVP"><a href="#MVP" class="headerlink" title="MVP :"></a>MVP :</h3><p>MVP(全名:Model-view-presenter),是MVC演变而来的一种软件设计模式。与MVC有一定的相似性：Presenter负责逻辑的处理，Model提供数据，View负责显示。但MVP与MVC有着一个重大的区别：在MVP中View并不直接使用Model，它们之间的通信是通过Presenter(MVC中的Controller)来进行的，所有的交互都发生在Presenter内部， 从理论上去除了View和Model的耦合。<br>模块介绍及功能：<br>Model：负责存储、检索、操纵数据，但与MVC的Model不同的是MVP的Model与可视化元素的呈现无关，与UI（view）处理逻辑也无关。<br>View：数据的展示、提供用户数据显示及操作的可视化界面，同时含有一个Presenter成员变量及逻辑接口<br>Presenter：处理与用户交互的负责逻辑。相比于MVC的controller，除了相同的事件触发控制功能，由于去除了View和Model的交互，所有的交互功能都发生在了Presenter（从Model传递需要呈现的可视化元素、View逻辑执行后发送响应等等）。由于解除了View与Model的耦合性，开发者可模拟测试View和Model中的任意一个模块，但明显的是Presenter接口与实现类的增加导致代码冗余度、复杂度会有明显增加。<br><img src="/img/MVP.PNG" alt="MVP架构模式alt">  </p><h3 id="MVVM"><a href="#MVVM" class="headerlink" title="MVVM :"></a>MVVM :</h3><p>MVVM(全名:Model View ViewModel)MVVM是MVP的进一步发展与规范，实现了View和Model的自动同步。MVVM模式中，一个ViewModel和一个View匹配绑定，所有View中的修改变化，都会自动更新到ViewModel中，同时ViewModel的任何变化也会自动同步到View上显示(ViewModel中的属性都实现了observable这样的接口，当使用属性 的set的方法，都会同时触发属性修改的事件，使绑定的View自动刷新，一般由不同的前端框架平台封装例如VUE。)，ViewModel和View之间的交互通过Data Binding完成， 而Data Binding可以实现双向的交互,这就使得视图和控制层之间的耦合程度进一步降低。<br>三个模块介绍及功能：<br>Model：负责存储、检索、操纵数据。<br>View：数据的展示、提供用户数据显示及操作的可视化界面，通过通过模板语法来声明在ViewModel模块完成数据绑定。<br>ViewModel：处理与用户交互的负责逻辑，核心是双向数据绑定，去除了View与Model的耦合关联，View可以独立于Model变化和修改方便测试，同时降低了代码的冗余度增加了重用度。<br><img src="/img/MVVM.PNG" alt="MVVM架构模式alt">  </p><h2 id="多层架构"><a href="#多层架构" class="headerlink" title="多层架构"></a>多层架构</h2><p>多层架构是开发人员在开发过程当中面对复杂且易变的需求采取的一种以隔离控制为主的应对策略，具体显示为将业务划分为多个层。  </p><h3 id="3层架构-3-tier-architecture"><a href="#3层架构-3-tier-architecture" class="headerlink" title="3层架构(3-tier architecture)"></a>3层架构(3-tier architecture)</h3><p>三层架构(3-tier architecture) 通常意义上的三层架构就是将整个业务应用划分为：界面层（User Interface layer）、业务逻辑层（Business Logic Layer）、 数据访问层（Data access layer）。<br>各层功能：<br>UI(界面层): 数据的展示、提供用户数据显示及操作的可视化界面。用于接收用户输入的数据和显示处理后用户需要的数据。<br>BLL:(业务逻辑层): UI层和DAL层之间的交互通道。对数据层的操作，对数据业务逻辑处理。<br>DAL:(数据访问层): 实现对数据的增、删、改、查。将存储在数据库中的数据提交给业务层，同时将业务层处理的数据保存到数据库。<br><img src="/img/3-tier-architecture.PNG" alt="三层架构alt"><br>大多数人三层架构易与架构模式混淆（尤其是MVC模式），从表示图可以直观看出它们间区别。架构模式（MVC）设计初衷是降低View与Model间的耦合度、降低代码冗余度、提高数据访问安全性。而三层架构是从整个业务应用出发，架构模式例如MVC只是三层架构中的UI（界面层）和BLL(业务逻辑层)展示。（很多博客文章表示MVC严格意义上 只是三层架构的UI界面层，MVC的Model模块实现了业务逻辑的处理和对数据层的操作）用图表示之间关系如下(下图表示基于B/S系统的三层架构，橙线表示对B/S系统的划分)。<br><img src="/img/emm.PNG" alt="三层架构alt">  </p><h3 id="2-2-多层架构-n-tier-architecture"><a href="#2-2-多层架构-n-tier-architecture" class="headerlink" title="2.2 多层架构(n-tier architecture)"></a>2.2 多层架构(n-tier architecture)</h3><p>简单的说多层架构是对三层架构的进一步划分，实际中有时“标准”的划分为三层架构会对维护调试带来很多麻烦，多层架构便是对三层架构中的UI（界面层）与BLL（业务逻辑层）进行进一步细分。</p><h2 id="java的三层架构"><a href="#java的三层架构" class="headerlink" title="java的三层架构"></a>java的三层架构</h2><p>也属于三层架构各个层的名字有所变化。<br>Struts（表示层）：Struts是一个表示层框架，主要作用是界面展示，接收请求，分发请求为用户提供一种交互式操作的界面。在MVC框架中，Struts属于VC层次，负责界面表现，负责MVC关系的分发。<br>Spring（业务层）：业务层框架，是一个整合的框架，能够很好地黏合表示层与持久层。<br>Hibernate（持久层）：持久层，有时候也称为是数据访问层，其功能主要是负责数据库的访问，可以访问数据库系统、二进制文件、文本文档或是XML文档。</p><p>学期末学习了MVC架构模式有感，也算完成了自己的第一篇博客，当作知识积累日志。<br>参考学习文章：<a href="https://www.runoob.com/w3cnote/three-tier-architecture.html" target="_blank" rel="noopener">https://www.runoob.com/w3cnote/three-tier-architecture.html</a><br>参考学习文章：<a href="https://www.jianshu.com/p/ebd2c5914d20" target="_blank" rel="noopener">https://www.jianshu.com/p/ebd2c5914d20</a></p>]]></content>
      
      
      <categories>
          
          <category> 架构模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MVC </tag>
            
            <tag> MVP </tag>
            
            <tag> MVVM </tag>
            
            <tag> 三层架构(3-tier application) </tag>
            
            <tag> 多层架构(n-tier application) </tag>
            
            <tag> 架构模式 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
